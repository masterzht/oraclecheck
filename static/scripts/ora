#!/bin/bash
#
# Copyright (c) 2018, 2028, YanKu IT HangZhou Ltd.  All rights reserved.
# Author: chongzi
# 2021-11-15 3.7.5 add s or S to logon on database
# 2021-10-21 3.7.5 add 4030 sqlmon
# 2021-10-13 3.7.4 modify table/tab
# 2021-10-13 3.7.4 modify ddl/get_ddl
# 2021-10-13 3.7.4 add active , Show Active Session and SQL For Current Node.
# 2021-10-13 3.7.4 add ORA/ora <ErrorNumber>
# 2021-06-18 3.7.3 add awrsqrpt
# 2020-11-06 3.7.2 load command enhencement
# 2020-11-06 3.7.1 new command logon, calculate logon frequency using listener.log
# 2020-11-03 3.7   column width adjust
# 2020-09-17 3.6.4 merge sga_stats into sga
# 2020-09-14 3.6.3 fix bug for ddl partitioned table
# 2020-08-19 3.6.2 add get timestamp bind value from v#SQL_BIND_CAPTURE
# 2020-08-12 3.6.1 new command highparse2, find top CPU SQL with same force_matching_signature (sql not using bind variables)
# 2020-08-06 3.6   fix column display width in 11204
# 2020-06-01 3.5.2 fix column display width in 12.2
# 2020-05-28 3.5   review all command ; ddl support interactive; fix bugs......
# 2020-05-22 3.2.2 fix recover(display instance smon recover progress) bug
# 2020-05-06 3.2.1 sep sql_check and sql_check_his
# 2020-05-06 3.2.0 sql_check add 2 charater: filter and hash join
# 2020-03-24 3.1.7 modify default lock command not to display object/rowid info, use -a to display
# 2020-03-24 3.1.6 new command snap or snapshot;new commang awr_baseline
# 2020-03-23 3.1.5 fix bug for lock command :dedup for lack of inst_id condition, contributed by Albert Liang
# 2020-03-17 3.1.4 new command mon_bind ;new command pc2 (show if current phv is the best)
# 2020-03-16 3.1.3 rewrite new pc,rename pc to pc_old
# 2020-03-15 3.1.2 to support sql_patch opt_param ,fix bug
# 2020-03-13 3.1.1 session command add sql_text (running)
# 2020-02-20 3.1.0 rename cursor_share to high_version,add get single sql_id info ;  fix if sqlhc.sql file exist bug
# 2020-02-20 3.0.9 fix bug and enhencement(lock command)
# 2020-01-11 3.0.8 fix bug and enhencement
# 2020-01-08 3.0.7 fix bug and enhencement
# 2020-01-06 3.0.6 sql_check ; enhencement
# 2020-01-02 3.0.4 fix bug
# 2019-12-26 3.0.3 enhencement
# 2019-12-17 3.0.2 new command [expdash]
# 2019-12-16 3.0   ==========================add sql check=========================
# 2019-12-16 2.0.3 add spool to log for most operation
# 2019-12-14 2.0.1 adjust [sql] command ,add event info from gv_active_session_history; new command [dup_index]
# 2019-12-09 2.0   =========================add -a -s -i option====================
# 2019-12-08 1.3.0 add [table] an interactive mode : ora table <tab_name> [owner] ; add -e mode; rename index to [tabidx]; new commmand index ;
# 2019-12-07 1.2.9 add [awr] an interactive mode
# 2019-12-05 1.2.8 new command : [resize] :resize datafile to shrink tablespace(just show command,no execute)
# 2019-12-03 1.2.7 new command : [sql_baseline]
# 2019-12-01 1.2.6 new command : [col] display column info
# 2019-11-27 1.2.5 support sql_patch for 12.2+
# 2019-11-22 1.2.2 new command : tbs_frag
# 2019-11-14 1.2.0 adjust many column display format; new command : process ,session ; change xpo and xo to my code mode;fix awr bug(12c)
# 2019-11-10 1.1.7 new command : dir
# 2019-11-10 1.1.6 new command : iostat (only for 12.1 and below version)
# 2019-11-08 1.1.5 new command : file/files
# 2019-11-05 1.1.4 new command : toparea_by_sig ; topsql_by_plan
# 2019-11-04 1.1.3 tophis command,order by cpu|read|time 3 option ;load command add db_cpu and db_time 2 column
# 2019-11-03 1.1.2 new command events: batch display awr top 5 events
# 2019-11-01 1.1.1 highparse add sql_id column;
# 2019-10-30 1.1.0 new command : big_by_tbs ;fix sparse_table bug ;rename ashsession to ash; rename dashsession to dash;rename segment to seg
# 2019-10-23 1.0.9 adjust output display format for : load
# 2019-10-22 1.0.8 new command : xo (xplan_awr) / xpo (xplan_cursor) (add execution order column in execution plan);sql command: column adjust
# 2019-10-14 1.0.6 new command : drop  profile|patch|baseline  <name>
# 2019-10-09 1.0.5 fix some display issue; new command  stat
# 2019-10-04 1.0.4 new command  sparse_index , sparse_table , hintname; check command add foreign key no index
# 2019-09-29 1.0.3 new command : load (awr load profile,in batch mode), top_seg (awr segment order by ,in batch mode)
# 2019-09-22 1.0.1 new command :tbs_usage (fast but may not accurate), tbs_last (from snapshot,fast but may not accurate)
# 2019-09-18 1.0.0 fix few bugs
usage()
{
  echo "
  Usage: ora <command> [<arguments>] or ora [-u user/pass] <command> [<arguments>]
  e.g. : ora check     or   ora -u system/password sqlhc <sqlid1> [sqlid2] [sqlid3]

    General
      -u user/pass                             use USER/PASS to log in
      [] is the default ;  <> is a must

    Commands list:
      - 10046                                  gather 10046 trace
      - 4030                                   diagnositic ora-4030 problem
      - 4031                                   diagnositic ora-4031 problem
      - active                                 Show Active Session and SQL For Current Node
      - alert [2]day                           alert.log ORA- info in recent 2(default) days (v\$diag_alert_ext)
      - app                                    displays application configuration level information such as Sequence No Cache..
      - ashdump  [1]min                        dump ash records into trc file,default value is 1 minutes
      - asm                                    Show asm space/free space
      - awr [bid] [eid]                        ora awr bid eid (all nodes and RAC),top 50 sql;default is last 2 snapshots interval
      - awrsqrpt [bid] [eid] [sql_id]             ora awrsqrpt bid eid sql_id (all nodes), display awrsqrpt html and text information
      - awrsnap | listsnap  [3]                list snapshots of recent [3] days,alias : listsnap
      - awr_baseline [bid] [eid]               create an awr baseline for given bid eid

      - batch_osstat [48]|<bid> <eid>          awr osstat in batch mode(similiar with AWR osstat),fixed 48 snaps or given bid and eid
      - batch_event  [48]|<bid> <eid>          awr top 5 event in batch mode,fixed 48 snaps or given bid and eid,exe ./ora -i 2 batch_event
      - batch_load   [48]|<bid> <eid>          awr load profile in batch mode,fixed 48 snaps or given bid and eid
      - batch_iostat [48]|<bid> <eid>          awr top 5 reads tablespace in batch mode (awr: Tablespace IO Stats) 12.1 and below

      - big_by_tbs <tbs_name> [20]             top n big size objects by tablespace name
      - bind | binds <sql_id>                  display bind capture information for  specified cursor

      - check                                  unusable indexes,etc.
      - cputime                                cputime by day / by top
      - cursor_summary                         summarize stats about (un)pinned cursors

      - dblink/db_link/link                    show dblink Information
      - dbtime                                 dbtime by day / by top
      - ddl  <name> [owner] [type]             DDL info : dbms_metadata.get_ddl (Case Insensitive); all interactive mode
      - ddl/get_ddl <name>                     DDL info : dbms_metadata.get_ddl (Case Insensitive); all interactive mode
      - degree | parallel                      degree of objects (tables and indexes) ,and running parallel processes
      - dg | dg_info                           data guard :contributed by Albert Liang
      - dir                                    show all directories info
      - drop patch|profile|baseline <name>     drop sql patch/sql profile/sql plan baseline
      - dpr_risk [100]                         simple find direct path read risk (blocks > 0.8*_small_table_threshold and exes> 100 /day )
      - dup_index <owner>

      - event                                  v\$session summary by event
      - event2sqlid <event_name> <bid> <eid>   dba_hist_active_sess_history, such as ./ora event2sqlid \"db file sequential read\" 560 561
      - event_set                              list all event for alter system set events or set event=
      - expdash \"2020/05/27 10:33:40\" 30     12.2+ only ; to default DIR ; listed in term

      - feature                                about:db link/trigger/partition/compress/temporary/sqlpatch/profile/baseline..
      - file | files                           list spfile/control_file/datafile/tempfile names
      - fulltext  <sql_id>                     display the entire sql_id SQL text(lob),no more than 32767(v\$.sql_text has a limit of 1000)
      - gather <owner> <table_name>            gather table stats(cascade=>true,no_invalidate=>false)

      - histogram <owner><tab_name><col_name>  get histogram value ratio
      - highparse  [500]                       ora highparse  <500 is default> ,top 50 only (same force_matching_signature ,diff sql_id)
      - highcost [50]                          high cost sql in gv#sql_plan
      - high_version [100]                     display information for reasons cursor not shared (single sqlid: ora sharing <sqlid>)
      - hintname <part of hint name>           get hint info from v\$sql_hint
      - systemdump/hanganalyze                 hanganalyze 3 + systemdump 266

      - idx2sqlid <index_name>                 show sqls use the given index name
      - ind | index <table_name>               get all indexes info for given table
      - index_creating                         index is creating

      - job                                    show all jobs
      - longops                                show records in gv\$session_longops (running)
      - lock|blocker|wait_chain                show blocked rows and blocked chains
      - lob                                    show top space used lob segment
      - lobfree <owner><lobname>               display free space for give securefile lob segmentname(no basicfile type) need \\$\\$

      - mvsnap                                 view all_snapshots (mview) status
      - sqlmon/sqlmonitor                      <sql_id> get v#sql_monitor Information

      - obj  <part of obj info>[owner]         view detail info for given part of a object_name  ,need %
      - open_cursor [100]                      top 30 ,default >100
      - outline  <profile|patch> <name>        ora outline profile|patch name,get hint set (no sql_plan_baseline)
      - ORA  <Error Number>                    Display processing Ideas for Current ORA-ErrorNumber such ./ora ORA 00020

      - params [<pattern>]                     view all parameters, even hidden ones
      - parameter [<pattern>] [2]              parameters in his(recent 2 snap) and current
      - pc/whats_changed/plan_changed  [8]     get plan changed in recent [def 31] days
      - pc2 [8]                                if last_active phv is the best
      - pga [50]                               top 50 pga_used_mem
      - pga_detail <os_pid>|-mem <size_M>      Gives details on how PGA memory is consumed by a process (given its os PID) : ora pga_detail <pid>
                                               or by the set of precesses consuming more than <size_mb> MB of PGA memory   : ora pga_detail -mem 100
      - pid  <pid>                             show detailed pid(from OS) info
      - print_table <sql_text>                 display sql result in single column mode(note: when v\$ view used,\\is needed)
      - process <pid>                          process detail info ,in print_table mode
      - process_dump <pid> <level>
      - processes [<min_mb>]                   display process pga memory info; similiar with pga
      - purge <sql_id>                         SYS.DBMS_SHARED_POOL.PURGE

      - raw <date|varchar2|number> <value>     ora raw date raw_data_string
      - redo                                   redo info : generate frequence
      - recover_state|recover                  gv\$fast_start_transactions,recover progress
      - resize                                 show smallest size all datafile can shrink to
      - repeat <interval> <count|forever>      Repeat an coomand <count> time,Sleep <interval> between two calls
              <ora_command>                    E.g. ora repeat 5 100 temp
      - rman                                   rman status and RECOVERY_FILE_DEST info

      - seq                                    show sequences have bad setting (order_flag='Y' or cache_size<=20)
      - seg <object_name>                      segment info for given object
      - session  <sid>                         session detail info ,in print_table mode,in rac ,-i maybe needed
      - sessions [all]|<active>                ora sessions [active](def)|all  (active:also no BACKGROUD)
      - session_event [all]|<noidle>|<px>      ora session_event | ora session_event px | ora session_event noidle
      - snapper \"12:10\" 40                   AAS
      - sh                                     Run a shell command. E.g.  ora repeat 2 5 sh 'ps -edf | grep DESC'
      - sharing <sql_id>                       print why cursors are not shared ; high_version diag
      - sga                                    tell how much sga memory is used and dynamically used
      - snap|snapshot                          dbms_workload_repository.create_snapshot
      - sparse_index
      - sparse_table
      - sql <sqlid>                            display sql information
      - sql_baseline <sqlid> <sqlid> <PHV>
      - sql_check
      - sql_check_his
      - sql_patch <sqlid> <hint>               ora sql_patch <sqlid> <hint>
      - sql_profile <sqlid> <sqlid> <PHV>      ora sql_profile <sqlid> <sqlid> <PHV> --->fix use given plan
      - sqlhc <sqlid1> [sqlid2] [sqlid3]...    collect sqlhc for given sqlids
      - stats                                  show infomation about stats collection
      - sysmetric \"yyyy/mm/dd hh24:mi\" [30]    DBA_HIST_SYSMETRIC_HISTORY from given time last for default 30 minutes

      - table/tab  <tab_name> [owner]          show detail info for given table
      - tabidx    <table_name>                 get table index info
      - tbs_last                               fast show tablespace info from dba_hist_tbspc_space_usage last snapshot
      - tbs_usage                              fast get tablespace usage
      - tbs_frag                               tablespace fragment info
      - tbs                                    view all tablespace detail info
      - tbsinc                                 display total tablespace size by day
      - temp                                   view detail usage of temp tablespace
      - top                                    displays the latest time and the specified logical read SQL( default 10000)
      - toparea                                top sql in gv\$sqlarea : 5cpu/5reads/5elap
      - toparea_by_sig cpu|time|read <topn>    v#sqlarea group by force_matching_signature,topn
      - topsql_by_plan cpu|time|read <topn>    v#sql group by phv

      - tophis cpu|read|time [def max-1] [max] top sql in dba_hist_sqlstat: ora tophis <bid> <eid> (default is last snapshot)
      - tophis_byplan cpu|read|time ...
      - tophis_bysig  cpu|read|time ...
      - toppid [5]                             top command top10, LOCAL top 5(def)
      - topseg [bid] [eid]                     show awr top segment info as AWR Segments by 'logical Reads' and 'physical Reads'
      - top_level <sql_id>                     get sub sql_id by top_level sql_id from dba_hist_active_sess_history
      - text2sqlid <text_piece>                find sql_id for given piece of key sql text
      - trc                                    get trace path

      - undo                                   show undo information
      - user | users                           list all users information
      - xp  <sql_id>                           display_cursor for given sql_id
      - xpo <sql_id> [child_number]            xplan.display_cursor for given sql_id(add execution order column)
      - x   <sql_id>                           display_awr for given sql_id
      - xo  <sql_id> [phv]                     xplan.display_awr for given sql_id (add execution order column)

  NOTE
  ================
    - Set environment variable DBUSER to change default connect string which  is \"/ as sysdba\"
    - Set environment variable ORA_TMP to the default temp directory (default if /tmp when not set)
"
#echo "sed -n /\"^if \[ \\\"\\\$1\"/p ora|awk '{print \$5 \"            \" \$9}'|sort"
}

##################################################################################

EXEC_NAME=`basename $0`
ORA_PROG=$0
ARGS=""
T_TRC="/tmp"

if [ "$DBUSER" = "" ]; then
  DBUSER="/ as SYSDBA"
  #DBUSER="user/password@xxx"
  #sys/oracle@localhost:1521/pdb_tiger as sysdba
fi

if [ "$ORA_TMP" = "" ]; then
  ORA_TMP="/tmp"
fi

##########################################
#very important init parameter
#filedate=`date +"%Y%m%d_%H%M%S"`
filedate=`date +"%Y%m%d"`
ECHO=""
DEFNODISP="--"
DEFDISP=""
INST="1"
#DEBUG="#"

#########################################################################
while [ 1 ]; do
  case "$1" in
    "-u")
      ARGS="$ARGS $1 $2"
      DBUSER=$2
      shift
      ;;

    "-e")#echo sql
      ECHO=";"
      ;;

    "-a") #all
      DEFNODISP=""
      ;;

    "-s") #simple
      DEFDISP="--"
      ;;

   # "-d")
   #   DEBUG=""
   #   ;;

    "-i")
      ARGS="$ARGS $1 $2"
      INST=$2
      shift
      ;;
    *)
      break
      ;;
  esac
  shift
done

##############################################################################
#echo "instance_number=$INST"

if [ $# -lt 1 ]; then
  usage
  exit 1
fi

###usage ver2=`get_ver 2` / ver4=`get_ver 4`
function get_ver
{
    version=`echo "select 12345||trim(version) as ver from PRODUCT_COMPONENT_VERSION where product like 'Oracle%';" | sqlplus -s $DBUSER|grep 12345|cut -c 6-13`
    #echo $version
    echo $version|cut -c 1-$1
    #ver2=`echo $version|cut -c 1-2`
    #ver4=`echo $version|cut -c 1-4`
}

###############################################################################
##this is just a template,if you add new command ,just copy and replace with your own script:
################################################################################
if [ "$1" = "test" ]; then
#  echo "instance_number=$INST"
## if [ "$2" = "" ]; then
##   echo "ora $1 xxx"
##   exit 1
## else
##   PRED="$2"
## fi

   echo ORACLE_SID=$ORACLE_SID

   ver2=`get_ver 2`
   ver4=`get_ver 4`
   ver8=`get_ver 8`
   #echo $ver2
   #echo $ver4
   #echo $ver8

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    set head off

    select 'DB_version='||'$ver8' from dual;
    $ECHO
!
exit 0
fi

if [ "$1" = "batch" ]; then
ora batch_load
ora batch_osstat
ora batch_event
ora -i 2 batch_load
ora -i 2 batch_osstat
ora -i 2 batch_event
echo "over"
exit 0
fi


################################################################################
if [ "$1" = "logon" ]; then
   if [ "$2" = "" -o "$3" = "" ]; then
     echo "usage: ora logon \"03-NOV-2020 11:3\" sec  or ora logon \"03-NOV-2020 11\" min"
     exit 1
  else
    datestr=$2
  fi

   logfile=`lsnrctl status|grep "Listener Log File"|awk '{ print $4 }'|sed -e 's/alert\/log.xml/trace\/listener.log/g'`

   if [ "$3" = "sec" ]; then
     #by seconds
     fgrep "$datestr" $logfile | fgrep "establish" | awk '{ print $1 " " $2 }'|  sort | uniq -c
   else
     #by minutes
     fgrep "$datestr" $logfile | fgrep "establish" | awk '{ print $1 " " $2 }'| awk -F: '{ print $1 ":" $2 }' | sort | uniq -c
   fi
exit 0
fi

################################################################################
if [ "$1" = "s" -o "$1" = "S" ]; then
  $ORACLE_HOME/bin/sqlplus / as sysdba
fi
################################################################################
if [ "$1" = "dg_info" -o "$1" = "dg" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

Pro DataGuard Config Info:
Pro
    set pagesize 200
    set linesize 200
    col name for a30
    col display_value for a100
select name, display_value
  from (select name, display_value
          from v\$parameter
         where name in ('log_archive_config',
                        'db_file_name_convert',
                        'log_file_name_convert',
                        'fal_client',
                        'fal_server')
            or name like 'log_archive_dest%'
            or name like 'log_archive_dest_state_1%'
         order by 1 desc
    )
 where display_value is not null AND display_value !='enable';

Pro DataGuard RunTime Apply Info:
Pro

set linesize 400
set serveroutput on
set feedback off
declare
    v_database_role varchar2(100) :=null;
    v_open_mode varchar2(100) :=null;
    v_protection_mode  varchar2(100) :=null;
    v_switchover  varchar2(100) :=null;
    v_force_logging varchar2(100) :=null;

  cursor c_lag is select inst_id,name,value from gv\$dataguard_stats where name like '%lag%' order by inst_id,name;
  v_lag c_lag%rowtype;
  cursor c_dest_error is select inst_id,dest_name,
  decode(regexp_substr(destination,'((25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))\.){3}(25[0-5]|2[0-4]\d|((1\d{2})|([1-9]?\d)))'),null,destination,'Exception') as destination,
  decode(error,null,'None',error) as error
  from gv\$archive_dest where destination is not null order by dest_id;
  v_dest_error c_dest_error%rowtype;

  cursor c_standby_lag is select inst_id,lpad(name,14) as name , value from gv\$dataguard_stats where name like '%lag%' order by inst_id,name;
  v_standby_lag c_standby_lag%rowtype;
  cursor c_standby_max_seq is select thread#, max(sequence#) as mseq from v\$archived_log where applied='YES' group by thread#;
  v_standby_max_seq c_standby_max_seq%rowtype;
  cursor c_mrp is select thread#,process,status,sequence#,block#,blocks from v\$managed_standby where PROCESS like 'MRP%' order by sequence#;
  v_mrp c_mrp%rowtype;
  cursor c_convert is select q'[alter system set ]' || name || q'[ = ']' || replace(value,', ',''',''') || q'[' scope=spfile;]' command from v\$parameter where name in ('log_file_name_convert','db_file_name_convert');
  v_convert c_convert%rowtype;

  cursor c_runtime_apply_info is select thread# as thread,
       DB_UNIQUE_NAME,
       DEST_NAME,
       TARGET,
       DATABASE_MODE,
       error,
       DESTINATION,
       RECOVERY_MODE,
       GAP_STATUS,
       Last_Archived,
       APPLIED_SEQ# as APPLIED_SEQ,
       current_scn,
       applied_scn,
       to_char((scn_to_timestamp(current_scn)), 'yyyymmdd hh24:mi:ss') current_scn_time,
       to_char((scn_to_timestamp(applied_scn)), 'yyyymmdd hh24:mi:ss') applied_scn_time,
       extract(day from(scn_to_timestamp(current_scn) - scn_to_timestamp(current_scn))) * 24 * 60 +
       extract(hour from(scn_to_timestamp(current_scn) - scn_to_timestamp(current_scn))) * 60 +
       extract(minute from(scn_to_timestamp(current_scn) - scn_to_timestamp(applied_scn))) as DELAY_TIME_MINUTE
from
(SELECT al.thread#,
               ads.dest_id,
               ads.DEST_NAME,
               ads.TYPE || ' ' || ad.TARGET TARGET,
               ADS.DATABASE_MODE,
               ads.STATUS,
               ads.error,
               ads.RECOVERY_MODE,
               ads.DB_UNIQUE_NAME,
               ads.DESTINATION,
               ads.GAP_STATUS,
               (SELECT sequence#
                  FROM v\$log na
                 WHERE na.thread# = al.thread#
                   and status = 'CURRENT') Current_Seq#,
               Last_Archived,
               al.APPLIED_SEQ#,
               ad.applied_scn,
               current_scn
          FROM (SELECT dest_id,
                       thread#,
                       d.current_scn,
                       MAX(sequence#) Last_Archived,
                       max(CASE
                             WHEN APPLIED = 'YES' THEN
                              sequence#
                           end) APPLIED_SEQ#
                  FROM v\$archived_log V, v\$database d
                 WHERE V.resetlogs_change# = d.RESETLOGS_CHANGE#
                 group by dest_id, thread#, d.current_scn
                ) al,
               v\$archive_dest_status ads,
               v\$archive_dest AD
         WHERE al.dest_id(+) = ads.dest_id
           AND ads.STATUS != 'INACTIVE'
           AND AD.DEST_ID = ADS.DEST_ID
           and ad.APPLIED_SCN <> 0
         ORDER BY al.thread#, ads.dest_id
);
  v_runtime_apply_info c_runtime_apply_info%rowtype;

begin
select database_role,open_mode,PROTECTION_MODE,SWITCHOVER_STATUS,FORCE_LOGGING into v_database_role,v_open_mode,v_protection_mode,v_switchover,v_force_logging from v\$database;

    dbms_output.put_line('DG Information');
    dbms_output.put_line('=======================');
    dbms_output.put_line('DATABASE_ROLE            :   '|| v_database_role);
    dbms_output.put_line('OPEN_MODE                :   '|| v_open_mode);
    dbms_output.put_line('PROTECTION_MODE          :   '|| v_protection_mode);
    dbms_output.put_line('SWITCHOVER_STATUS        :   '|| v_switchover);
    dbms_output.put_line('FORCE_LOGGING            :   '|| v_force_logging);
if v_database_role = 'PRIMARY' then

  dbms_output.put_line('
DataGuard Runtime Apply Info');
  dbms_output.put_line('=======================');
  open c_runtime_apply_info;
    loop fetch c_runtime_apply_info into v_runtime_apply_info;
    exit when c_runtime_apply_info%notfound;

    dbms_output.put_line('Thread#                  :   '|| v_runtime_apply_info.thread);
    dbms_output.put_line('DB_UNIQUE_NAME           :   '|| v_runtime_apply_info.DB_UNIQUE_NAME);
    dbms_output.put_line('DEST_NAME                :   '|| v_runtime_apply_info.DEST_NAME);
    dbms_output.put_line('TARGET                   :   '|| v_runtime_apply_info.TARGET);
    dbms_output.put_line('DATABASE_MODE            :   '|| v_runtime_apply_info.DATABASE_MODE);
    dbms_output.put_line('ERROR                    :   '|| v_runtime_apply_info.error);
    dbms_output.put_line('DESTINATION              :   '|| v_runtime_apply_info.DESTINATION);
    dbms_output.put_line('RECOVERY_MODE            :   '|| v_runtime_apply_info.RECOVERY_MODE);
    dbms_output.put_line('GAP_STATUS               :   '|| v_runtime_apply_info.GAP_STATUS);
    dbms_output.put_line('Primary_Last_Archived#   :   '|| v_runtime_apply_info.Last_Archived);
    dbms_output.put_line('APPLIED_SEQ#             :   '|| v_runtime_apply_info.APPLIED_SEQ);
    dbms_output.put_line('current_scn              :   '|| v_runtime_apply_info.current_scn);
    dbms_output.put_line('applied_scn              :   '|| v_runtime_apply_info.applied_scn);
    dbms_output.put_line('current_scn_time         :   '|| v_runtime_apply_info.current_scn_time);
    dbms_output.put_line('applied_scn_time         :   '|| v_runtime_apply_info.applied_scn_time);
    dbms_output.put_line('DELAY_TIME_MINUTE        :   '|| v_runtime_apply_info.DELAY_TIME_MINUTE);
    dbms_output.put_line('==============================================');
    end loop;
  close c_runtime_apply_info;

  dbms_output.put_line('
Primary Dest_id Error Information');
  dbms_output.put_line('=======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| inst# |' || ' DEST_NAME            ' || '| ERROR                                     |' || ' DESTINATION ADDRESS ' || '|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------');
  open c_dest_error;
    loop fetch c_dest_error into v_dest_error;
    exit when c_dest_error%notfound;
    dbms_output.put_line('| '|| lpad(v_dest_error.inst_id,5) || ' | ' || rpad(v_dest_error.dest_name,20) || ' | ' || rpad(v_dest_error.error,41) || ' | ' || lpad(v_dest_error.destination,19) || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------');
  close c_dest_error;
else
  dbms_output.put_line('
Standby Current Apply Lag Information');
  dbms_output.put_line('=======================');
  open c_standby_lag;
    loop fetch c_standby_lag into v_standby_lag;
    exit when c_standby_lag%notfound;
    dbms_output.put_line('DEST_ID                  :   '|| v_standby_lag.inst_id);
    dbms_output.put_line('DEST_NAME                :   '|| rpad(ltrim(v_standby_lag.name),20));
    dbms_output.put_line('VALUE                    :   '|| rpad(ltrim(v_standby_lag.value),20));
    end loop;
  close c_standby_lag;

  dbms_output.put_line('
alter database recover managed standby database cancel;
alter database recover managed standby database using current logfile disconnect from session;
MRP Processes Status Information');
  dbms_output.put_line('=======================');
  open c_mrp;
    loop fetch c_mrp into v_mrp;
    exit when c_mrp%notfound;
    dbms_output.put_line('thread#                  :   '|| v_mrp.thread#);
    dbms_output.put_line('PROCESS                  :   '|| v_mrp.PROCESS);
    dbms_output.put_line('STATUS                   :   '|| v_mrp.STATUS);
    dbms_output.put_line('SEQUENCE#                :   '|| v_mrp.SEQUENCE#);
    dbms_output.put_line('BLOCK#                   :   '|| v_mrp.BLOCK#);
    end loop;
  close c_mrp;

  dbms_output.put_line('
db_file_name_convert and log_file_name_convert in Physical Standby');
  dbms_output.put_line('=======================');
  open c_convert;
    loop fetch c_convert into v_convert;
    exit when c_convert%notfound;
    dbms_output.put_line(v_convert.command);
    end loop;
  close c_convert;

end if;
end;
/

$ECHO
!
exit 0
fi



##################################show dblink information ##############################################
if [ "$1" = "db_link" -o "$1" = "dblink" -o "$1" = "link" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 300 pagesize 0
set timing off
col owner head OWNER for a15
col db_link head DB_LINK for a25
col username head USERNAME for a20
col host head HOST for a50
col show_dblink_ddl_command for a110
prompt
prompt Show the DBLINK information
prompt =======================
select owner,db_link,username,host,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created from dba_db_links;

prompt Show the DDL of DBLINK creation
prompt =======================
select q'[create public database link ]' || DB_LINK || q'[ connect to ]' || USERNAME || q'[ identified by ]' || 'password using ' || q'[']'||HOST||q'[';]' as show_dblink_ddl_command
from dba_db_links;

-- who is querying via dblink?
-- Courtesy of Tom Kyte, via Mark Bobak
-- this script can be used at both ends of the database link
-- to match up which session on the remote database started
-- the local transaction
-- the GTXID will match for those sessions
-- just run the script on both databases
col GTXID for a38
col username for a28
select /*+ ORDERED */
substr(s.ksusemnm,1,10)||'-'|| substr(s.ksusepid,1,10)      "ORIGIN",
substr(g.K2GTITID_ORA,1,35) "GTXID",
substr(s.indx,1,4)||'.'|| substr(s.ksuseser,1,5) "LSESSION" ,
s2.username,
substr(
   decode(bitand(ksuseidl,11),
      1,'ACTIVE',
      0, decode( bitand(ksuseflg,4096) , 0,'INACTIVE','CACHED'),
      2,'SNIPED',
      3,'SNIPED',
      'KILLED'
   ),1,1
) "STATUS",
substr(w.event,1,18) "WAITING"
from  x\$k2gte g, x\$ktcxb t, x\$ksuse s, v\$session_wait w, v\$session s2
where  g.K2GTDXCB =t.ktcxbxba
and   g.K2GTDSES=t.ktcxbses
and  s.addr=g.K2GTDSES
and  w.sid=s.indx
and s2.sid = w.sid;

$ECHO
!
exit 0
fi

################################################################################
if [ "$1" = "awr_baseline" ]; then

    if [ "$2" = "" -o "$3" = "" ]; then
     ora awrsnap
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 30
    break on startup_time
    select  instance_number,snap_id-1 as begin_snapid,snap_id as end_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,to_char(end_interval_time,'mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi

   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else
    bid=$2
    eid=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    exec dbms_workload_repository.create_baseline($bid,$eid,'baseline_${bid}_${eid}');
    Pro awr baseline ${bid}_${eid} created!

!
exit 0
fi


################################################################################
if [ "$1" = "snap" -o "$1" = "snapshot" ]; then

   read -p "This Command will execute dbms_workload_repository.create_snapshot,cont? y/[n]:" cont

    if [ "${cont}" = "y" -o "${cont}" = "Y" ];then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    exec dbms_workload_repository.create_snapshot();
    Pro dbms_workload_repository.create_snapshot executed!
!
   else
      echo "command canceled"
      exit 1
    fi
exit 0
fi

################################################################################
if [ "$1" = "sqlmon" -o "$1" = "sql_monitor" -o "$1" = "sqlmonitor" ]; then

  if [ "$2" = "" ]; then
    read -p "please input sqlid :" sqlid
    if [ -z "${sqlid}" ];then
      echo "no input,exit"
      exit 1
    fi
  else
    sqlid=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set trimspool on
    col comm format a300
    set long 999999999
    set timing off
    set verify off
    set feedback off
    set time off
    prompt ======================
    prompt = Parallel SQL
    prompt = Executing more than 5 Seconds
    prompt = Use /*+ monitor */ Hint to
    prompt ======================
    SET LONG 1000000
    SET LONGCHUNKSIZE 1000000
    SET LINESIZE 1000
    SET PAGESIZE 0
    SET TRIM ON
    --SET TRIMSPOOL OFF
    SET ECHO OFF
    SET FEEDBACK OFF

    spool ora_sqlmon_'$sqlid'_$filedate.log
/**
    SELECT DBMS_SQLTUNE.report_sql_monitor(
    sql_id       => '$sqlid',
    type         => 'HTML',
    report_level => 'ALL'
    ) AS report
    FROM dual;
**/
    col comm format a200
    set long 999999999
    set linesize 500
    set pages 1000
    col "inst#" for 99
    col SQL_EXEC_START for a14
    col GETS for a7
    col reads for 99999
    SET FEEDBACK ON
    COL "elapsed(ms)" for 999999
    COL "cpu(ms)" for 999999
    SELECT INST_ID as "inst#",
           to_char(SQL_EXEC_START, 'mmdd hh24:mi:ss') SQL_EXEC_START,
           status,
           sql_exec_id,
           SQL_PLAN_HASH_VALUE as PLAN_HASH,
           SID,
           round(ELAPSED_TIME / 1000) as "elapsed(ms)",
           round(CPU_TIME / 1000) as "cpu(ms)",
           round(USER_IO_WAIT_TIME / 1000) as "user_io(ms)",
           round(CLUSTER_WAIT_TIME / 1000) as "cluster(ms)",
           fetches,
           round(buffer_gets / 1024 / 1024) || 'M' as gets,
           disk_reads as reads
      FROM gv\$sql_monitor
     where sql_id = '$sqlid'
     order by SQL_EXEC_START;


    SELECT dbms_sqltune.report_sql_monitor(sql_id       => '$sqlid',
                                           report_level => 'ALL',
                                           type         => 'text') comm
    FROM dual;
spool off
    $ECHO
!
exit 0
fi

################################################################################
if [ "$1" = "toppid" ]; then

  if [ "$2" = "" ]; then
    topn=5
  else
    topn=$2
  fi

    echo "show top $topn ospid detail info:"
    cnt=0
    top -u oracle  -n 1 -b -c |head -50|grep LOCAL|head -$topn|awk '{print $1}' >pids.log
    while read pid
    do
      let cnt=$cnt+1
      echo "top $cnt pid: $pid"
      ora pid $pid
    done < pids.log

exit 0
fi

################################################################################
if [ "$1" = "process_dump" ]; then

  if [ "$2" = "" ]; then

  read -p "Please input pid(v#proces.spid where v#session.paddr=v#process.addr):" pid
        if [ -z "${pid}" ];then
             echo "input error"
             exit 1
        fi
   else
     pid=$2
  fi

  if [ "$3" = "" ]; then

  read -p "Please input dump level [10,256,266] (no default):" level
        if [ -z "${level}" ];then
             echo "input error"
             exit 1
        fi
   else
     level=$3
  fi

sqlplus -s /NOLOG << ! | egrep -v "Statement processed|Function returned|rows selected"

      connect $DBUSER

      oradebug setospid $pid
      oradebug unlimit
      oradebug dump processstate $level
      oradebug tracefile_name
!

exit 0
fi

#####################################################################################################

if [ "$1" = "tophis_byplan" ]; then

   if [ "$2" = "" -o "$2" = "cpu" -o "$2" = "CPU" ]; then
       orderby=cpu_s
   elif [ "$2" = "read" ]; then
       orderby=reads_k
   elif [ "$2" = "time" ]; then
       orderby=etime_s
   fi

   if [ "$3" = "" -o "$4" = "" ]; then
       defeid=`echo "select trim(12345||max(snap_id)) as eid from dba_hist_snapshot ;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
       let defbid=defeid-1
       read -p "Please input begin snap_id,default is [$defbid] (max-1):" bid
        if [ -z "${bid}" ];then
             bid=$defbid
        fi
       read -p "Please input end   snap_id,default is [$defeid] (max):" eid
        if [ -z "${eid}" ];then
             eid=$defeid
        fi

       if [ ${bid} -ge ${eid} ];then
          echo "input error! begin_snap_id:$bid cannot bigger than end_snap_id:$eid"
          exit 1
       fi
       else
        bid=$3
        eid=$4
   fi

   if [ "$5" = "" ]; then
     deftopn=30
     read -p "Please input top sql count,default is[$deftopn]:" topn
        if [ -z "${topn}" ];then
             topn=$deftopn
        fi
     else
      topn=$5
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set linesize 250 pagesize 30
    --set numwidth 20
    col inst format 9999
    col rn format 999
    col min_schema format a10 trunc
    col sqltext format a40 trunc
    col min_sql_id format a14
    col plans format 99
    col app_s format 999
    col conc_s format 9999
    col clu_s format 9999
    col plsql_s format 99999
    col sorts format 999999
    col sqls format 9999
    col CPU_S format 9999999
    col reads_k format 9999999

    spool ora_tophis_byplan_${INST}_${bid}_${eid}_${orderby}.log

    with sql_stat as
    (
     select rownum as RN,v.* from
      (select
          INSTANCE_NUMBER as inst,
          plan_hash_value as PHV,
          round(sum(cpu_time_delta)/1e6)  as CPU_S,
          round(sum(DISK_READS_DELTA)/1000,1)  as reads_k,
          min(sql_id) as min_sql_id,
          count(distinct sql_id) as sqls,
          round(sum(ELAPSED_TIME_DELTA)/1e6)  as etime_s,
          case when sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1) >=1
               then round(sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1))
               else  1  end as avg_elap_ms,
          min(PARSING_SCHEMA_NAME) as min_schema,
          sum(executions_delta) as execs,
          --count(distinct plan_hash_value) as  plans,
          --max(plan_hash_value) as phv,
          round(sum(BUFFER_GETS_DELTA)/greatest(sum(executions_delta),1))  as avg_BUF,
          round(sum(ROWS_PROCESSED_DELTA)/greatest(sum(executions_delta),1),1)  as avg_ROW
          --substr(min(MODULE),1,10) as module,
          --round(sum(IOWAIT_DELTA)/1e6)  as sum_IO_s,
    $DEFNODISP ,round(sum(APWAIT_DELTA)/1e6)  as App_s
    $DEFNODISP ,round(sum(CCWAIT_DELTA)/1e6)  as ConC_s
    $DEFNODISP ,round(sum(CLWAIT_DELTA)/1e6)  as CLu_s
    $DEFNODISP ,round(sum(PLSEXEC_TIME_DELTA)/1e6)  as PLSQL_s
          --round(sum(JAVEXEC_TIME_DELTA)/1e6)  as sum_JAVA_s,
          --round(sum(DIRECT_WRITES_DELTA))  as sum_DIRECT_W,
          --round(sum(PHYSICAL_READ_REQUESTS_DELTA))  as sum_PHY_R_Req,---not support in 10g
          --round(sum(PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
          --round(sum(PHYSICAL_WRITE_REQUESTS_DELTA))  as sum_PHY_W_Req,--not support in 10g
          --round(sum(PX_SERVERS_EXECS_DELTA))  as sum_PX_Svr,
    $DEFNODISP ,round(sum(SORTS_DELTA))  as SORTS
           from dba_hist_sqlstat a
           where snap_id > $bid
             and snap_id <=$eid
             and INSTANCE_NUMBER=$INST
             and plan_hash_value>0
          group by INSTANCE_NUMBER,plan_hash_value
          order by $orderby desc
      ) v where rownum<=$topn
    )
    select a.*,ltrim(nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,100)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** '))) SqlText
    from sql_stat a,dba_hist_sqltext b where a.min_sql_id=b.sql_id order by rn;
    $ECHO

   --Pro Current Max snap_id is :
   --select max(snap_id) as max_snap_id  from dba_hist_snapshot;
    spool off
!
echo "instance_number=$INST"
echo "Above result:Begin snap_id=$bid , End snap_id=$eid , top $topn sql ,ordered by $orderby."
echo "usage: ora [ -i 2 ] tophis_byplan [cpu]|<read>|<time> bid eid [30]"
exit 0
fi

#####################################################################################################
# "id=:1 and type=1" vs "id=:1 and type=2" diff in  force_matching_signature
if [ "$1" = "tophis_bysig" ]; then

   if [ "$2" = "" -o "$2" = "cpu" -o "$2" = "CPU" ]; then
       orderby=cpu_s
   elif [ "$2" = "read" ]; then
       orderby=reads_k
   elif [ "$2" = "time" ]; then
       orderby=etime_s
   fi

   if [ "$3" = "" -o "$4" = "" ]; then
       defeid=`echo "select trim(12345||max(snap_id)) as eid from dba_hist_snapshot ;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
       let defbid=defeid-1
       read -p "Please input begin snap_id[$defbid]:" bid
        if [ -z "${bid}" ];then
             bid=$defbid
        fi
       read -p "Please input end   snap_id[$defeid]:" eid
        if [ -z "${eid}" ];then
             eid=$defeid
        fi

       if [ ${bid} -ge ${eid} ];then
          echo "begin_snap_id:$bid cannot bigger than end_snap_id:$eid  input error!"
          exit 1
       fi
       else
        bid=$3
        eid=$4
   fi

   if [ "$5" = "" ]; then
     deftopn=30
     read -p "Please input top sql count[$deftopn]:" topn
        if [ -z "${topn}" ];then
             topn=$deftopn
        fi
     else
      topn=$5
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set linesize 200 pagesize 30
    --set numwidth 20
    col rn format 999
    col inst format 999
    col min_schema format a10 trunc
    col sqltext format a30 trunc
    col min_sql_id format a14
    col plans format 99
    col app_s format 999
    col conc_s format 9999
    col clu_s format 9999
    col plsql_s format 99999
    col sorts format 999999
    col force_matching_signature format 999999999999999999999999
    col sqls format 9999
    col CPU_S format 9999999
    col reads_k format 9999999

    spool ora_tophis_bysig_${INST}_${bid}_${eid}_${orderby}.log

    with sql_stat as
    (
     select rownum as RN,v.* from
      (select
          INSTANCE_NUMBER as inst,
          force_matching_signature,
          round(sum(cpu_time_delta)/1e6)  as CPU_S,
          round(sum(DISK_READS_DELTA)/1000,1)  as reads_k,
          min(sql_id) as min_sql_id,
          count(distinct sql_id) as sqls,
          round(sum(ELAPSED_TIME_DELTA)/1e6)  as etime_s,
          case when sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1) >=1
               then round(sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1))
               else  1  end as avg_elap_ms,
          min(PARSING_SCHEMA_NAME) as min_schema,
          sum(executions_delta) as execs,
          --count(distinct plan_hash_value) as  plans,
          --max(plan_hash_value) as phv,
          round(sum(BUFFER_GETS_DELTA)/greatest(sum(executions_delta),1))  as avg_BUF,
          round(sum(ROWS_PROCESSED_DELTA)/greatest(sum(executions_delta),1),1)  as avg_ROW
          --substr(min(MODULE),1,10) as module,
          --round(sum(IOWAIT_DELTA)/1e6)  as sum_IO_s,
    $DEFNODISP ,round(sum(APWAIT_DELTA)/1e6)  as App_s
    $DEFNODISP ,round(sum(CCWAIT_DELTA)/1e6)  as ConC_s
    $DEFNODISP ,round(sum(CLWAIT_DELTA)/1e6)  as CLu_s
    $DEFNODISP ,round(sum(PLSEXEC_TIME_DELTA)/1e6)  as PLSQL_s
          --round(sum(JAVEXEC_TIME_DELTA)/1e6)  as sum_JAVA_s,
          --round(sum(DIRECT_WRITES_DELTA))  as sum_DIRECT_W,
          --round(sum(PHYSICAL_READ_REQUESTS_DELTA))  as sum_PHY_R_Req,---not support in 10g
          --round(sum(PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
          --round(sum(PHYSICAL_WRITE_REQUESTS_DELTA))  as sum_PHY_W_Req,--not support in 10g
          --round(sum(PX_SERVERS_EXECS_DELTA))  as sum_PX_Svr,
    $DEFNODISP ,round(sum(SORTS_DELTA))  as SORTS
           from dba_hist_sqlstat a
           where snap_id > $bid
             and snap_id <=$eid--(select max(snap_id)   from dba_hist_snapshot)
             and INSTANCE_NUMBER=$INST
             and force_matching_signature>0
          group by INSTANCE_NUMBER,force_matching_signature
          order by $orderby desc
      ) v where rownum<=$topn
    )
    select a.*,ltrim(nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,50)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** '))) SqlText
    from sql_stat a,dba_hist_sqltext b
    where a.min_sql_id=b.sql_id
    order by rn;
    $ECHO

    select max(snap_id) as max_snap_id  from dba_hist_snapshot;
    spool off
!
echo "instance_number=$INST"
echo "usage: ora tophis_bysig [cpu]|<read>|<time> bid eid"
echo "Get top sql ,ordered by $orderby . Begin snap_id=$bid ; End snap_id=$eid"
exit 0
fi

################################################################################
if [ "$1" = "index_creating" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col owner format a20
    col segment_name format a30
    col segment_type format a20
    col tablespace_name format a20
    select owner,segment_name,segment_type,round(bytes/1024/1024) size_M,tablespace_name
    from dba_segments a where segment_type='TEMPORARY';
    $ECHO
!
echo "ora repeat 10 20 index_creating"
exit 0

fi
################################################################################
if [ "$1" = "expdash" ]; then

   ver4=`get_ver 4`
   ver2=`get_ver 2`
   if [ "$ver4" = "12.2" -o "$ver2" = "18" -o "$ver2" = "19" ]; then
       if [ "$2" = "" -o "$3" = "" ]; then
         #echo "Usage: ora $1 \"`date +"%Y/%m/%d %H:%M:%S" -d "-1hour"`\" 30"
         echo "Usage: ora $1 \"`date +"%Y/%m/%d %H:%M:%S"`\" 30"
         exit 1
       fi

      expdp \"/ as sysdba\" views_as_tables=sys.DBA_HIST_active_sess_history \
           query=\"where sample_time between to_date\(\'$2\',\'yyyy/mm/dd hh24:mi:ss\'\) and to_date\(\'$2\',\'yyyy/mm/dd hh24:mi:ss\'\)+$3/24\" \
           file=expdash_$filedate.dmp version=12.1
   else
     echo "only support version 12.2+,current version is $ver4"
     exit 1
   fi

echo "impdp fred/fred remap_schema=sys:fred"
exit 0

fi

################################################################################
if [ "$1" = "sql_check_his" ]; then
#sys.WRH$_SQL_PLAN.max(snap_id) >  dba_hist_snapshot.max(snap_id) ????
   if [ "$2" = "" -o "$3" = "" ]; then

   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi

   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else
    bid=$2
    eid=$3
  fi

   if [ "$4" = "" ]; then
     rn=50
   else
     rn=$4
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    spool ora_sql_check_his_$filedate.log
    --1+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro Full scan ,high cost,low cardinality(top $rn),missing index:
    col plan_oper format a30
    col OBJECT_NAME format a30
    col sql_id format a13
    col min_sql_id format a13

    with tmp1 as
    (select * from
        (
            select sql_id,plan_hash_value,object_name, operation||' '||options as plan_oper
            --,filter_predicates
            ,cost,cardinality,round(cost/cardinality) ratio
            from sys.WRH\$_SQL_PLAN where
             operation||' '||options in ('TABLE ACCESS FULL','INDEX FAST FULL SCAN',
                                         'TABLE ACCESS STORAGE FULL','TABLE ACCESS INMEMORY FULL')
            and object_owner not in ('SYS') and cost >0 and cardinality >0
            and snap_id >$bid and snap_id<=$eid
            order by ratio desc
        )where rownum<=$rn
    ), tmp2 as
    (select SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO
         from
          (select a.*
                   ,row_number() over (partition by sql_id order by ratio desc) as rnum
           from tmp1 a
           ) where rnum=1
     )--sql_id dedup
     select min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO , count(*) as sql_cnt
     from tmp2
     group by PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO --dedup same force_matching_signature
     order by ratio;
    $ECHO


    --2+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro High card in index,low card "index rowid"(top $rn),suboptimal index:
    with tmp1 as
    (select sql_id,plan_hash_value, OBJECT_NAME,cardinality as index_card,lag_card as lag_card
          ,round(cardinality/lag_card) as ratio from
        (
            select * from
            (
                select sql_id,plan_hash_value, OBJECT_NAME,operation,options ,cardinality,id,parent_id,depth
                ,lag(operation||' '||options) over (partition by sql_id,plan_hash_value order by id) as lag_oper
                ,lag(id) over (partition by sql_id,plan_hash_value order by id) as lag_id
                --,lag(parent_id) over (partition by sql_id,plan_hash_value order by id) as lag_parent_id
                ,lag(cardinality)over (partition by sql_id,plan_hash_value order by id) as lag_card
                from sys.WRH\$_SQL_PLAN
                where cardinality is not null and object_owner<>'SYS'
                     and snap_id >$bid and snap_id<=$eid
            )where operation||' '||options='INDEX RANGE SCAN' and lag_oper like 'TABLE ACCESS BY%INDEX ROWID%'
                and id=lag_id+1 and parent_id=lag_id
                and lag_card is not null
            order by cardinality/lag_card desc
        )where rownum<=$rn
    ),tmp2 as
    ( select SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO
      from
         (select a.*,row_number() over (partition by sql_id order by ratio desc) as rnum
          from tmp1 a
          ) where rnum=1
     )
     select min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO
            ,count(*) as sql_cnt
     from tmp2
     group by PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO
     order by ratio;
    $ECHO

    --3+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    $DEFNODISP Pro Filter with more than 2 suboperations
    $DEFNODISP select distinct sql_id,plan_hash_value
    $DEFNODISP from
    $DEFNODISP (
    $DEFNODISP select sql_id,plan_hash_value,parent_id,count(*)
    $DEFNODISP from sys.WRH\$_SQL_PLAN
    $DEFNODISP where (sql_id,plan_hash_value,parent_id )in
    $DEFNODISP      (
    $DEFNODISP       select sql_id,plan_hash_value,id
    $DEFNODISP       from  sys.WRH\$_SQL_PLAN
    $DEFNODISP       where cardinality is not null and object_owner<>'SYS'
    $DEFNODISP           and snap_id >$bid and snap_id<=$eid and operation='FILTER'
    $DEFNODISP       )
    $DEFNODISP     and OBJECT_OWNER<>'SYS' and snap_id >$bid and snap_id<=$eid
    $DEFNODISP group by sql_id,plan_hash_value,parent_id
    $DEFNODISP having count(*)>1
    $DEFNODISP );
    --4+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    col oper format a20
    col card format 9999999
    col username format a15 trunc
    col child format 99
    Pro hash join with little join big result in little set:
    with tmp0 as
    ( select a.*
              --,row_number() over (partition by sql_id,plan_hash_value order by cost/cardinality desc) as rn
              ,lead(cardinality) over (partition by sql_id,plan_hash_value order by id) as lead_card
        from --gv\$sql_plan a --where sql_id='8fgsm55xftv5g'
             sys.WRH\$_SQL_PLAN a where snap_id >$bid and snap_id<=$eid
    ),
    tmp1 as
    (select object_owner,sql_id,plan_hash_value,id,operation||' '||options as oper,cost,cardinality as card,lead_card
          ,round(cost/cardinality,1) as ratio
     from
        (
        select a.*,row_number() over (partition by sql_id,plan_hash_value order by cost/cardinality desc) as rn
        from tmp0 a
        where operation ='HASH JOIN' and ( options not like '%ANTI%' or options is null)
              and cardinality<1000
        )where rn=1
    )
    select * from
    (select a.object_owner as username,a.*,substr(b.sql_text,1,30) as sql_text
    from tmp1 a, dba_hist_sqltext b
    where a.sql_id=b.sql_id
    and a.object_owner not in ('SYS','DBSNMP')
    order by ratio desc
    )where rownum<=20;

    --5+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    spool off
!
echo "full nodes"
echo "Missing index or suboptimal index,from WRH\$_SQL_PLAN(with snap_id). top $rn"
exit 0
fi


################################################################################
if [ "$1" = "sql_check" ]; then

   if [ "$2" = "" ]; then
     rn=20
   else
     rn=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col inst_id format 9999999
    spool ora_sql_check_$filedate.log
    --1+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro Full scan ,high cost,low cardinality(top $rn),missing index:
    col plan_oper format a25
    col OBJECT_NAME format a30
    col sql_id format a13
    col min_sql_id format a13

    with tmp1 as
    (select * from
        (
            select inst_id,sql_id,plan_hash_value,object_name, operation||' '||options as plan_oper
            --,filter_predicates
            ,cost,cardinality,round(cost/cardinality) ratio
            from gv\$sql_plan
            where
             operation||' '||options in ('TABLE ACCESS FULL','INDEX FAST FULL SCAN',
                                         'TABLE ACCESS STORAGE FULL','TABLE ACCESS INMEMORY FULL')
            and object_owner not in ('SYS') and cost >0 and cardinality >0
            order by ratio desc
        )where rownum<=$rn
    ), tmp2 as
    (select inst_id,SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO
         from
          (select a.*
                   ,row_number() over (partition by sql_id order by ratio desc) as rnum
           from tmp1 a
           ) where rnum=1
     )--sql_id dedup
     select inst_id,min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO , count(*) as sql_cnt
     from tmp2
     group by inst_id,PLAN_HASH_VALUE, OBJECT_NAME,PLAN_OPER,COST,CARDINALITY,RATIO --dedup same force_matching_signature
     order by ratio;
    $ECHO


    --2+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    Pro High card in index,low card "index rowid"(top $rn),suboptimal index:
    with tmp1 as
    (select inst_id,sql_id,plan_hash_value, OBJECT_NAME,cardinality as index_card,lag_card as lag_card
          ,round(cardinality/lag_card) as ratio from
        (
            select * from
            (
                select inst_id,sql_id,plan_hash_value, OBJECT_NAME,operation,options ,cardinality,id,parent_id,depth
                ,lag(operation||' '||options) over (partition by inst_id,sql_id,plan_hash_value order by id) as lag_oper
                ,lag(id) over (partition by inst_id,sql_id,plan_hash_value order by id) as lag_id
                --,lag(parent_id) over (partition by sql_id,plan_hash_value order by id) as lag_parent_id
                ,lag(cardinality)over (partition by inst_id,sql_id,plan_hash_value order by id) as lag_card
                from gv\$sql_plan
                where cardinality is not null and object_owner<>'SYS'
            )where operation||' '||options='INDEX RANGE SCAN' and lag_oper like 'TABLE ACCESS BY%INDEX ROWID%'
                and id=lag_id+1 and parent_id=lag_id
                and lag_card is not null
            order by cardinality/lag_card desc
        )where rownum<=$rn
    ),tmp2 as
    ( select inst_id,SQL_ID,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO
      from
         (select a.*,row_number() over (partition by sql_id order by ratio desc) as rnum
          from tmp1 a
          ) where rnum=1
     )
     select inst_id,min(sql_id) as min_sql_id,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO
            ,count(*) as sql_cnt
     from tmp2
     group by inst_id,PLAN_HASH_VALUE, OBJECT_NAME,INDEX_CARD,LAG_CARD,RATIO
     order by ratio;
    $ECHO

    --3+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    $DEFNODISP Pro Filter with more than 2 suboperations
    $DEFNODISP
    $DEFNODISP select distinct sql_id,plan_hash_value
    $DEFNODISP from
    $DEFNODISP (
    $DEFNODISP select inst_id,sql_id,plan_hash_value,child_number,parent_id,count(*)
    $DEFNODISP from gv\$sql_plan
    $DEFNODISP where (inst_id,sql_id,plan_hash_value,child_number,parent_id )in
    $DEFNODISP      (select inst_id,sql_id,plan_hash_value,child_number,id
    $DEFNODISP      from gv\$sql_plan
    $DEFNODISP      where operation='FILTER'
    $DEFNODISP      )
    $DEFNODISP     and OBJECT_OWNER<>'SYS'
    $DEFNODISP group by inst_id,sql_id,plan_hash_value,child_number,parent_id
    $DEFNODISP having count(*)>1
    $DEFNODISP ) where rownum<=$rn;

    --4+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
    col oper format a25
    col card format 9999999
    col username format a15 trunc
    col child format 99
    col id format 999

    Pro hash join with little join big result in little set:
    with tmp0 as
    ( select a.*
              --,row_number() over (partition by inst_id,sql_id,plan_hash_value order by cost/cardinality desc) as rn
              ,lead(cardinality) over (partition by inst_id,sql_id,plan_hash_value order by id) as lead_card
        from gv\$sql_plan a --where sql_id='8fgsm55xftv5g'
    ),
    tmp1 as
    (select inst_id,sql_id,plan_hash_value,id,child_number as child,operation||' '||options as oper,cost,cardinality as card,lead_card
          ,round(cost/cardinality,1) as ratio
     from
        (
        select a.*,row_number() over (partition by inst_id,sql_id,plan_hash_value order by cost/cardinality desc) as rn
        from tmp0 a
        where operation ='HASH JOIN' and ( options not like '%ANTI%' or options is null)
              and cardinality<1000
        )where rn=1
    )
    select * from
    (select B.PARSING_SCHEMA_NAME as username,a.*--,substr(b.sql_text,1,30) as sql_text
    from tmp1 a, gv\$sqlarea b
    where a.sql_id=b.sql_id and a.inst_id=b.inst_id
    and B.PARSING_SCHEMA_NAME not in ('SYS','DBSNMP')
    order by ratio desc
    )where rownum<=$rn;

    --5+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

    spool off
!
echo "full nodes"
echo "Missing index or suboptimal index,from WRH\$_SQL_PLAN(with snap_id). top $rn"
exit 0
fi

################################################################################
if [ "$1" = "dup_index" ]; then

   if [ "$2" = "" ]; then
       ora user
       read -p "Please input a owner:" owner
        if [ -z "${owner}" ];then
             echo "table owner needed!"
             exit 1
        fi
   else
     owner=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180
    col table_name format a30
    col index_name format a30
    col index_col_lists format a30
    col dup_col_lists format a30
    col dup_index_name format a30
    spool ora_dup_index_$filedate.log
    with tmp as
    (
    select table_owner,table_name,index_name,
           listagg(column_name,chr(10)||',') within group (order by column_position) as col_lists
    from dba_ind_columns where table_owner=upper('$owner')
    group by table_owner,table_name,index_name
    )
    select table_name,index_name,index_col_lists,dup_col_lists,dup_index_name
    from
    (select table_owner,
          table_name,index_name,col_lists as index_col_lists
         ,lag(col_lists) over (partition by table_owner,table_name order by col_lists) as dup_col_lists
         ,lag(index_name) over (partition by table_owner,table_name order by col_lists) as dup_index_name
    from tmp a
    )where table_owner=upper('$owner') and
           index_col_lists like dup_col_lists||chr(10)||',%';
    $ECHO
    spool off
!
echo "get duplicate index by table owner for $owner"
exit 0
fi

################################################################################
if [ "$1" = "highcost" ]; then

   if [ "$2" = "" ]; then
     rn=50
   else
     rn=$2
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col sql_id format a13
    col sql_text format a64
    spool ora_highcost_${INST}_${filedate}.log
    with tmp as
    (select rownum as rn,a.* from
        (select inst_id,sql_id,max(cost) max_cost
          from gv\$sql_plan
         where id=0 and cost>=100
               and inst_id=$INST
         group by inst_id,sql_id
         order by max_cost desc
        )a where rownum<=$rn
    )
    select a.*,b.sql_text
    from tmp a,gv\$sqltext b
    where a.sql_id=b.sql_id
          and b.inst_id=$INST
          and b.piece=0
          order by rn;
    $ECHO
    spool off
!
echo "instance_number=$INST"
echo "get top cost sql from gv_sql_plan"
exit 0
fi

################################################################################
if [ "$1" = "trc" ]; then

   ver2=`get_ver 2`

   if [ "$ver2" = "10" ]; then
      echo "$ORACLE_BASE/admin/$ORACLE_SID/bdump/"
      exit 0
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    set head off
    select value from v\$diag_info where name='Diag Trace';
    $ECHO
!
exit 0
fi
################################################################################
if [ "$1" = "index" -o "$1" = "ind" ]; then

  if [ "$2" = ""  ]; then
   read -p "Please input table_name:" tablename
    if [ -z "${tablename}" ];then
         echo "no input , exit"
         exit 1
    fi
  else
    tablename=$2
  fi

   if [ "$3" = ""  ]; then

    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_tables where table_name=upper('$tablename') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    if [ -z "${defowner}" ];then
       echo "table $tablename not found,please check again!"
       exit 1
    fi
   read -p "Please input table_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
         owner=$defowner
    fi
   else
    owner=$3
  fi


   ver2=`get_ver 2`
   if [ $ver2 -lt 11 ];then
     ver="--"
   else
     ver=""
   fi

   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pages 0
    set serveroutput on
    set verify off
    set timing off
    set trimspool on
spool ora_indexes_of_${owner}_${tablename}.log

undefine table_name
undefine owner
var table_name varchar2(100);
var owner varchar2(100);

begin
  :owner :=upper('$owner');
  :table_name := upper('$tablename');
end;
/

--alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
declare
  v_part_cnt number;
  v_foreign_key_cnt number;
  cursor c_constraints is select
   a.owner,
   a.table_name,
   a.constraint_name,
   b.column_name,
   lpad(a.constraint_type,10) as constraint_type,
   decode(a.index_name,null,'nil',a.index_name) as index_name,
   a.status
  from all_constraints a,all_cons_columns b
  where a.owner = b.owner
    and a.constraint_name = b.constraint_name
    and a.table_name = :table_name
    and a.OWNER = :owner;
  v_constraints c_constraints%rowtype;

    cursor c_i is SELECT
       A.INDEX_NAME,
       A.COLUMN_NAME,
           decode(t.DATA_TYPE,
           'NUMBER',t.DATA_TYPE||'('||
           decode(t.DATA_PRECISION,
                  null,t.DATA_LENGTH||')',
                  t.DATA_PRECISION||','||t.DATA_SCALE||')'),
                  'DATE',t.DATA_TYPE,
                  'LONG',t.DATA_TYPE,
                  'LONG RAW',t.DATA_TYPE,
                  'ROWID',t.DATA_TYPE,
                  'MLSLABEL',t.DATA_TYPE,
                  t.DATA_TYPE||'('||t.DATA_LENGTH||')') ||' '||
           decode(t.nullable,
                  'N','NOT NULL',
                  'n','NOT NULL',
                  NULL) col_type,
       A.COLUMN_POSITION,decode(b.TABLESPACE_NAME,null,'None',B.TABLESPACE_NAME) as TABLESPACE_NAME,B.INDEX_TYPE,B.DEGREE,
       round(C.BYTES / 1024 / 1024) AS INDEX_MB,
       A.DESCEND,
       case when B.STATUS = 'UNUSABLE' then 'NO' else 'YES' end USABLE,
       decode(to_char(B.last_analyzed,'yymmdd hh24:mi'),null,'None',
       to_char(b.last_analyzed,'yymmdd hh24:mi')) as last_analyzed,
       case when b.visibility = 'VISIBLE' then 'YES' else 'NO ' end visibility,
       case when uniqueness = 'UNIQUE' then 'YES' else 'NO ' end UNIQUENESS,
       B.CLUSTERING_FACTOR,
       decode(B.GLOBAL_STATS,'YES','GLOBAL','LOCAL') as INDEX_PARTITION
  FROM DBA_IND_COLUMNS A, DBA_INDEXES B, DBA_SEGMENTS C ,DBA_TAB_COLUMNS T
 WHERE A.INDEX_NAME = B.INDEX_NAME
   AND A.index_owner = b.owner
   AND T.TABLE_NAME = A.TABLE_NAME
   AND T.OWNER = A.INDEX_OWNER
   AND A.COLUMN_NAME = T.COLUMN_NAME
   AND A.TABLE_NAME = :table_name
   AND a.INDEX_OWNER = :owner
   AND C.SEGMENT_NAME = A.INDEX_NAME
   AND C.OWNER = A.INDEX_OWNER
 ORDER BY INDEX_NAME, COLUMN_POSITION;
    v_i c_i%rowtype;

    cursor c_foreign_key_without_index is select owner,
       table_name,
       constraint_name,
       substr(cname1 || nvl2(cname2, ',' || cname2, null) || nvl2(cname3, ',' || cname3, null) ||
              nvl2(cname4, ',' || cname4, null) || nvl2(cname5, ',' || cname5, null) ||
              nvl2(cname6, ',' || cname6, null) || nvl2(cname7, ',' || cname7, null) ||
              nvl2(cname8, ',' || cname8, null), 0, 400) as cols
from (select b.owner,
             b.table_name,
             b.constraint_name,
             max(decode(position, 1, column_name, null)) cname1,
             max(decode(position, 2, column_name, null)) cname2,
             max(decode(position, 3, column_name, null)) cname3,
             max(decode(position, 4, column_name, null)) cname4,
             max(decode(position, 5, column_name, null)) cname5,
             max(decode(position, 6, column_name, null)) cname6,
             max(decode(position, 7, column_name, null)) cname7,
             max(decode(position, 8, column_name, null)) cname8,
             count(*)                                    col_cnt
      from (select owner,
                   constraint_name,
                   column_name,
                   position
            from dba_cons_columns
            where owner not in
                  ('SYSTEM', 'OWBSYS', 'XS$NULL', 'FLOWS_FILES', 'WMSYS', 'DIP', 'XDB', 'SYS', 'ANONYMOUS', 'QMONITOR',
                   'ORDPLUGINS', 'OUTLN', 'ORDSYS', 'SI_INFORMTN_SCHEMA',
                   'ORDDATA', 'OJVMSYS', 'SPATIAL_WFS_ADMIN_USR', 'MDSYS', 'LBACSYS', 'SPATIAL_CSW_ADMIN_USR', 'DVSYS',
                   'DBSNMP', 'APEX_PUBLIC_USER',
                   'APPQOSSYS', 'APEX_040200', 'ORACLE_OCM', 'AUDSYS', 'CTXSYS', 'MDDATA', 'APEX_030200', 'EXFSYS',
                   'MGMT_VIEW', 'OLAPSYS', 'SYSMAN', 'OWBSYS_AUDIT',
                   'WH_SYNC', 'GSMADMIN_INTERNAL')) a,
           dba_constraints b
      where a.constraint_name = b.constraint_name
        and b.constraint_type = 'R'
        and a.owner = b.owner
      group by b.owner, b.table_name, b.constraint_name
     ) cons
where col_cnt > ALL
      (select count(*)
       from dba_ind_columns i
       where i.table_name = cons.table_name
         and i.column_name in (cname1, cname2, cname3, cname4,
                               cname5, cname6, cname7, cname8)
         and i.column_position <= cons.col_cnt
         and i.INDEX_OWNER = cons.owner
       group by i.index_name
      );
         v_f c_foreign_key_without_index%rowtype;
         cursor c_par_ind is select index_name, PARTITION_POSITION as PART_POSITION, PARTITION_NAME, BLEVEL, LEAF_BLOCKS, NUM_ROWS, DISTINCT_KEYS,
                             CLUSTERING_FACTOR,
                             case when STATUS = 'UNUSABLE' then 'NO' else 'YES' end USABLE,
                             high_value
                             from dba_ind_partitions
                             where index_name in
                            (
                            select index_name from dba_indexes where table_name = UPPER(:table_name)
                            and INDEX_OWNER = upper(:owner)
                            and partitioned = 'YES') order by index_name, partition_position;

         v_part c_par_ind%rowtype;

begin
  dbms_output.enable(buffer_size => NULL);
  dbms_output.put_line('
C# Means COLUMN_POSITION
DE? Means DEGREE
DES? Means DESC OR ASC
US? Means USABLE?
VI? Means VISIABLE?
UN? Means UNIQUE Index?
G OR L? Means Global OR Local Indexes
Index Information(contains Global and Local index See the Last Column)');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| INDEX_NAME             |' || ' COLUMN_NAME    ' || '| COLUMN_TYPE        ' || '| C# |' || ' TABLESPACE_NAME ' || '| IND_TYPE |' || ' DE? ' || '| I_MB |' || ' DES? ' || '| US? |'  || ' LAST_ANALYZE '|| '| VI? |'  || ' UN? ' || '| CLUS_FACTOR '|| '| G OR L? ' ||'|');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_i;
    loop fetch c_i into v_i;
    exit when c_i%notfound;
    dbms_output.put_line('| ' || rpad(v_i.INDEX_NAME,22) ||' | '|| rpad(v_i.COLUMN_NAME,14) || ' | ' ||rpad(v_i.col_type,18) ||' | '|| lpad(v_i.COLUMN_POSITION,2) || ' | '|| lpad(v_i.TABLESPACE_NAME,15) || ' | '|| lpad(v_i.INDEX_TYPE,8) || ' | '|| lpad(v_i.DEGREE,3) ||  ' | '|| lpad(v_i.INDEX_MB,4) || ' | '|| lpad(v_i.DESCEND,4) || ' | '|| lpad(v_i.USABLE,3) || ' | '|| lpad(v_i.LAST_ANALYZED,12) || ' | '|| lpad(v_i.visibility,3) || ' | '|| lpad(v_i.UNIQUENESS,3)|| ' | '|| lpad(v_i.CLUSTERING_FACTOR,11) || ' | ' || lpad(v_i.INDEX_PARTITION,7) ||' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_i;
  dbms_output.put_line('If US? status Is NO!!!');
  dbms_output.put_line('Please Execute: alter index ' ||:owner ||'.' ||'index_name' ||' rebuild online;');
  dbms_output.put_line('======================');

   select count(*) into v_part_cnt from dba_ind_partitions where index_name in (select index_name from dba_indexes where table_name = UPPER(:table_name) and INDEX_OWNER = upper(:owner) and partitioned = 'YES') order by index_name, partition_position;
if v_part_cnt > 0 then
    dbms_output.put_line('
Partition Index Information(if index is Local Index)');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| INDEX_NAME         |' || ' PART_POSITION ' || '| PARTITION_NAME |' || ' BLEVEL ' || '| LEAF_BLOCKS |' || ' NUM_ROWS ' || '| DISTINCT_KEYS |' || ' CLUSTERING_FACTOR '  || '| USABLE |'|| ' HIGH_VALUE                              '|| '|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_par_ind;
    loop fetch c_par_ind into v_part;
    exit when c_par_ind%notfound;
    dbms_output.put_line('| ' || rpad(v_part.INDEX_NAME,18) ||' | '|| lpad(v_part.PART_POSITION,13) || ' | '|| lpad(v_part.PARTITION_NAME,14) || ' | '|| lpad(v_part.BLEVEL,6) || ' | '|| lpad(v_part.LEAF_BLOCKS,11) || ' | '|| lpad(v_part.NUM_ROWS,8) ||  ' | '|| lpad(v_part.DISTINCT_KEYS,13) || ' | '|| lpad(v_part.CLUSTERING_FACTOR,17) || ' | '|| lpad(v_part.USABLE,6) || ' | '|| lpad(v_part.HIGH_VALUE,40)||'|');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_par_ind;
end if;

  select count(*) into v_foreign_key_cnt from (select b.owner,
             b.table_name,
             b.constraint_name,
             max(decode(position, 1, column_name, null)) cname1,
             max(decode(position, 2, column_name, null)) cname2,
             max(decode(position, 3, column_name, null)) cname3,
             max(decode(position, 4, column_name, null)) cname4,
             max(decode(position, 5, column_name, null)) cname5,
             max(decode(position, 6, column_name, null)) cname6,
             max(decode(position, 7, column_name, null)) cname7,
             max(decode(position, 8, column_name, null)) cname8,
             count(*)                                    col_cnt
      from (select owner,
                   constraint_name,
                   column_name,
                   position
            from dba_cons_columns
            where owner not in
                  ('SYSTEM', 'OWBSYS', 'XS$NULL', 'FLOWS_FILES', 'WMSYS', 'DIP', 'XDB', 'SYS', 'ANONYMOUS', 'QMONITOR',
                   'ORDPLUGINS', 'OUTLN', 'ORDSYS', 'SI_INFORMTN_SCHEMA',
                   'ORDDATA', 'OJVMSYS', 'SPATIAL_WFS_ADMIN_USR', 'MDSYS', 'LBACSYS', 'SPATIAL_CSW_ADMIN_USR', 'DVSYS',
                   'DBSNMP', 'APEX_PUBLIC_USER',
                   'APPQOSSYS', 'APEX_040200', 'ORACLE_OCM', 'AUDSYS', 'CTXSYS', 'MDDATA', 'APEX_030200', 'EXFSYS',
                   'MGMT_VIEW', 'OLAPSYS', 'SYSMAN', 'OWBSYS_AUDIT',
                   'WH_SYNC', 'GSMADMIN_INTERNAL')) a,
           dba_constraints b
      where a.constraint_name = b.constraint_name
        and b.constraint_type = 'R'
        and a.owner = b.owner
      group by b.owner, b.table_name, b.constraint_name
     ) cons
where col_cnt > ALL
      (select count(*)
       from dba_ind_columns i
       where i.table_name = cons.table_name
         and i.column_name in (cname1, cname2, cname3, cname4,
                               cname5, cname6, cname7, cname8)
         and i.column_position <= cons.col_cnt
         and i.INDEX_OWNER = cons.owner
       group by i.index_name
      );

if v_foreign_key_cnt > 0 then
  dbms_output.put_line('
Foreign Key Without Index Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER                |' || ' TABLE_NAME            ' || '| CONSTRAINT_NAME         |' || ' COLUMNS                                                                              ' || '|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_foreign_key_without_index;
    loop fetch c_foreign_key_without_index into v_f;
    exit when c_foreign_key_without_index%notfound;
    dbms_output.put_line('| ' || rpad(v_f.OWNER,20) ||' | '|| rpad(v_f.TABLE_NAME,21) || ' | '|| rpad(v_f.CONSTRAINT_NAME,23) || ' | ' || rpad(v_f.cols,85) || '|');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_foreign_key_without_index;
end if;

  dbms_output.put_line('
Show The Table Constraints');
  dbms_output.put_line('======================');
  dbms_output.put_line('---------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER                |' || ' TABLE_NAME            ' || '| INDEX_NAME                  |' || ' constraint_name |' || ' column_name    ' || '| constraint_type |' || ' STATUS  ' || '|');
  dbms_output.put_line('---------------------------------------------------------------------------------------------------------------------------------------------');
  open c_constraints;
    loop fetch c_constraints into v_constraints;
    exit when c_constraints%notfound;
    dbms_output.put_line('| ' || rpad(v_constraints.owner,20) ||' | '|| rpad(v_constraints.table_name,21) || ' | '|| rpad(v_constraints.index_name,27) || ' | '|| rpad(v_constraints.constraint_name,15) || ' | '|| rpad(v_constraints.column_name,14) || ' | '|| rpad(v_constraints.constraint_type,15) ||  ' | '|| rpad(v_constraints.status,7) || ' |');
    end loop;
    dbms_output.put_line('---------------------------------------------------------------------------------------------------------------------------------------------');
  close c_constraints;

end;
/

$ECHO
  spool off
!
exit 0
fi

################################################################################
if [ "$1" = "resize" ]; then

#################
sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

connect $DBUSER

set linesize 200 pagesize 100
col ResizeCmd format a120

select a.file#,
         --a.name,
         round(a.bytes / 1024 / 1024) Current_MB,
         ceil(HWM * a.block_size / 1024 / 1024) ResizeTo,
         round((a.bytes - HWM * a.block_size) / 1024 / 1024) Release_MB,
         'alter database datafile ''' || a.name || ''' resize ' ||
         ceil(HWM * a.block_size / 1024 / 1024) || 'M;' ResizeCmd
from v\$datafile a,
       (SELECT file_id, MAX(block_id + blocks - 1) HWM
          FROM DBA_EXTENTS
         GROUP BY file_id
         ) b
where a.file# = b.file_id(+)
And (a.bytes - HWM * a.block_size) >0
order by Release_MB;
$ECHO
!
exit 0
fi



################################################################################
if [ "$1" = "sql_baseline" ]; then

     if [ "$2" = "" ]; then
      sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col plan_name format a30
    col signature format 99999999999999999999
    col created format a20
    col sql_handle format a20
    col description format a40 trunc
    col creator format a10 trunc
    col sql_text format a50 trunc
    col ORIGIN format a12 trunc
    select * from
    (select plan_NAME,enabled, accepted, fixed--,signature,sql_handle
           ,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss') as created
            ,creator,origin, DESCRIPTION,SQL_TEXT
           from dba_sql_plan_baselines order by created desc
     ) where rownum<=20;
!
    echo "ora sql_baseline sql_id_1 sql_id_2 phv"
    exit 1
  fi

  if [ "$2" = "" -o "$3" = "" -o "$4" = "" ]; then

    echo "ora sql_baseline <ori_sqlid> <modi_sqlid> <modi_phv>"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150


--SPO coe_load_sql_baseline.log;
SET DEF ON TERM OFF ECHO ON FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUM 20 SQLP SQL>;
SET SERVEROUT ON SIZE UNL;
SET TERM ON ECHO OFF;
DEF original_sql_id = '$2';
DEF modified_sql_id = '$3';
DEF plan_hash_value = '$4';
PRO
PRO Values passed to coe_load_sql_baseline:
PRO ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
PRO ORIGINAL_SQL_ID: "&&original_sql_id."
PRO MODIFIED_SQL_ID: "&&modified_sql_id."
PRO PLAN_HASH_VALUE: "&&plan_hash_value."
PRO
WHENEVER SQLERROR EXIT SQL.SQLCODE;
SET TERM OFF ECHO ON;

-- trim parameters
COL original_sql_id NEW_V original_sql_id FOR A30;
COL modified_sql_id NEW_V modified_sql_id FOR A30;
COL plan_hash_value NEW_V plan_hash_value FOR A30;
SELECT TRIM('&&original_sql_id.') original_sql_id, TRIM('&&modified_sql_id.') modified_sql_id,
TRIM('&&plan_hash_value.') plan_hash_value FROM DUAL;

-- open log file
--SPO coe_load_sql_baseline_&&original_sql_id..log;
--GET coe_load_sql_baseline.log;

-- get user
COL connected_user NEW_V connected_user FOR A30;
SELECT USER connected_user FROM DUAL;

VAR sql_text CLOB;
VAR plan_name VARCHAR2(30);
EXEC :sql_text := NULL;
EXEC :plan_name := NULL;

-- get sql_text from memory
BEGIN
  SELECT REPLACE(sql_fulltext, CHR(00), ' ')
    INTO :sql_text
    FROM gv\$sqlarea
   WHERE sql_id = TRIM('&&original_sql_id.')
     AND ROWNUM = 1;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- get sql_text from awr
BEGIN
  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
    SELECT REPLACE(sql_text, CHR(00), ' ')
      INTO :sql_text
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&&original_sql_id.')
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- sql_text as found
col sql_text format a100
SELECT :sql_text as sql_text FROM DUAL;

-- check is sql_text for original sql is available
SET TERM ON;
BEGIN
  IF :sql_text IS NULL THEN
    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for original SQL_ID &&original_sql_id. was not found in memory (gv\$sqlarea) or AWR (dba_hist_sqltext).');
  END IF;
END;
/

-- check phv is found
DECLARE
  l_count NUMBER;
BEGIN
  SELECT COUNT(*)
    INTO l_count
    FROM gv\$sql
   WHERE sql_id = TRIM('&&modified_sql_id.')
     AND plan_hash_value = TO_NUMBER(TRIM('&&plan_hash_value.'));

   IF l_count = 0 THEN
     RAISE_APPLICATION_ERROR(-20110, 'PHV &&plan_hash_value. for modified SQL_ID &&modified_sql_id. was not be found in memory (gv\$sql).');
   END IF;
END;
/

SET ECHO OFF;
DECLARE
  plans NUMBER;
  description VARCHAR2(500);
  sys_sql_handle VARCHAR2(30);
  sys_plan_name VARCHAR2(30);
BEGIN
  -- create sql_plan_baseline for original sql using plan from modified sql
  plans :=
  DBMS_SPM.LOAD_PLANS_FROM_CURSOR_CACHE (
    sql_id          => TRIM('&&modified_sql_id.'),
    plan_hash_value => TO_NUMBER(TRIM('&&plan_hash_value.')),
    sql_text        => :sql_text );

  DBMS_OUTPUT.PUT_LINE('Plans Loaded: '||plans);

  -- find handle and plan_name for sql_plan_baseline just created
  SELECT sql_handle, plan_name
    INTO sys_sql_handle, sys_plan_name
    FROM dba_sql_plan_baselines
   WHERE creator = USER
     AND origin like 'MANUAL-LOAD%'
     AND created = ( -- past 1 minute only
  SELECT MAX(created) max_created
    FROM dba_sql_plan_baselines
   WHERE creator = USER
     AND origin like 'MANUAL-LOAD%'
     AND created > SYSDATE - (1/24/60));

  -- update description of new sql_plan_baseline
  description := 'ori:'||TRIM('&&original_sql_id.')||' modi:'||TRIM('&&modified_sql_id.')||' phv:'||TRIM('&&plan_hash_value.')||' created by coe_load_sql_baseline(tiger)';
  plans :=
  DBMS_SPM.ALTER_SQL_PLAN_BASELINE (
    sql_handle      => sys_sql_handle,
    plan_name       => sys_plan_name,
    attribute_name  => 'description',
    attribute_value => description );
  DBMS_OUTPUT.PUT_LINE(plans||' plan(s) modified description: "'||description||'"');

  -- update plan_name of new sql_plan_baseline
  :plan_name := TRIM('&&modified_sql_id.')||'_'||TRIM('&&plan_hash_value.');
  plans :=
  DBMS_SPM.ALTER_SQL_PLAN_BASELINE (
    sql_handle      => sys_sql_handle,
    plan_name       => sys_plan_name,
    attribute_name  => 'plan_name',
    attribute_value => :plan_name );
  DBMS_OUTPUT.PUT_LINE(plans||' plan(s) modified plan_name: "'||:plan_name||'"');
/*
--tiger liu comment:  -- drop baseline staging table for original sql (if one exists)
--tiger liu comment:  BEGIN
--tiger liu comment:    DBMS_OUTPUT.PUT_LINE('dropping staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'"');
--tiger liu comment:    EXECUTE IMMEDIATE 'DROP TABLE STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'));
--tiger liu comment:  EXCEPTION
--tiger liu comment:    WHEN OTHERS THEN
--tiger liu comment:      DBMS_OUTPUT.PUT_LINE('staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'" did not exist');
--tiger liu comment:  END;
--tiger liu comment:
--tiger liu comment:  -- create baseline staging table for original sql
--tiger liu comment:  DBMS_OUTPUT.PUT_LINE('creating staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'"');
--tiger liu comment:  DBMS_SPM.CREATE_STGTAB_BASELINE (
--tiger liu comment:    table_name  => 'STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.')),
--tiger liu comment:    table_owner => '&&connected_user.' );
--tiger liu comment:
--tiger liu comment:  -- packs new baseline for original sql
--tiger liu comment:  DBMS_OUTPUT.PUT_LINE('packaging new sql baseline into staging table "STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.'))||'"');
--tiger liu comment:  plans :=
--tiger liu comment:  DBMS_SPM.PACK_STGTAB_BASELINE (
--tiger liu comment:     table_name  => 'STGTAB_BASELINE_'||UPPER(TRIM('&&original_sql_id.')),
--tiger liu comment:     table_owner => '&&connected_user.',
--tiger liu comment:     sql_handle  => sys_sql_handle,
--tiger liu comment:     plan_name   => :plan_name );
--tiger liu comment:  DBMS_OUTPUT.PUT_LINE(plans||' pla(s) packaged');
*/
END;
/

-- display details of new sql_plan_baseline
SET ECHO ON;
col signature format 9999999999999999999
col sql_handle format a30
col plan_name format a30
SELECT signature, sql_handle, plan_name, enabled, accepted, fixed--, reproduced (avail on 11.2.0.2)
  FROM dba_sql_plan_baselines WHERE plan_name = :plan_name;
col description format a100
SELECT description
  FROM dba_sql_plan_baselines WHERE plan_name = :plan_name;
SET ECHO OFF;
/*
--tiger liu comment:PRO
--tiger liu comment:PRO ****************************************************************************
--tiger liu comment:PRO * Enter &&connected_user. password to export staging table STGTAB_BASELINE_&&original_sql_id.
--tiger liu comment:PRO ****************************************************************************
--tiger liu comment:HOS exp &&connected_user. tables=&&connected_user..STGTAB_BASELINE_&&original_sql_id. file=STGTAB_BASELINE_&&original_sql_id..dmp statistics=NONE indexes=N constraints=N grants=N triggers=N
--tiger liu comment:PRO
--tiger liu comment:PRO If you need to implement this SQL Plan Baseline on a similar system,
--tiger liu comment:PRO import and unpack using these commands:
--tiger liu comment:PRO
--tiger liu comment:PRO imp &&connected_user. file=STGTAB_BASELINE_&&original_sql_id..dmp tables=STGTAB_BASELINE_&&original_sql_id. ignore=Y
--tiger liu comment:PRO
--tiger liu comment:PRO SET SERVEROUT ON;;
--tiger liu comment:PRO DECLARE
--tiger liu comment:PRO   plans NUMBER;;
--tiger liu comment:PRO BEGIN
--tiger liu comment:PRO   plans := DBMS_SPM.UNPACK_STGTAB_BASELINE('STGTAB_BASELINE_&&original_sql_id.', '&&connected_user.');;
--tiger liu comment:PRO   DBMS_OUTPUT.PUT_LINE(plans||' plan(s) unpackaged');;
--tiger liu comment:PRO END;;
--tiger liu comment:PRO /
--tiger liu comment:PRO
--tiger liu comment:SPO OFF;
--tiger liu comment:HOS zip -m coe_load_sql_baseline_&&original_sql_id. coe_load_sql_baseline_&&original_sql_id..log STGTAB_BASELINE_&&original_sql_id..dmp coe_load_sql_baseline.log
--tiger liu comment:HOS zip -d coe_load_sql_baseline_&&original_sql_id. coe_load_sql_baseline.log
*/

PRO coe_load_sql_baseline completed.(script modified by Tiger Liu)

!
exit 0
fi
################################################################################
if [ "$1" = "tbs_frag" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col tablespace_name format a30
spool ora_tbsfrag_$filedate.log

$ECHO
spool off
!
exit 0
fi

################################################################################
if [ "$1" = "event" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    col inst_id format 9999
    col event format a40 trunc
    col max_sql_id format a14
    col session_cnt format 9999
    col max_user_name format a20 trunc

    select  inst_id,event,max(sql_id) as max_sql_id
           ,max(username) as max_user_name
           ,sum(sysdate-sql_exec_start)*86400 as sum_elap_s
           ,count(*) as session_cnt
    from gv\$session
    where status='ACTIVE' and upper(event) not like '%IDLE%'
          and inst_id=$INST
    group by inst_id,event
    order by count(*);
    $ECHO
!
echo "event count in gv\$session status='ACTIVE' group by inst_id, event"
echo "instance_number=$INST"
exit 0
fi


########################################################################################################
if [ "$1" = "session" -o "$1" = "sid" ]; then

  if [ "$2" = "" ]; then
    echo "ora session <sid> "
    exit 1
  fi

  ora -i $INST print_table "select a.*,lpad(''-'',60,''-'') as process_info,b.spid,b.tracefile,b.pga_used_mem \
                            ,c.sql_id||'':''||substr(c.SQL_TEXT,1,150) as running_sql \
                     from gv\$session a,gv\$process b,gv\$sqlarea c \
                     where a.sid=$2 and a.paddr=b.addr and a.inst_id=$INST and b.inst_id=$INST \
                          and a.sql_id=c.sql_id(+) and c.inst_id(+)=$INST "


  echo "instance_number=$INST"
exit 0;
fi

########################################################################################################
if [ "$1" = "process" ]; then

  if [ "$2" = "" ]; then
    echo "ora process <spid> "
    exit 1
  fi

  ora -i $INST print_table "select * from gv\$process where spid=$2 and inst_id=$INST"
echo "instance_number=$INST"
exit 0;
fi


################################################################################
if [ "$1" = "dir" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 37
    set linesize 150
    col owner format a12 trunc
    col DIRECTORY_NAME format a25 trunc
    col DIRECTORY_path format a100

    select owner,DIRECTORY_NAME,DIRECTORY_path from dba_directories order by 1,2,3;
    $ECHO
!
exit 0
fi

################################################################################
if [ "$1" = "iostat" -o "$1" = "batch_iostat" -o "$1" = "batch_iostats" -o "$1" = "batch_io" ]; then
    if [ "$2" = ""  -o  "$3" = "" ]; then
      #echo "ora iostat <bid> <eid> "
      #exit 1
      bid="(select max(snap_id)-48 from dba_hist_snapshot)"
      eid="(select max(snap_id)    from dba_hist_snapshot)"
    else
       bid=$2
       eid=$3
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 50
    col filename format a120
    col inst_id format 9999
    col tsname format a20 trunc
    col BEGIN_TIME format a16
    col ELA_MIN for 999
    col eid for 99999
    col rn for 999
    col R_P_S for 99999
    col W_P_S for 99999
    col WAITS for 99999
    col STPWT for 99999
    break on BEGIN_TIME
    set trimspool on
    spool ora_batch_iostat_${INST}_$filedate.log

    with snap_sum as
    (select instance_number as inst_id,snap_id,tsname
          ,sum(phyrds) as phyrds,sum(readtim) as readtim ,sum(phyblkrd) as phyblkrd
          ,sum(SINGLEBLKRDS) as singleblkrds,sum(phywrts) as phywrts,sum(SINGLEBLKRDTIM) singleblkrdtim
          ,sum(wait_count) as wait_count,sum(time) as time
           from dba_hist_filestatxs e
           where dbid = (select dbid from v\$database)
            and instance_number=$INST and snap_id >=$bid-1 and snap_id<=$eid
    group by instance_number,snap_id,tsname
    ),
    delta_value as
    (select inst_id,tsname,lag(a.snap_id) over (partition by inst_id,tsname order by a.snap_id) as begin_snap_id,a.snap_id as end_snap_id
           ,lag(b.end_interval_time) over (partition by inst_id,tsname order by b.snap_id) as begin_interval_time,b.end_interval_time
           ,(cast(b.end_interval_time as date)-cast((lag(b.end_interval_time) over (partition by inst_id,tsname order by b.snap_id)) as date))*24*60 as ela_min
          ,phyrds-lag(phyrds) over (partition by inst_id,tsname order by a.snap_id) as reads
          ,phyblkrd-lag(phyblkrd) over (partition by inst_id,tsname order by a.snap_id) as phyblkrd
          ,phywrts-lag(phywrts) over (partition by inst_id,tsname order by a.snap_id) as writes
          ,wait_count-lag(wait_count) over (partition by inst_id,tsname order by a.snap_id) as waits
          ,readtim-lag(readtim) over (partition by inst_id,tsname order by a.snap_id) as readtim
          ,SINGLEBLKRDS-lag(SINGLEBLKRDS) over (partition by inst_id,tsname order by a.snap_id) as SINGLEBLKRDS
          ,SINGLEBLKRDTIM-lag(SINGLEBLKRDTIM) over (partition by inst_id,tsname order by a.snap_id) as SINGLEBLKRDTIM
          ,time-lag(time) over (partition by inst_id,tsname order by a.snap_id) as time
    from snap_sum a,dba_hist_snapshot b
    where a.inst_id=B.INSTANCE_NUMBER  and a.snap_id=b.snap_id  and a.inst_id=$INST
    and b.dbid = (select dbid from v\$database)
    ),
    final_total as
    (select inst_id,to_char(begin_interval_time,'yyyymmdd-hh24mi') as begin_time,end_snap_id as eid,tsname
           ,round(ela_min) as ela_min
           ,reads
           ,round(reads/ela_min/60) as r_p_s
           ,round(decode(reads,0,0,10*(readtim/reads)),2) as avg_rd_ms
           ,round(decode(reads,0,0,(phyblkrd/reads)),2) as blk_pr
           ,writes
           --,round(SINGLEBLKRDS/ela_min/60,2) as sbrps
           ,round(writes/ela_min/60) as w_p_s
           ,waits
           ,round(decode(waits,0,0,10*(time/waits))) as stpwt
           ,reads+writes as ios
    from delta_value
    where ela_min<100
    )
select * from
(
select a.*,row_number() over (partition by inst_id,eid order by reads desc) as rn
from final_total a
)where rn<=5
order by inst_id,eid;


set linesize 500

set arraysize 100
set long 20000 longchunksize 100000000
set serveroutput on size 100000

declare
    v_cnt number;
    v_open_mode varchar2(100) :=null;

    cursor c_io is select snap_time,
    decode(lfs,null,'None',lfs) as lfs,
    decode(lfpw,null,'None',lfpw) as lfpw,
    decode(dpr,null,'None',dpr) as dpr,
    decode(cfpw,null,'None',cfpw) as cfpw,
    decode(dfsr,null,'None',dfsr) as dfsr,
    decode(dfscr,null,'None',dfscr) as dfscr,
    decode(dpw,null,'None',dpw) as dpw,
    decode(dpwt,null,'None',dpw) as dpwt,
    decode(dprt,null,'None',dprt) as dprt
    from (
select 'inst 1@' || stat.snap_time as snap_time,
max(decode(stat.event_name,'log file sync', stat.Avg_wait_Time)) lfs,
max(decode(stat.event_name,'log file parallel write', stat.Avg_wait_Time)) lfpw,
max(decode(stat.event_name,'direct path read', stat.Avg_wait_Time)) dpr,
max(decode(stat.event_name,'control file parallel write', stat.Avg_wait_Time)) cfpw,
max(decode(stat.event_name,'db file sequential read', stat.Avg_wait_Time)) dfsr,
max(decode(stat.event_name,'db file scattered read', stat.Avg_wait_Time)) dfscr,
max(decode(stat.event_name,'direct path write', stat.Avg_wait_Time)) dpw,
max(decode(stat.event_name,'direct path write temp', stat.Avg_wait_Time)) dpwt,
max(decode(stat.event_name,'direct path read temp', stat.Avg_wait_Time)) dprt
from
(
select to_char(b.begin_interval_time,'yyyymmdd hh24:mi:ss') snap_time, event_name, TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id) waits, TIME_WAITED_MICRO-lag(TIME_WAITED_MICRO) over (partition by event_name order by event_name, a.snap_id) wait_time,
round((TIME_WAITED_MICRO-lag(TIME_WAITED_MICRO) over (partition by event_name order by event_name, a.snap_id)) / decode((TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id)),0,1,(TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id))) / 1000) Avg_wait_Time
from dba_hist_system_event a, dba_hist_snapshot b
where event_name in ('log file sync','log file parallel write','direct path read','direct path read temp','direct path write temp',
  'control file parallel write','db file sequential read','db file scattered read','direct path write')
and a.instance_number= 1
and a.instance_number = b.instance_number
and a.snap_id = b.snap_id
) stat group by snap_time
union all
select 'inst 2@' || stat.snap_time as snap_time,
max(decode(stat.event_name,'log file sync', stat.Avg_wait_Time)) lfs,
max(decode(stat.event_name,'log file parallel write', stat.Avg_wait_Time)) lfpw,
max(decode(stat.event_name,'direct path read', stat.Avg_wait_Time)) dpr,
max(decode(stat.event_name,'control file parallel write', stat.Avg_wait_Time)) cfpw,
max(decode(stat.event_name,'db file sequential read', stat.Avg_wait_Time)) dfsr,
max(decode(stat.event_name,'db file scattered read', stat.Avg_wait_Time)) dfscr,
max(decode(stat.event_name,'direct path write', stat.Avg_wait_Time)) dpw,
max(decode(stat.event_name,'direct path write temp', stat.Avg_wait_Time)) dpwt,
max(decode(stat.event_name,'direct path read temp', stat.Avg_wait_Time)) dprt
from
(
select to_char(b.begin_interval_time,'yyyymmdd hh24:mi:ss') snap_time, event_name, TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id) waits, TIME_WAITED_MICRO-lag(TIME_WAITED_MICRO) over (partition by event_name order by event_name, a.snap_id) wait_time,
round((TIME_WAITED_MICRO-lag(TIME_WAITED_MICRO) over (partition by event_name order by event_name, a.snap_id)) / decode((TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id)),0,1,(TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id))) / 1000) Avg_wait_Time
from dba_hist_system_event a, dba_hist_snapshot b
where event_name in ('log file sync','log file parallel write','direct path read','direct path read temp','direct path write temp',
  'control file parallel write','db file sequential read','db file scattered read','direct path write')
and a.instance_number= 2
and a.instance_number = b.instance_number
and a.snap_id = b.snap_id
) stat
group by snap_time
union all
select 'inst 3@' || stat.snap_time as snap_time,
max(decode(stat.event_name,'log file sync', stat.Avg_wait_Time)) lfs,
max(decode(stat.event_name,'log file parallel write', stat.Avg_wait_Time)) lfpw,
max(decode(stat.event_name,'direct path read', stat.Avg_wait_Time)) dpr,
max(decode(stat.event_name,'control file parallel write', stat.Avg_wait_Time)) cfpw,
max(decode(stat.event_name,'db file sequential read', stat.Avg_wait_Time)) dfsr,
max(decode(stat.event_name,'db file scattered read', stat.Avg_wait_Time)) dfscr,
max(decode(stat.event_name,'direct path write', stat.Avg_wait_Time)) dpw,
max(decode(stat.event_name,'direct path write temp', stat.Avg_wait_Time)) dpwt,
max(decode(stat.event_name,'direct path read temp', stat.Avg_wait_Time)) dprt
from
(
select to_char(b.begin_interval_time,'yyyymmdd hh24:mi:ss') snap_time, event_name, TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id) waits, TIME_WAITED_MICRO-lag(TIME_WAITED_MICRO) over (partition by event_name order by event_name, a.snap_id) wait_time,
round((TIME_WAITED_MICRO-lag(TIME_WAITED_MICRO) over (partition by event_name order by event_name, a.snap_id)) / decode((TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id)),0,1,(TOTAL_WAITS-lag(TOTAL_WAITS) over (partition by event_name order by event_name, a.snap_id))) / 1000) Avg_wait_Time
from dba_hist_system_event a, dba_hist_snapshot b
where event_name in ('log file sync','log file parallel write','direct path read','direct path read temp','direct path write temp',
  'control file parallel write','db file sequential read','db file scattered read','direct path write')
and a.instance_number= 3
and a.instance_number = b.instance_number
and a.snap_id = b.snap_id
) stat group by snap_time) order by snap_time;

v_io c_io%rowtype;

begin

  dbms_output.put_line('
LF_SYNC    Means Log File Sync
LFP_WRITE  Means Log File Parallel Write
DP_READ    Means Direct Path Read
DP_WRITE   Means Direct Path Write
sequential Means db file sequential read
scattered  Means db file scattered read
IO Event Latency(ms) Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| instance_number@snap_time |' || ' LF_SYNC |'|| ' LFP_WRITE |' || ' DP_READ |' || ' DP_WRITE ' || '| CFP_WRITE |' || ' sequential |'|| ' scattered ' || '| DP_READ_TEMP ' || '| DP_WRITE_TEMP |');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------');
  open c_io;
    loop fetch c_io into v_io;
    exit when c_io%notfound;
    dbms_output.put_line('| ' || lpad(v_io.snap_time,25) ||' | '|| lpad(v_io.lfs,7) || ' | '|| lpad(v_io.lfpw,9) || ' | '|| lpad(v_io.dpr,8) || ' | ' || lpad(v_io.dpw,7) || ' | ' || lpad(v_io.cfpw,9) || ' | ' || lpad(v_io.dfsr,10) || ' | ' || lpad(v_io.dfscr,10) || '|' || lpad(v_io.dprt,13) || ' | ' || lpad(v_io.dpwt,13) || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------');
  close c_io;
end;
/


$ECHO
spool off

!
echo "instance_number=$INST"
echo "12.1 and below version only"
echo "ora iostat <bid> <eid> (defualt is 48 recent snapshots)"
exit 0
fi


################################################################################
if [ "$1" = "file" -o "$1" = "files" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 100
    col filename format a80
    col name format a30

    pro datafile and tempfile
     select name as filename,round(bytes/1024/1024)as size_m,status from v\$datafile
     union all
     select name as filename,round(bytes/1024/1024),status from v\$tempfile
     order by filename;
     $ECHO

    pro spfile and control file:
    col name format a20
    select value as filename,name from v\$parameter where name ='spfile'
    union all
    select --name--,lv as position
           trim(REGEXP_SUBSTR( value,'[^,]+', 1, lv)) as filename,name
    from (select name,value from v\$parameter  where name = 'control_files')a,
     (select level lv from dual
       connect by level <=(select max(regexp_count(value, '[^,]+')) from v\$parameter)
      ) b
    where b.lv<=regexp_count(value, '[^,]+');
    $ECHO

    pro online redo log:
    select member as filename,round(bytes/1024/1024) as size_M,a.group# ,b.status
     from v\$logfile a,v\$log b
     where a.group#=b.group#
    order by group#;
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "topsql_by_plan" ]; then
  echo "ora topsql_by_plan cpu|read|time"
  if [ "$2" = "" -o "$2" = "cpu" ]; then
    orderby=cpu_s
  elif  [ "$2" = "read" ]; then
    orderby=reads_k
  elif  [ "$2" = "time" ]; then
    orderby=elap_s
  fi

  if [ "$3" = "" ]; then
    topn=50
  else
    topn=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200 trim on
    set numwidth 20
    col min_user format a10 trunc
    col cpu_s format  9999999
    col elap_s format 9999999
    col wait_s format 9999999
    col "wait/elap" format a8
    col execs format  99999999
    col ela_pe format 9999999
    col tot_buf_k format 99999999
    col avg_buf format   999999999
    col reads_k format   9999999
    col iowait_s format  9999999
    col sql_ids format  99999
    col rn format 99
    col sql_text format a40 trunc
    col phv format 99999999999
    col min_sqlid format a13
    col inst_id format 999
    set trimspool on
    spool ora_topsql_by_plan_${INST}_${filedate}_${orderby}.log
select rownum as rn,a.* from
(select     inst_id,
            min(PARSING_SCHEMA_NAME) as  min_USER,
            plan_hash_value as phv,
            count(distinct sql_id) as sql_ids,
            min(sql_id) as min_sqlid,
            round(sum(cpu_time)/1e6) as cpu_s ,
            round(sum(elapsed_Time)/1e6) as elap_s ,
            round(sum(elapsed_Time - cpu_time)/1e6) wait_s,
      $DEFNODISP trunc(sum(elapsed_Time - cpu_time)*100/(greatest(sum(elapsed_Time),1)),1)||'%' as "wait/elap",
            sum(executions) as execs,
            round(sum(elapsed_Time)/greatest(sum(executions),1)/1e6,2) ela_Pe,
            round(sum(buffer_gets)/1000) as tot_buf_k,
            round(sum(buffer_gets)/greatest(sum(executions),1),1) as avg_buf,
            round(sum(disk_reads)/1000) as reads_k,
            round(sum(USER_IO_WAIT_TIME)/1e6) as IOwait_s,
            min(substr(sql_text,1,25)) as  sql_text
            from gv\$sql t
            where plan_hash_value>0 and inst_id=$INST
            group by inst_id,plan_hash_value
            --having count(distinct sql_id)>5
            order by $orderby desc
) a where rownum<=$topn;
$ECHO
spool off

!
echo "instance_number=$INST"
echo "top sql group by plan hash value,orderby $orderby , top $topn"
exit 0
fi


################################################################################
if [ "$1" = "toparea_by_sig" ]; then
    echo "ora toparea_by_sig cpu|read|time"
  if [ "$2" = "" -o "$2" = "cpu" ]; then
    orderby=cpu_s
  elif  [ "$2" = "read" ]; then
    orderby=reads_k
  elif  [ "$2" = "time" ]; then
    orderby=elap_s
  fi

  if [ "$3" = "" ]; then
    topn=50
  else
    topn=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200 trims on
    set numwidth 20
    col min_user format a10 trunc
    col cpu_s format  9999999
    col elap_s format 9999999
    col wait_s format 9999999
    col "wait/elap" format a8
    col execs format  99999999
    col ela_pe format 9999999
    col tot_buf_k format 9999999
    col avg_buf format   9999999
    col reads_k format   9999999
    col iowait_s format  9999999
    col cnt format       9999
    col rn format        99
    col sql_text format a25
    col min_sql_id format a14
    spool ora_topsql_by_sig_${INST}_${filedate}_${orderby}.log

select rownum as rn,a.* from
(select
            force_matching_signature,
            count(*) as cnt,
            min(PARSING_SCHEMA_NAME) as  min_USER,
            min(sql_id) as min_sql_id,
            round(sum(cpu_time)/1e6) as cpu_s ,
            round(sum(elapsed_Time)/1e6) as elap_s ,
            round(sum(elapsed_Time - cpu_time)/1e6) wait_s,
            trunc(sum(elapsed_Time - cpu_time)*100/(greatest(sum(elapsed_Time),1)),1)||'%' as "wait/elap",
            sum(executions) as execs,
            round(sum(elapsed_Time)/greatest(sum(executions),1)/1e6,2) ela_Pe,
            round(sum(buffer_gets)/1000) as tot_buf_k,
            round(sum(buffer_gets)/greatest(sum(executions),1),1) as avg_buf,
            round(sum(disk_reads)/1000) as reads_k,
            round(sum(USER_IO_WAIT_TIME)/1e6) as IOwait_s,
            min(substr(sql_text,1,25)) as  sql_text
            from gv\$sqlarea t
            where force_matching_signature>0 and inst_id=$INST
            group by force_matching_signature
            --having count(*)>1
            order by $orderby desc
) a where rownum<=$topn;
$ECHO
spool off

!
echo "instance_number=$INST"
echo "top sqlarea group by force_matching_signarue,orderby $orderby , top $topn"
exit 0
fi


################################################################################
if [ "$1" = "open_cursor" ]; then

  if [ "$2" = "" ]; then
    th=100
  else
    th=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    pro display top 30 having open_cursor >= $th :
    select * from
    (
    select inst_id,sid,count(*) as cnt
    from gv\$open_cursor
    where inst_id=$INST
    group by inst_id,sid
    having count(*)>=$th
    order by 3 desc
    )where rownum<=30;
    $ECHO
!
echo "instance_number=$INST"
exit 0
fi

#########################################snapper_ash###################################################

#   if [ "$2" = "" ]; then
#    defbtime=$(TZ=EST-7EDT date +"%H:%M")
#    defbtime2=$(TZ=EST-7EDT date +"%Y/%m/%d %H:%M")
#    #defbtime=`date +'%H:%M'`
#    read -p "Please input begin time,datetime format is [$defbtime](default) or [$defbtime2] :" btime
#     if [ -z "${btime}" ];then
#         btime=$defbtime
#         #echo "No input,exit"
#         #exit 1
#      fi
#    defdur=30
#    read -p "Please input duration time ,default is [$defdur]:" dur
#      if [ -z "${dur}" ];then
#         dur=$defdur
#      fi
#   else
#     btime=$2
#     dur=$3
#   fi

#    strlen=`echo $btime|wc -c|tr -d " "`
#    #echo $strlen
#    #exit

#   if [ $strlen -ne 6 -a $strlen -ne 17 ]; then
#       echo "date parameter format error. usage: ora snapper 08:10 25 or ora snapper \"2020/01/09 22:39\" 30 "
#       #echo "ora snapper 08:10 25"
#       #echo "ora -i 1 snapper \"2020/01/09 22:39\" 30"
#       exit 1
#   fi

#   #08:10  strlen=6
#   if [ $strlen = 6 ]; then
#      starttime="to_date(to_char(sysdate,'yyyy/mm/dd ')||'$btime','yyyy/mm/dd hh24:mi')"
#   fi
#
#   #2020/01/09 22:39 strlen=17
#  if [ $strlen = 17 ]; then
#      starttime="to_date('$btime','yyyy/mm/dd hh24:mi')"
#   fi
#   #echo $starttime

if [ "$1" = "snapper_ash" -o "$1" = "snapper" ]; then

 if [ "$2" = "" ]; then
   echo "ora snapper \"`date +"%Y/%m/%d %H:%M"`\" 30"
   echo "calc average active session "
   exit 1
 fi

  if [ "$3" = "" ]; then
    dur=30
  else
    dur=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
set trimspool on
spool ora_snapper_ash_$filedate.log

set termout off
set tab off
set verify off
set pages 0
set linesize 999
set trimspool on
set trimout on null ""

/*
define snapper_options="&1"
define   snapper_sleep="&2"
define   snapper_count="&3"
define     snapper_sid="&4"
*/

define snapper_options="ash=sid+username+machine+service_name+sql_id+event"
define   snapper_sleep="5"
define   snapper_count="1"
define     snapper_sid="all"


define _IF_ORA11_OR_HIGHER="--"
define _IF_LOWER_THAN_ORA11="--"
define _IF_DBMS_SYSTEM_ACCESSIBLE="/* dbms_system is not accessible"
-- /*dummy*/ -- this "dummy" is here just for avoiding VIM syntax highlighter going crazy due to previous line
define _IF_X_ACCESSIBLE="--"

-- plsql_object_id columns available in v\$session (from 10.2.0.3)
define _YES_PLSQL_OBJ_ID="--"
define _NO_PLSQL_OBJ_ID=""
-- blocking_instance available in v\$session (from 10.2)
define _YES_BLK_INST="--"
define _NO_BLK_INST=""

-- snapper v4 manual before/after snapshotting
define _MANUAL_SNAPSHOT="--"
define _USE_DBMS_LOCK=""

-- set the noprint's value to "noprint" if you don't want these temporary variables to show up in a sqlplus spool file
DEF noprint=""
col snapper_ora11higher    &noprint new_value _IF_ORA11_OR_HIGHER
col snapper_ora11lower     &noprint new_value _IF_LOWER_THAN_ORA11
col dbms_system_accessible &noprint new_value _IF_DBMS_SYSTEM_ACCESSIBLE
col x_accessible           &noprint new_value _IF_X_ACCESSIBLE
col no_plsql_obj_id        &noprint new_value _NO_PLSQL_OBJ_ID
col yes_plsql_obj_id       &noprint new_value _YES_PLSQL_OBJ_ID
col no_blk_inst            &noprint new_value _NO_BLK_INST
col yes_blk_inst           &noprint new_value _YES_BLK_INST
col manual_snapshot        &noprint new_value _MANUAL_SNAPSHOT
col use_dbms_lock          &noprint new_value _USE_DBMS_LOCK

col snapper_sid            &noprint new_value snapper_sid

def sid_filter="/**/"
def inst_filter="/**/"
col sid_filter             &noprint new_value sid_filter
col inst_filter            &noprint new_value inst_filter


-- initialize, precompute and determine stuff
var v                      varchar2(100)
var x                      varchar2(10)
var sid_filter             varchar2(4000)
var inst_filter            varchar2(4000)

-- this is here for a reason
-- im extracting the first word of the snapper_sid (if its a complex expression, not just a single SID)
-- by relying on how DEF and & assignment treat spaces in strings
def ssid_begin=&snapper_sid

set termout off
set serveroutput off
declare

    o                      sys.dbms_describe.number_table;
    p                      sys.dbms_describe.number_table;
    l                      sys.dbms_describe.number_table;
    a                      sys.dbms_describe.varchar2_table;
    dty                    sys.dbms_describe.number_table;
    def                    sys.dbms_describe.number_table;
    inout                  sys.dbms_describe.number_table;
    len                    sys.dbms_describe.number_table;
    prec                   sys.dbms_describe.number_table;
    scal                   sys.dbms_describe.number_table;
    rad                    sys.dbms_describe.number_table;
    spa                    sys.dbms_describe.number_table;

    tmp                    number;
    lv_sid_filter          varchar2(4000);
    lv_inst_filter         varchar2(4000);

    function get_filter(str in varchar2) return varchar2
    is
      ret varchar2(1000);
    begin
      if str like '%@%' then
        ret := lower(trim(regexp_replace(substr(str,instr(str,'=')+1), '^(.+)@([[:digit:]\*]+)(.*)', '\1')));
      else
        ret := lower(trim(substr(str,instr(str,'=')+1)));
      end if;
      return ret;
    end get_filter;

begin
    -- compute inst_filter
    case
        when regexp_instr('&ssid_begin','@')           = 0 then
            lv_inst_filter := 's.inst_id=USERENV(''Instance'')';
        when regexp_instr('&ssid_begin','@\*') > 0 or '&ssid_begin' like '(%' then
            lv_inst_filter := '1=1';
        when regexp_instr('&ssid_begin','@\d+')        > 0 then
            lv_inst_filter := 's.inst_id = ' || regexp_replace('&ssid_begin', '^(.+)@(\d+)(.*)', '\2');
        else
            lv_inst_filter := 's.inst_id=USERENV(''Instance'')';
    end case;

    -- compute sid_filter
    case
        when trim(lower('&ssid_begin')) like 'sid=%'       then lv_sid_filter   := 's.sid in ('||get_filter('&ssid_begin')||')'; --||trim(replace('&ssid_begin','sid=',''))||')';
        when trim(lower('&ssid_begin')) like 'user=%'      then lv_sid_filter   := 'lower(username) like '''         ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'username=%'  then lv_sid_filter   := 'lower(username) like '''         ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'machine=%'   then lv_sid_filter   := 'lower(machine) like '''          ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'program=%'   then lv_sid_filter   := 'lower(program) like '''          ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'service=%'   then lv_sid_filter   := 'lower(service_name) like '''     ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'module=%'    then lv_sid_filter   := 'lower(module) like '''           ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'action=%'    then lv_sid_filter   := 'lower(action) like '''           ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'osuser=%'    then lv_sid_filter   := 'lower(osuser) like '''           ||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'client_id=%' then lv_sid_filter   := 'lower(client_identifier) like '''||get_filter('&ssid_begin')||'''';
        when trim(lower('&ssid_begin')) like 'spid=%'      then lv_sid_filter   := '(s.inst_id,s.paddr) in (select /*+ UNNEST */ inst_id,addr from gv\$process where spid in ('||get_filter('&ssid_begin')||'))';
        when trim(lower('&ssid_begin')) like 'ospid=%'     then lv_sid_filter   := '(s.inst_id,s.paddr) in (select /*+ UNNEST */ inst_id,addr from gv\$process where spid in ('||get_filter('&ssid_begin')||'))';
        when trim(lower('&ssid_begin')) like 'pid=%'       then lv_sid_filter   := '(s.inst_id,s.paddr) in (select /*+ NO_UNNEST */ inst_id,addr from gv\$process where spid in ('||get_filter('&ssid_begin')||'))';
        when trim(lower('&ssid_begin')) like 'qcsid=%'     then lv_sid_filter   := '(s.inst_id,s.sid)   in (select /*+ NO_UNNEST */ inst_id,sid from gv\$px_session where qcsid in ('||get_filter('&ssid_begin')||'))';
        when trim(lower('&ssid_begin')) like 'qc=%'        then lv_sid_filter   := '(s.inst_id,s.sid)   in (select /*+ NO_UNNEST */ inst_id,sid from gv\$px_session where qcsid in ('||get_filter('&ssid_begin')||'))';
        when trim(lower('&ssid_begin')) like 'all%'        then lv_sid_filter   := '1=1';
        when trim(lower('&ssid_begin')) like 'bg%'         then lv_sid_filter   := 'type=''BACKGROUND''';
        when trim(lower('&ssid_begin')) like 'fg%'         then lv_sid_filter   := 'type=''USER''';
        when trim(lower('&ssid_begin')) like 'smon%'       then lv_sid_filter   := 'program like ''%(SMON)%''';
        when trim(lower('&ssid_begin')) like 'pmon%'       then lv_sid_filter   := 'program like ''%(PMON)%''';
        when trim(lower('&ssid_begin')) like 'ckpt%'       then lv_sid_filter   := 'program like ''%(CKPT)%''';
        when trim(lower('&ssid_begin')) like 'lgwr%'       then lv_sid_filter   := 'program like ''%(LGWR)%''';
        when trim(lower('&ssid_begin')) like 'dbwr%'       then lv_sid_filter   := 'program like ''%(DBW%)%''';
        when trim(lower('&ssid_begin')) like 'select%'     then lv_sid_filter := q'{(s.inst_id,s.sid) in (&snapper_sid)}';
        when trim(lower('&ssid_begin')) like '(%'          then lv_inst_filter := '/* inst_filter2 */ 1=1'; lv_sid_filter := q'{(s.inst_id,s.sid) in (&snapper_sid)}'; -- '1=1'; lv_inst_filter := '1=1';
        else                                                    lv_sid_filter   := '/* sid_filter_else_cond */ s.sid in ('||get_filter('&ssid_begin')||')'; --lv_sid_filter := '/* sid_filter_else_cond */ s.sid in (&ssid_begin)';
    end case;

    :inst_filter := lv_inst_filter;
    :sid_filter  := lv_inst_filter||' and '||lv_sid_filter;

    begin
        execute immediate 'select count(*) from x\$kcbwh where rownum = 1' into tmp;
        :x:= ' '; -- x$ tables are accessible, so dont comment any lines out
    exception
        when others then null;
    end;

    sys.dbms_describe.describe_procedure(
        'DBMS_SYSTEM.KSDWRT', null, null,
        o, p, l, a, dty, def, inout, len, prec, scal, rad, spa
    );

    :v:= ' ';

exception
    when others then null;
end;
/

with mod_banner as (
    select
        replace(banner,'9.','09.') banner
    from
        v\$version
    where rownum = 1
)
select
    decode(substr(banner, instr(banner, 'Release ')+8,2), '09', '--', '') snapper_ora10lower,
    decode(substr(banner, instr(banner, 'Release ')+8,2), '09', '',  '--') snapper_ora9,
    decode(substr(banner, instr(banner, 'Release ')+8,1), '1',  '',  '--') snapper_ora10higher,
    case when substr(banner, instr(banner, 'Release ')+8,2) >= '11' then '' else '--' end snapper_ora11higher,
    case when substr(banner, instr(banner, 'Release ')+8,2)  < '11' then '' else '--' end snapper_ora11lower,
    nvl(:v, '/* dbms_system is not accessible') dbms_system_accessible,
    nvl(:x, '--') x_accessible,
    case when substr( banner, instr(banner, 'Release ')+8, instr(substr(banner,instr(banner,'Release ')+8),' ') ) >= '10.2'     then ''   else '--' end yes_blk_inst,
    case when substr( banner, instr(banner, 'Release ')+8, instr(substr(banner,instr(banner,'Release ')+8),' ') ) >= '10.2'     then '--' else ''   end no_blk_inst,
    case when substr( banner, instr(banner, 'Release ')+8, instr(substr(banner,instr(banner,'Release ')+8),' ') ) >= '10.2.0.3' then ''   else '--' end yes_plsql_obj_id,
    case when substr( banner, instr(banner, 'Release ')+8, instr(substr(banner,instr(banner,'Release ')+8),' ') ) >= '10.2.0.3' then '--' else ''   end no_plsql_obj_id,
    case when lower('&snapper_options') like '%,begin%' or lower('&snapper_options') like 'begin%' or lower('&snapper_options') like '%,end%' or lower('&snapper_options') like 'end%' then '' else '--' end manual_snapshot,
    case when lower('&snapper_options') like '%,begin%' or lower('&snapper_options') like 'begin%' or lower('&snapper_options') like '%,end%' or lower('&snapper_options') like 'end%' then '--' else '' end use_dbms_lock,
    :sid_filter  sid_filter,
    :inst_filter inst_filter
from
    mod_banner
/

set termout on serveroutput on size 1000000 format wrapped

prompt Sampling SID &4 with interval &snapper_sleep seconds, taking &snapper_count snapshots...

-- let the Snapping start!!!
-- main()
declare
    -- Snapper start
    -- forward declarations
    procedure output(p_txt in varchar2);
    procedure fout;

    function tptformat( p_num in number,
                        p_stype in varchar2 default 'STAT',
                        p_precision in number default 2,
                        p_base in number default 10,
                        p_grouplen in number default 3
                   )
                   return varchar2;
    function getopt( p_parvalues in varchar2,
                     p_extract in varchar2,
                     p_delim in varchar2 default ','
                   )
                   return varchar2;


    -- type, constant, variable declarations

    -- trick for holding 32bit UNSIGNED event and stat_ids in 32bit SIGNED PLS_INTEGER
    pls_adjust constant number(10,0) := power(2,31) - 1;

    type srec is record (ts timestamp, stype varchar2(4), inst_id number, sid number, statistic# number, value number, event_count number );
    type stab is table of srec index by pls_integer;
    type ltab is table of srec index by varchar2(100); -- lookup tab for various average calculation
    s1 stab;
    s2 stab;
    l1 ltab;
    l2 ltab;

    type snrec is record (stype varchar2(4), statistic# number, name varchar2(100));
    type sntab is table of snrec index by pls_integer;
    sn_tmp sntab;
    sn sntab;

    type sntab_reverse is table of snrec index by varchar2(100); -- used for looking up stat id from stat name
    sn_reverse sntab_reverse;

    tmp_varchar2 varchar2(1000); -- misc

    function get_useful_average(c in srec /* curr_metric */, p in srec /* all_prev_metrics */) return varchar2;

    type tmp_sestab is table of gv\$session%rowtype index by pls_integer;
    type sestab is table of gv\$session%rowtype index by varchar2(20);

    g_sessions           sestab;
    g_empty_sessions     sestab;

    type hc_tab is table of number index by pls_integer; -- index is sql hash value
    type ses_hash_tab is table of hc_tab index by pls_integer; -- index is SID

    g_ses_hash_tab       ses_hash_tab;
    g_empty_ses_hash_tab ses_hash_tab;

    -- dbms_debug_vc2coll is a built-in collection present in every oracle db
    g_ash                sys.dbms_debug_vc2coll := new sys.dbms_debug_vc2coll();
    g_empty_ash          sys.dbms_debug_vc2coll := new sys.dbms_debug_vc2coll();
    g_snap1              sys.dbms_debug_vc2coll;
    g_snap2              sys.dbms_debug_vc2coll;

    g_ash_samples_taken  number := 0;

    g_count_statname  number;
    g_count_eventname number;

    g_mysid           number;

    i number;
    a number;
    b number;

    c number;
    delta number;
    evcnt number;
    changed_values number;
    pagesize number:=99999999999999;
    missing_values_s1 number := 0;
    missing_values_s2 number := 0;
    disappeared_sid   number := 0;
    lv_curr_sid       number := 0; -- used for determining whether to print an empty line between session stats
    d1 timestamp(6);
    d2 timestamp(6);
    ash_date1 date;
    ash_date2 date;
    lv_gather        varchar2(1000);
    gv_header_string varchar2(1000);
    lv_data_string   varchar2(1000);

    lv_ash           varchar2(1000);
    lv_stats         varchar2(1000);

    gather_stats     number := 0;
    gather_ash       number := 0;

    g_snap_begin    varchar2(1000);
    g_snap_end      varchar2(1000);

    -- CONFIGURABLE STUFF --

    -- this sets what are the default ash sample TOP reporting group by columns
    g_ash_columns     varchar2(1000) := 'inst_id + sql_id + sql_child_number + event + wait_class';
    g_ash_columns1    varchar2(1000) := 'inst_id + event + p1 + wait_class';
    g_ash_columns2    varchar2(1000) := 'inst_id + sid + user + machine + program';
    g_ash_columns3    varchar2(1000) := 'inst_id + plsql_object_id + plsql_subprogram_id + sql_id';

    -- output column configuration
    output_header     number := 0; -- 1=true 0=false
    output_username   number := 1; -- v$session.username
    output_inst       number := 0; -- inst
    output_sid        number := CASE WHEN dbms_utility.is_cluster_database = TRUE THEN 0 ELSE 1 END; -- just sid
    output_inst_sid   number := CASE WHEN dbms_utility.is_cluster_database = TRUE THEN 1 ELSE 0 END; -- inst_id and sid together
    output_time       number := 0; -- time of snapshot start
    output_seconds    number := 0; -- seconds in snapshot (shown in footer of each snapshot too)
    output_stype      number := 1; -- statistic type (WAIT,STAT,TIME,ENQG,LATG,...)
    output_sname      number := 1; -- statistic name
    output_delta      number := 1; -- raw delta
    output_delta_s    number := 0; -- raw delta normalized to per second
    output_hdelta     number := 0; -- human readable delta
    output_hdelta_s   number := 1; -- human readable delta normalized to per second
    output_percent    number := 1; -- percent of total time/samples
    output_eventcnt   number := 1; -- wait event count
    output_eventcnt_s number := 1; -- wait event count
    output_eventavg   number := 1; -- average wait duration
    output_pcthist    number := 1; -- percent of total visual bar (histogram) -- Histograms seem to work for me on 9.2.0.7 + - JBJ2)

    -- column widths in ASH report output
    w_inst_id                     number :=  4;
    w_sid                         number :=  6;
    w_username                    number := 20;
    w_machine                     number := 20;
    w_terminal                    number := 20;
    w_program                     number := 25;
    w_event                       number := 35;
    w_wait_class                  number := 15;
    w_state                       number :=  8;
    w_p1                          number := 20;
    w_p2                          number := 20;
    w_p3                          number := 20;
    w_row_wait_obj#               number := 10;
    w_row_wait_file#              number :=  6;
    w_row_wait_block#             number := 10;
    w_row_wait_row#               number :=  6;
    w_blocking_session_status     number := 15;
    w_blocking_instance           number := 12;
    w_blocking_session            number := 12;
    w_sql_hash_value              number := 12;
    w_sql_id                      number := 15;
    w_sql_child_number            number :=  9;
    w_plsql_entry_object_id       number := 10;
    w_plsql_entry_subprogram_id   number := 10;
    w_plsql_object_id             number := 10;
    w_plsql_subprogram_id         number := 10;
    w_module                      number := 25;
    w_action                      number := 25;
    w_client_identifier           number := 25;
    w_service_name                number := 25;

    w_activity_pct                number :=  7;

    -- END CONFIGURABLE STUFF --

    -- constants for ash collection extraction from the vc2 collection
    s_inst_id                      constant number :=  1 ;
    s_sid                          constant number :=  2 ;
    s_username                     constant number :=  3 ;
    s_machine                      constant number :=  4 ;
    s_terminal                     constant number :=  5 ;
    s_program                      constant number :=  6 ;
    s_event                        constant number :=  7 ;
    s_wait_class                   constant number :=  8 ;
    s_state                        constant number :=  9 ;
    s_p1                           constant number := 10 ;
    s_p2                           constant number := 11 ;
    s_p3                           constant number := 12 ;
    s_row_wait_obj#                constant number := 13 ;
    s_row_wait_file#               constant number := 14 ;
    s_row_wait_block#              constant number := 15 ;
    s_row_wait_row#                constant number := 16 ;
    s_blocking_session_status      constant number := 17 ;
    s_blocking_instance            constant number := 18 ;
    s_blocking_session             constant number := 19 ;
    s_sql_hash_value               constant number := 20 ;
    s_sql_id                       constant number := 21 ;
    s_sql_child_number             constant number := 22 ;
    s_plsql_entry_object_id        constant number := 23 ;
    s_plsql_entry_subprogram_id    constant number := 24 ;
    s_plsql_object_id              constant number := 25 ;
    s_plsql_subprogram_id          constant number := 26 ;
    s_module                       constant number := 27 ;
    s_action                       constant number := 28 ;
    s_client_identifier            constant number := 29 ;
    s_service_name                 constant number := 30 ;

    -- constants for ash collection reporting, which columns to show in report
    c_inst_id                      constant number := power(2, s_inst_id                  );
    c_sid                          constant number := power(2, s_sid                      );
    c_username                     constant number := power(2, s_username                 );
    c_machine                      constant number := power(2, s_machine                  );
    c_terminal                     constant number := power(2, s_terminal                 );
    c_program                      constant number := power(2, s_program                  );
    c_event                        constant number := power(2, s_event                    );
    c_wait_class                   constant number := power(2, s_wait_class               );
    c_state                        constant number := power(2, s_state                    );
    c_p1                           constant number := power(2, s_p1                       );
    c_p2                           constant number := power(2, s_p2                       );
    c_p3                           constant number := power(2, s_p3                       );
    c_row_wait_obj#                constant number := power(2, s_row_wait_obj#            );
    c_row_wait_file#               constant number := power(2, s_row_wait_file#           );
    c_row_wait_block#              constant number := power(2, s_row_wait_block#          );
    c_row_wait_row#                constant number := power(2, s_row_wait_row#            );
    c_blocking_session_status      constant number := power(2, s_blocking_session_status  );
    c_blocking_instance            constant number := power(2, s_blocking_instance        );
    c_blocking_session             constant number := power(2, s_blocking_session         );
    c_sql_hash_value               constant number := power(2, s_sql_hash_value           );
    c_sql_id                       constant number := power(2, s_sql_id                   );
    c_sql_child_number             constant number := power(2, s_sql_child_number         );
    c_plsql_entry_object_id        constant number := power(2, s_plsql_entry_object_id    );
    c_plsql_entry_subprogram_id    constant number := power(2, s_plsql_entry_subprogram_id);
    c_plsql_object_id              constant number := power(2, s_plsql_object_id          );
    c_plsql_subprogram_id          constant number := power(2, s_plsql_subprogram_id      );
    c_module                       constant number := power(2, s_module                   );
    c_action                       constant number := power(2, s_action                   );
    c_client_identifier            constant number := power(2, s_client_identifier        );
    c_service_name                 constant number := power(2, s_service_name             );


  /*---------------------------------------------------
    -- proc for outputting data to trace or dbms_output
    ---------------------------------------------------*/
    procedure output(p_txt in varchar2) is
    begin

        if (getopt('&snapper_options', 'out') is not null)
            or
           (getopt('&snapper_options', 'out') is null and getopt('&snapper_options', 'trace') is null)
        then
            dbms_output.put_line(p_txt);
        end if;

        -- The block below is a sqlplus trick for conditionally commenting out PL/SQL code
        &_IF_DBMS_SYSTEM_ACCESSIBLE
        if getopt('&snapper_options', 'trace') is not null then
            sys.dbms_system.ksdwrt(1, p_txt);
            sys.dbms_system.ksdfls;
        end if;
        -- */
    end; -- output

   /*---------------------------------------------------
   -- function for converting interval datatype to microseconds
   ---------------------------------------------------*/
   function get_seconds(i interval day to second) return number
   as
   begin
       return to_number(extract(second from i)) +
              to_number(extract(minute from i)) * 60 +
              to_number(extract(hour   from i)) * 60 * 60 +
              to_number(extract(day    from i)) * 60 * 60 * 24;
   end get_seconds;

  /*---------------------------------------------------
    -- proc for outputting data, utilizing global vars
    ---------------------------------------------------*/
    procedure fout is
        l_output_username VARCHAR2(100);
        gsid varchar2(20);
    begin
        --if s2(b).stype='WAIT' then output( 'DEBUG WAIT ' || sn(s2(b).statistic#).name || ' ' || delta ); end if;
        --output( 'DEBUG, Entering fout(), b='||to_char(b)||' sn(s2(b).statistic#='||s2(b).statistic# );
        --output( 'DEBUG, In fout(), a='||to_char(a)||' b='||to_char(b)||' s1.count='||s1.count||' s2.count='||s2.count||' s2.count='||s2.count);

        gsid := trim(to_char(s2(b).inst_id))||','||trim(to_char(s2(b).sid));

        if output_username = 1 then
            begin
                l_output_username := nvl( g_sessions(gsid).username, substr(g_sessions(gsid).program, instr(g_sessions(gsid).program,'(')) );
            exception
                when no_data_found then l_output_username := 'error';
                when others then raise;
            end;
        end if;

        -- DEBUG
        --output('before');
        --output (CASE WHEN output_eventavg    = 1 THEN CASE WHEN s2(b).stype IN ('WAIT') THEN lpad(tptformat(delta / CASE WHEN evcnt = 0 THEN 1 ELSE evcnt END, s2(b).stype), 10, ' ')||' average wait' ELSE get_useful_average(s2(b), s1(a)) END END);
        --output('after');

        output( CASE WHEN output_header      = 1 THEN 'SID= ' END
             || CASE WHEN output_inst        = 1 THEN to_char(s2(b).inst_id, '9999')||', ' END
             || CASE WHEN output_sid         = 1 THEN to_char(s2(b).sid,'999999')||', ' END
             || CASE WHEN output_inst_sid    = 1 THEN to_char(s2(b).sid,'99999')||' '||lpad('@'||trim(to_char(s2(b).inst_id, '99')),3)||', ' END
             || CASE WHEN output_username    = 1 THEN rpad(CASE s2(b).sid WHEN -1 THEN ' ' ELSE NVL(l_output_username, ' ') END, 10)||', ' END
             || CASE WHEN output_time        = 1 THEN to_char(d1, 'YYYYMMDD HH24:MI:SS')||', ' END
             || CASE WHEN output_seconds     = 1 THEN to_char(case get_seconds(d2-d1) when 0 then &snapper_sleep else get_seconds(d2-d1) end, '9999999')||', ' END
             || CASE WHEN output_stype       = 1 THEN s2(b).stype||', ' END
             || CASE WHEN output_sname       = 1 THEN rpad(sn(s2(b).statistic#).name, 58, ' ')||', ' END
             || CASE WHEN output_delta       = 1 THEN to_char(delta, '999999999999')||', ' END
             || CASE WHEN output_delta_s     = 1 THEN to_char(delta/(case get_seconds(d2-d1) when 0 then &snapper_sleep else get_seconds(d2-d1) end),'999999999')||', ' END
             || CASE WHEN output_hdelta      = 1 THEN lpad(tptformat(delta, s2(b).stype), 10, ' ')||', ' END
             || CASE WHEN output_hdelta_s    = 1 THEN lpad(tptformat(delta/(case get_seconds(d2-d1) when 0 then &snapper_sleep else get_seconds(d2-d1) end ), s2(b).stype), 10, ' ')||', ' END
             || CASE WHEN output_percent     = 1 THEN CASE WHEN s2(b).stype IN ('TIME','WAIT') THEN to_char(delta/CASE get_seconds(d2-d1) WHEN 0 THEN &snapper_sleep ELSE get_seconds(d2-d1) END / 10000, '9999.9')||'%' ELSE '        ' END END||', '
             || CASE WHEN output_pcthist     = 1 THEN CASE WHEN s2(b).stype IN ('TIME','WAIT') THEN rpad(rpad('[', ceil(round(delta/CASE get_seconds(d2-d1) WHEN 0 THEN &snapper_sleep ELSE get_seconds(d2-d1) END / 100000,1))+1, CASE WHEN s2(b).stype IN ('WAIT') THEN 'W' WHEN sn(s2(b).statistic#).name = 'DB CPU' THEN '@' ELSE '#' END),11,' ')||']' ELSE '            ' END END||', '
             || CASE WHEN output_eventcnt    = 1 THEN CASE WHEN s2(b).stype IN ('WAIT') THEN to_char(evcnt, '99999999') ELSE '         ' END END||', '
             || CASE WHEN output_eventcnt_s  = 1 THEN CASE WHEN s2(b).stype IN ('WAIT') THEN lpad(tptformat((evcnt / case get_seconds(d2-d1) when 0 then &snapper_sleep else get_seconds(d2-d1) end ), 'STAT' ), 10, ' ') ELSE '          ' END END||', '
             || CASE WHEN output_eventavg    = 1 THEN CASE WHEN s2(b).stype IN ('WAIT') THEN lpad(tptformat(delta / CASE WHEN evcnt = 0 THEN 1 ELSE evcnt END, s2(b).stype), 10, ' ')||' average wait' ELSE get_useful_average(s2(b), s1(a)) END END
        );

    end;


  /*---------------------------------------------------
   -- lookup stat delta helper calculator (l2.value - l1.value)
   ---------------------------------------------------*/
    function get_delta(metric_id in varchar2) return number
    is
        rec1 srec;
        rec2 srec;

        val1 number;
        val2 number;

        d    number;
    begin
        begin
            val1 := l1(metric_id).value;
        exception
            when no_data_found then val1 := 0;
        end;

        begin
            val2 := l2(metric_id).value;
        exception
            when no_data_found then val2 := 0;
        end;

        d := val2 - NVL(val1, 0);
        return d;
    end get_delta;

  /*---------------------------------------------------
   -- delta helper function for convenience - it allows to specify any metric delta, if not specified then get current one
   ---------------------------------------------------*/
    function gd(c in srec, metric_type in varchar2 DEFAULT NULL, metric_name in varchar2 DEFAULT NULL) return number
    is
        str varchar2(1000);
        tmp_delta number;
    begin
        if metric_type || metric_name  is null then
            str := c.stype||','||trim(to_char(c.inst_id))||','||trim(to_char(c.sid))||','||trim(to_char(c.statistic#,'999999999999999999999999'));
        else
            begin
                str := trim(metric_type)||','||trim(to_char(c.inst_id))||','||trim(to_char(c.sid))||','||trim(to_char(sn_reverse(metric_type||','||metric_name).statistic#));
            exception
                when no_data_found then return 0;
            end;
        end if;
        tmp_delta := get_delta(str);
        --output('tmp_delta '||c.stype||' '||tmp_delta);
        return tmp_delta;
        -- return get_delta(str);
    end;

    /*---------------------------------------------------
     -- function for calculating useful averages and ratios between metrics
     ---------------------------------------------------*/
    function get_useful_average(c in srec /* curr_metric */, p in srec /* all_prev_metrics */) return varchar2
    is
        ret varchar2(1000);
        mt  varchar2(100) := c.stype; -- metric_type
        mn  varchar2(100) := sn(c.statistic#).name; -- metric_name
    begin
        case
          when mt = 'STAT' then
            case
              when mn = 'bytes sent via SQL*Net to client'         then ret := lpad( tptformat(gd(c) / nullif(gd(c, 'STAT', 'SQL*Net roundtrips to/from client'),0), mt), 10) || ' bytes per roundtrip' ;
              when mn = 'bytes receive via SQL*Net from client'    then ret := lpad( tptformat(gd(c) / nullif(gd(c, 'STAT', 'SQL*Net roundtrips to/from client'),0), mt), 10) || ' bytes per roundtrip' ;
              when mn = 'redo size'                                then ret := lpad( tptformat(gd(c) / nullif(gd(c, 'STAT', 'user commits'                     ),0), mt), 10) || ' bytes per user commit';
              when mn = 'execute count'                            then ret := lpad( tptformat(gd(c) / nullif(gd(c, 'STAT', 'parse count (total)'              ),0), mt), 10) || ' executions per parse';
              when mn = 'parse count (total)'                      then ret := lpad( tptformat(gd(c) / nullif(gd(c, 'STAT', 'parse count (hard)'               ),0), mt), 10) || ' softparses per hardparse';
              when mn = 'session cursor cache hits'                then ret := lpad( tptformat(gd(c) -       (gd(c, 'STAT', 'parse count (total)'              )  ), mt), 10) || ' softparses avoided thanks to cursor cache';
              when mn = 'buffer is pinned count'                   then ret := lpad( tptformat(gd(c) / nullif(gd(c) + gd(c, 'STAT', 'session logical reads'),0) * 100, mt), 10) || ' % buffer gets avoided thanks to buffer pin caching';
              else ret :=                                                      lpad( tptformat(gd(c) / nullif(gd(c, 'STAT', 'execute count'),0), mt), 10) || ' per execution' ;
            end case; -- mt=stat, mn
          when mt = 'TIME' then
            -- this is ugly and wrong at the moment - will refactor some day
            case
              when mn = 'DB time'                                  then ret := lpad(tptformat(get_seconds(d2 - d1)*1000000 - gd(c) - nullif(gd(c, 'DB CPU', 'TIME')
                                                                                                            - gd(c, 'WAIT', 'pmon timer')
                                                                                                            - gd(c, 'WAIT', 'VKTM Logical Idle Wait')
                                                                                                            - gd(c, 'WAIT', 'VKTM Init Wait for GSGA')
                                                                                                            - gd(c, 'WAIT', 'IORM Scheduler Slave Idle Wait')
                                                                                                            - gd(c, 'WAIT', 'rdbms ipc message')
                                                                                                            - gd(c, 'WAIT', 'i/o slave wait')
                                                                                                            - gd(c, 'WAIT', 'VKRM Idle')
                                                                                                            - gd(c, 'WAIT', 'wait for unread message on broadcast channel')
                                                                                                            - gd(c, 'WAIT', 'wait for unread message on multiple broadcast channels')
                                                                                                            - gd(c, 'WAIT', 'class slave wait')
                                                                                                            - gd(c, 'WAIT', 'KSV master wait')
                                                                                                            - gd(c, 'WAIT', 'PING')
                                                                                                            - gd(c, 'WAIT', 'watchdog main loop')
                                                                                                            - gd(c, 'WAIT', 'DIAG idle wait')
                                                                                                            - gd(c, 'WAIT', 'ges remote message')
                                                                                                            - gd(c, 'WAIT', 'gcs remote message')
                                                                                                            - gd(c, 'WAIT', 'heartbeat monitor sleep')
                                                                                                            - gd(c, 'WAIT', 'GCR sleep')
                                                                                                            - gd(c, 'WAIT', 'SGA: MMAN sleep for component shrink')
                                                                                                            - gd(c, 'WAIT', 'MRP redo arrival')
                                                                                                            - gd(c, 'WAIT', 'LNS ASYNC archive log')
                                                                                                            - gd(c, 'WAIT', 'LNS ASYNC dest activation')
                                                                                                            - gd(c, 'WAIT', 'LNS ASYNC end of log')
                                                                                                            - gd(c, 'WAIT', 'simulated log write delay')
                                                                                                            - gd(c, 'WAIT', 'LGWR real time apply sync')
                                                                                                            - gd(c, 'WAIT', 'parallel recovery slave idle wait')
                                                                                                            - gd(c, 'WAIT', 'LogMiner builder: idle')
                                                                                                            - gd(c, 'WAIT', 'LogMiner builder: branch')
                                                                                                            - gd(c, 'WAIT', 'LogMiner preparer: idle')
                                                                                                            - gd(c, 'WAIT', 'LogMiner reader: log (idle)')
                                                                                                            - gd(c, 'WAIT', 'LogMiner reader: redo (idle)')
                                                                                                            - gd(c, 'WAIT', 'LogMiner client: transaction')
                                                                                                            - gd(c, 'WAIT', 'LogMiner: other')
                                                                                                            - gd(c, 'WAIT', 'LogMiner: activate')
                                                                                                            - gd(c, 'WAIT', 'LogMiner: reset')
                                                                                                            - gd(c, 'WAIT', 'LogMiner: find session')
                                                                                                            - gd(c, 'WAIT', 'LogMiner: internal')
                                                                                                            - gd(c, 'WAIT', 'Logical Standby Apply Delay')
                                                                                                            - gd(c, 'WAIT', 'parallel recovery coordinator waits for slave cleanup')
                                                                                                            - gd(c, 'WAIT', 'parallel recovery control message reply')
                                                                                                            - gd(c, 'WAIT', 'parallel recovery slave next change')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Txn Recovery Start')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Txn Recovery Reply')
                                                                                                            - gd(c, 'WAIT', 'fbar timer')
                                                                                                            - gd(c, 'WAIT', 'smon timer')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Metadata Update')
                                                                                                            - gd(c, 'WAIT', 'Space Manager: slave idle wait')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Index Merge Reply')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Index Merge Execute')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Index Merge Close')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: kdcph_mai')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: kdcphc_ack')
                                                                                                            - gd(c, 'WAIT', 'shared server idle wait')
                                                                                                            - gd(c, 'WAIT', 'dispatcher timer')
                                                                                                            - gd(c, 'WAIT', 'cmon timer')
                                                                                                            - gd(c, 'WAIT', 'pool server timer')
                                                                                                            - gd(c, 'WAIT', 'JOX Jit Process Sleep')
                                                                                                            - gd(c, 'WAIT', 'jobq slave wait')
                                                                                                            - gd(c, 'WAIT', 'pipe get')
                                                                                                            - gd(c, 'WAIT', 'PX Deque wait')
                                                                                                            - gd(c, 'WAIT', 'PX Idle Wait')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Join ACK')
                                                                                                            - gd(c, 'WAIT', 'PX Deq Credit: need buffer')
                                                                                                            - gd(c, 'WAIT', 'PX Deq Credit: send blkd')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Msg Fragment')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Parse Reply')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Execute Reply')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Execution Msg')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Table Q Normal')
                                                                                                            - gd(c, 'WAIT', 'PX Deq: Table Q Sample')
                                                                                                            - gd(c, 'WAIT', 'Streams fetch slave: waiting for txns')
                                                                                                            - gd(c, 'WAIT', 'Streams: waiting for messages')
                                                                                                            - gd(c, 'WAIT', 'Streams capture: waiting for archive log')
                                                                                                            - gd(c, 'WAIT', 'single-task message')
                                                                                                            - gd(c, 'WAIT', 'SQL*Net message from client')
                                                                                                            - gd(c, 'WAIT', 'SQL*Net vector message from client')
                                                                                                            - gd(c, 'WAIT', 'SQL*Net vector message from dblink')
                                                                                                            - gd(c, 'WAIT', 'PL/SQL lock timer')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: emn coordinator idle wait')
                                                                                                            - gd(c, 'WAIT', 'EMON slave idle wait')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: waiting for messages in the queue')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: waiting for time management or cleanup tasks')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: delete acknowledged messages')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: deallocate messages from Streams Pool')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: qmn coordinator idle wait')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: qmn slave idle wait')
                                                                                                            - gd(c, 'WAIT', 'Streams AQ: RAC qmn coordinator idle wait')
                                                                                                            - gd(c, 'WAIT', 'HS message to agent')
                                                                                                            - gd(c, 'WAIT', 'ASM background timer')
                                                                                                            - gd(c, 'WAIT', 'auto-sqltune: wait graph update')
                                                                                                            - gd(c, 'WAIT', 'WCR: replay client notify')
                                                                                                            - gd(c, 'WAIT', 'WCR: replay clock')
                                                                                                            - gd(c, 'WAIT', 'WCR: replay paused')
                                                                                                            - gd(c, 'WAIT', 'JS external job')
                                                                                                            - gd(c, 'WAIT', 'cell worker idle')
                                                                                           ,0) , mt), 10) || ' unaccounted time' ;
              else null;
            end case; -- mt=time, mn
        end case; -- mt
        return ret;
    end get_useful_average;

  /*---------------------------------------------------
    -- function for converting large numbers to human-readable format
    ---------------------------------------------------*/
    function tptformat( p_num in number,
                        p_stype in varchar2 default 'STAT',
                        p_precision in number default 2,
                        p_base in number default 10,    -- for KiB/MiB formatting use
                        p_grouplen in number default 3  -- p_base=2 and p_grouplen=10
                      )
                      return varchar2
    is
    begin
        if p_num = 0 then return '0'; end if;
        if p_num IS NULL then return '~'; end if;

        if p_stype in ('WAIT','TIME') then

            return
                round(
                    p_num / power( p_base , trunc(log(p_base,abs(p_num)))-trunc(mod(log(p_base,abs(p_num)),p_grouplen)) ), p_precision
                )
                || case trunc(log(p_base,abs(p_num)))-trunc(mod(log(p_base,abs(p_num)),p_grouplen))
                       when 0            then 'us'
                       when 1            then 'us'
                       when p_grouplen*1 then 'ms'
                       when p_grouplen*2 then 's'
                       when p_grouplen*3 then 'ks'
                       when p_grouplen*4 then 'Ms'
                       else '*'||p_base||'^'||to_char( trunc(log(p_base,abs(p_num)))-trunc(mod(log(p_base,abs(p_num)),p_grouplen)) )||' us'
                    end;

        else

            return
                round(
                    p_num / power( p_base , trunc(log(p_base,abs(p_num)))-trunc(mod(log(p_base,abs(p_num)),p_grouplen)) ), p_precision
                )
                || case trunc(log(p_base,abs(p_num)))-trunc(mod(log(p_base,abs(p_num)),p_grouplen))
                       when 0            then ''
                       when 1            then ''
                       when p_grouplen*1 then 'k'
                       when p_grouplen*2 then 'M'
                       when p_grouplen*3 then 'G'
                       when p_grouplen*4 then 'T'
                       when p_grouplen*5 then 'P'
                       when p_grouplen*6 then 'E'
                       else '*'||p_base||'^'||to_char( trunc(log(p_base,abs(p_num)))-trunc(mod(log(p_base,abs(p_num)),p_grouplen)) )
                    end;

        end if;

    end; -- tptformat

  /*---------------------------------------------------
    -- simple function for parsing arguments from parameter string
    ---------------------------------------------------*/
    function getopt( p_parvalues in varchar2,
                     p_extract in varchar2,
                     p_delim in varchar2 default ','
                   ) return varchar2
    is
        ret varchar(1000) := NULL;
    begin

      -- dbms_output.put('p_parvalues = ['||p_parvalues||'] ' );
      -- dbms_output.put('p_extract = ['||p_extract||'] ' );

        if lower(p_parvalues) like lower(p_extract)||'%'
        or lower(p_parvalues) like '%'||p_delim||lower(p_extract)||'%' then

            ret :=
                nvl (
                    substr(p_parvalues,
                            instr(p_parvalues, p_extract)+length(p_extract),
                            case
                                instr(
                                    substr(p_parvalues,
                                            instr(p_parvalues, p_extract)+length(p_extract)
                                    )
                                    , p_delim
                                )
                            when 0 then length(p_parvalues)
                            else
                                instr(
                                    substr(p_parvalues,
                                            instr(p_parvalues, p_extract)+length(p_extract)
                                    )
                                    , p_delim
                                ) - 1
                            end
                    )
                    , chr(0) -- in case parameter was specified but with no value
                );

        else
            ret := null; -- no parameter found
        end if;

      -- dbms_output.put_line('ret = ['||replace(ret,chr(0),'\0')||']');

        return ret;

    end; -- getopt

  /*---------------------------------------------------
    -- proc for getting session list with username, osuser, machine etc
    ---------------------------------------------------*/
   procedure get_sessions is
       tmp_sessions tmp_sestab;
   begin

       select /*+ unnest */ /* get_session_list:1 */
           *
       bulk collect into
           tmp_sessions
       from
           gv\$session s
       where
           1=1
       and (
           &sid_filter
       ) ;
           --(inst_id,sid) in (&snapper_sid);

       g_sessions := g_empty_sessions;

       for i in 1..tmp_sessions.count loop
           g_sessions(tmp_sessions(i).inst_id||','||tmp_sessions(i).sid) := tmp_sessions(i);
       end loop;

   end; -- get_sessions

  /*---------------------------------------------------
    -- function for getting session list with username, osuser, machine etc
    -- this func does not update the g_sessions global array but returns session info as return value
    ---------------------------------------------------*/
   function get_sessions return sestab is
       tmp_sessions tmp_sestab;
       l_return_sessions sestab;
   begin

       select /*+ unnest */ /* get_session_list:2 */
           *
       bulk collect into
           tmp_sessions
       from
           gv\$session s
       where
           1=1
       and (&sid_filter) ;
         --(inst_id,sid) in (&snapper_sid);

       for i in 1..tmp_sessions.count loop
           --output('get_sessions i='||i||' sid='||tmp_sessions(i).sid);
           l_return_sessions(tmp_sessions(i).inst_id||','||tmp_sessions(i).sid) := tmp_sessions(i);
       end loop;

       return l_return_sessions;

   end; -- get_sessions


   function sitem(p in varchar2) return varchar2 as
   begin
      return '<'||translate(p, '<>', '__')||'>';
   end; -- sitem varchar2

   function sitem(p in number) return varchar2 as
   begin
      return '<'||to_char(p)||'>';
   end; -- sitem number

   function sitem(p in date) return varchar2 as
   begin
      return '<'||to_char(p, 'YYYY-MM-DD HH24:MI:SS')||'>';
   end; -- sitem date

   function sitem_raw(p in raw) return varchar2 as
   begin
      return '<'||upper(rawtohex(p))||'>';
   end; -- sitem_raw

   procedure reset_ash is
   begin
      g_ash_samples_taken := 0;
      -- clear g_ash
      g_ash := new sys.dbms_debug_vc2coll();
   end; -- reset_ash

   procedure extract_ash is
       ash_i varchar2(30);
       s gv\$session%rowtype;

   begin
       g_ash_samples_taken := g_ash_samples_taken + 1;
       ash_i := g_sessions.first;

       while ash_i is not null loop

          s := g_sessions(ash_i);
          if -- active, on cpu
              (s.status = 'ACTIVE' and s.state != 'WAITING' and s.sid != g_mysid)
          or -- active, waiting for non-idle wait
              (s.status = 'ACTIVE' and s.state = 'WAITING' and s.wait_class != 'Idle' and s.sid != g_mysid)
          then
             --output('extract_ash: i='||i||' sid='||s.sid||' hv='||s.sql_hash_value||' sqlid='||s.sql_id);
             -- if not actually waiting for anything, clear the past wait event details
             if s.state != 'WAITING' then
                 s.state:='ON CPU';
                 s.event:='ON CPU';
                 s.wait_class:='ON CPU'; --TODO: What do we need to do for 9i here?
                 s.p1:=NULL;
                 s.p2:=NULL;
                 s.p3:=NULL;
             end if;

             g_ash.extend;

             -- max length 1000 bytes (due to dbms_debug_vc2coll)
             g_ash(g_ash.count) := substr(
                            sitem(s.inst_id)                   --  1
                          ||sitem(s.sid)                       --  2
                          ||sitem(s.username)                  --  3  -- 30 bytes
                          ||sitem(s.machine)                   --  4  -- 64 bytes
                          ||sitem(s.terminal)                  --  5  -- 30 bytes
                          ||sitem(s.program)                   --  6  -- 48 bytes
                          ||sitem(s.event)                     --  7  -- 64 bytes
                          ||sitem(s.wait_class)                --  8  -- 64 bytes, 10g+
                          ||sitem(s.state)                     --  9
                          ||sitem(s.p1)                        -- 10
                          ||sitem(s.p2)                        -- 11
                          ||sitem(s.p3)                        -- 12
                          ||sitem(s.row_wait_obj#)             -- 13
                          ||sitem(s.row_wait_file#)            -- 14
                          ||sitem(s.row_wait_block#)           -- 15
                          ||sitem(s.row_wait_row#)             -- 16
                          ||sitem(s.blocking_session_status)   -- 17   -- 10g+
           &_NO_BLK_INST  ||sitem('N/A')                       -- 17   -- 10gR2+
          &_YES_BLK_INST  ||sitem(s.blocking_instance)         -- 18   -- 10gR2+
                          ||sitem(s.blocking_session)          -- 19   -- 10g+
                          ||sitem(s.sql_hash_value)            -- 20
                          ||sitem(s.sql_id)                    -- 21   -- 10g+
                          ||sitem(s.sql_child_number)          -- 22   -- 10g+
      &_NO_PLSQL_OBJ_ID   ||sitem('N/A')                       -- 23
      &_NO_PLSQL_OBJ_ID   ||sitem('N/A')                       -- 24
      &_NO_PLSQL_OBJ_ID   ||sitem('N/A')                       -- 25
      &_NO_PLSQL_OBJ_ID   ||sitem('N/A')                       -- 22
     &_YES_PLSQL_OBJ_ID   ||sitem(s.plsql_entry_object_id)     -- 23
     &_YES_PLSQL_OBJ_ID   ||sitem(s.plsql_entry_subprogram_id) -- 24
     &_YES_PLSQL_OBJ_ID   ||sitem(s.plsql_object_id)           -- 25
     &_YES_PLSQL_OBJ_ID   ||sitem(s.plsql_subprogram_id)       -- 26
                          ||sitem(s.module)                    -- 27  -- 48 bytes
                          ||sitem(s.action)                    -- 28  -- 32 bytes
                          ||sitem(s.client_identifier)         -- 29  -- 64 bytes
                          ||sitem(s.service_name)              -- 30  -- 64 bytes, 10g+
                    , 1, 1000);

          end if; -- sample is of an active session

          ash_i := g_sessions.next(ash_i);

       end loop;

   exception
       when no_data_found then output('error in extract_ash(): no_data_found for item '||i);
   end; -- extract_ash


   /*---------------------------------------------------
    -- proc for querying performance data into collections
    ---------------------------------------------------*/
   procedure snap( p_snapdate out timestamp, p_stats out stab, l_stats out ltab, p_stats_string out sys.dbms_debug_vc2coll) is

        lv_include_stat  varchar2(1000) := nvl( lower(getopt('&snapper_options', 'sinclude=' )), '%');
        lv_include_latch varchar2(1000) := nvl( lower(getopt('&snapper_options', 'linclude=' )), '%');
        lv_include_time  varchar2(1000) := nvl( lower(getopt('&snapper_options', 'tinclude=' )), '%');
        lv_include_wait  varchar2(1000) := nvl( lower(getopt('&snapper_options', 'winclude=' )), '%');

        lstr             varchar2(1000);

   begin

        p_snapdate := systimestamp;

        select /* get_session_stats */ p_snapdate ts, snapper_stats.*
        bulk collect into p_stats
        from (
                                         select 'STAT' stype, s.inst_id, s.sid, ss.statistic# - pls_adjust statistic#, ss.value, null event_count
                                         from gv\$session s, gv\$sesstat ss
                                         where &sid_filter --(inst_id,sid) in (&snapper_sid)
                                         and s.inst_id = ss.inst_id
                                         and s.sid = ss.sid
                                         and  (lv_gather like '%s%' or lv_gather like '%a%')
                                         and ss.statistic# in (select /*+ no_unnest */ statistic# from v\$statname
                                                            where lower(name) like '%'||lv_include_stat||'%'
                                                            or regexp_like (name, lv_include_stat, 'i')
                                                           )
                                         --
                                         union all
                                         select
                                                'WAIT', s.inst_id, s.sid,
                                                en.event# + (select count(*) from v\$statname) + 1 - pls_adjust,
                                                nvl(se.time_waited_micro,0) + ( decode(se.event||s.state, s.event||'WAITING', s.seconds_in_wait, 0) * 1000000 ) value, total_waits event_count
                                         from gv\$session s, gv\$session_event se, v\$event_name en
                                         where &sid_filter
                                         and   s.sid = se.sid
                                         and   s.inst_id = se.inst_id
                                         and   se.event = en.name
                                         --and   (se.inst_id, se.sid) in (&snapper_sid)
                                         and   (lv_gather like '%w%' or lv_gather like '%a%')
                                         and   en.event#  in (select event# from v\$event_name
                                                            where lower(name) like '%'||lv_include_wait||'%'
                                                            or    regexp_like (name, lv_include_wait, 'i')
                                                           )
                                         --
                                         union all
                                         select 'TIME' stype, s.inst_id, s.sid, st.stat_id - pls_adjust statistic#, st.value, null event_count
                                         from gv\$session s, gv\$sess_time_model st
                                         where &sid_filter --(inst_id,sid) in (&snapper_sid)
                                         and s.inst_id = st.inst_id
                                         and s.sid = st.sid
                                         and   (lv_gather like '%t%' or lv_gather like '%a%')
                                         and st.stat_id in (select stat_id from gv\$sys_time_model
                                                            where lower(stat_name) like '%'||lv_include_time||'%'
                                                            or    regexp_like (stat_name, lv_include_time, 'i')
                                                           )
                                         --
                                         union all
                                         select 'LATG', s.inst_id, -1 sid,
                                               s.latch# +
                                                   (select count(*) from v\$statname) +
                                                   (select count(*) from v\$event_name) +
                                                   1 - pls_adjust statistic#,
                                               s.gets + s.immediate_gets value, null event_count
                                         from gv\$latch s
                                         where &inst_filter
                                         and (lv_gather like '%l%' or lv_gather like '%a%')
                                         and latch# in (select latch# from v\$latchname
                                                        where lower(name) like '%'||lv_include_latch||'%'
                                                        or    regexp_like (name, lv_include_latch, 'i')
                                                       )
                                         --
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  union all
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  select 'BUFG', to_number(sys_context('userenv', 'instance')), -1 sid,
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        sw.indx +
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER            (select count(*) from v\$statname) +
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER            (select count(*) from v\$event_name) +
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER            (select count(*) from gv\$latch) +
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER            1 - pls_adjust statistic#,
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        why.why0+why.why1+why.why2+sw.other_wait value, null event_count
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  from
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        x\$kcbuwhy why,
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        x\$kcbwh       dsc,
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        x\$kcbsw       sw
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  where
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        why.indx = dsc.indx
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   why.inst_id = dsc.inst_id
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   dsc.inst_id = sw.inst_id
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   why.inst_id = sw.inst_id
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   why.why0 + why.why1 + why.why2 + sw.other_wait > 0
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   dsc.indx = sw.indx
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   why.indx = sw.indx
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER        -- deliberate cartesian join
 &_IF_X_ACCESSIBLE &_IF_ORA11_OR_HIGHER  and   (lv_gather like '%b%' or lv_gather like '%a%')
                                         --
                                         union all
                                         select 'ENQG', s.inst_id, -1 sid,
                                               ascii(substr(s.eq_type,1,1))*256 + ascii(substr(s.eq_type,2,1)) +
                                                   (select count(*) from v\$statname) +
                                                   (select count(*) from v\$event_name) +
                                                   (select count(*) from gv\$latch) +
  &_IF_X_ACCESSIBLE                                (select count(*) from x\$kcbwh) +
                                                   1 - pls_adjust statistic#,
                                               s.total_req# value, null event_count
                                         from gv\$enqueue_stat s
                                         where &inst_filter
                                         and   (lv_gather like '%e%' or lv_gather like '%a%')
        ) snapper_stats
        order by inst_id, sid, stype, statistic#;

        if p_stats.COUNT > 0 then
            -- l_stats is an associative array for stats lookup, used for the useful averages calculation
            -- p_stats_string is a dbms_debug_vc2coll collection datatype for "persisting" stats values across snapper DB calls (for "before" and "after" snaps)
            p_stats_string := sys.dbms_debug_vc2coll();
            for s in p_stats.first..p_stats.last loop
                -- type srec is record (stype varchar2(4), sid number, statistic# number, value number, event_count number );
                lstr := p_stats(s).stype||','||trim(to_char(p_stats(s).inst_id))||','||trim(to_char(p_stats(s).sid))||','||trim(to_char(p_stats(s).statistic#,'999999999999999999999999'));
                l_stats(lstr) := p_stats(s);

                if g_snap_begin is not null then
                    p_stats_string.extend();
                    p_stats_string(s) := TO_CHAR(p_stats(s).ts, 'YYYY-MM-DD HH24:MI:SS.FF')              ||','||
                                         p_stats(s).stype                                                ||','||
                                         TO_CHAR(p_stats(s).inst_id)                                     ||','||
                                         TO_CHAR(p_stats(s).sid)                                         ||','||
                                         TRIM(TO_CHAR(p_stats(s).statistic#, '999999999999999999999999'))||','||
                                         TRIM(TO_CHAR(p_stats(s).value,      '999999999999999999999999'))||','||
                                         TRIM(TO_CHAR(p_stats(s).event_count,'999999999999999999999999'));
                    --output('p_stats.p_stats_string='||p_stats_string(s));
                end if;
            end loop; -- s in (p_stats)
        end if;  -- p.stats.COUNT > 0
   end snap;


   /*---------------------------------------------------
    -- proc for reversing the string-normalized
    -- stats array into lookup tables/collections
    ---------------------------------------------------*/
   procedure snap_from_stats_string (p_string_stats in sys.dbms_debug_vc2coll, p_snapdate out timestamp, p_stats out stab, l_stats out ltab)
   is
     lstr varchar2(1000);
     lv_rec srec;
   begin
       p_snapdate := NULL;
       --type srec is record (stype varchar2(4), sid number, statistic# number, value number, event_count number );
       for s in p_string_stats.first .. p_string_stats.last loop
           lv_rec.ts          := TO_TIMESTAMP(replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 1),',',''), 'YYYY-MM-DD HH24:MI:SS.FF');
           lv_rec.stype       :=              replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 2),',','');
           lv_rec.inst_id     :=    TO_NUMBER(replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 3),',',''));
           lv_rec.sid         :=    TO_NUMBER(replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 4),',',''));
           lv_rec.statistic#  :=    TO_NUMBER(replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 5),',',''));
           lv_rec.value       :=    TO_NUMBER(replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 6),',',''));
           lv_rec.event_count :=    TO_NUMBER(replace(regexp_substr(p_string_stats(s)||',', '(.*?),', 1, 7),',',''));
           --output('snap_from_stats_string.event_count = '||to_char(lv_rec.event_count));

           p_stats(s) := lv_rec;
           lstr := p_stats(s).stype||','||trim(to_char(p_stats(s).inst_id))||','||trim(to_char(p_stats(s).sid))||','||trim(to_char(p_stats(s).statistic#,'999999999999999999999999'));
           l_stats(lstr) := p_stats(s);
       end loop;

       p_snapdate := lv_rec.ts;
   end snap_from_stats_string;

   /*---------------------------------------------------
    -- proc for dumping ASH data out in grouped
    -- and ordered fashion
    ---------------------------------------------------*/
    procedure out_ash( p_ash_columns in varchar2, p_topn in number := 10 ) as

        -- whether to print given column or not
        p_inst_id                     number := 0;
        p_sid                         number := 0;
        p_username                    number := 0;
        p_machine                     number := 0;
        p_terminal                    number := 0;
        p_program                     number := 0;
        p_event                       number := 0;
        p_wait_class                  number := 0;
        p_state                       number := 0;
        p_p1                          number := 0;
        p_p2                          number := 0;
        p_p3                          number := 0;
        p_row_wait_obj#               number := 0;
        p_row_wait_file#              number := 0;
        p_row_wait_block#             number := 0;
        p_row_wait_row#               number := 0;
        p_blocking_session_status     number := 0;
        p_blocking_instance           number := 0;
        p_blocking_session            number := 0;
        p_sql_hash_value              number := 0;
        p_sql_id                      number := 0;
        p_sql_child_number            number := 0;
        p_plsql_entry_object_id       number := 0;
        p_plsql_entry_subprogram_id   number := 0;
        p_plsql_object_id             number := 0;
        p_plsql_subprogram_id         number := 0;
        p_module                      number := 0;
        p_action                      number := 0;
        p_client_identifier           number := 0;
        p_service_name                number := 0;

        -- temporary variables for holding session details (for later formatting)
        o_inst_id                     varchar2(100);
        o_sid                         varchar2(100);
        o_username                    varchar2(100);
        o_machine                     varchar2(100);
        o_terminal                    varchar2(100);
        o_program                     varchar2(100);
        o_event                       varchar2(100);
        o_wait_class                  varchar2(100);
        o_state                       varchar2(100);
        o_p1                          varchar2(100);
        o_p2                          varchar2(100);
        o_p3                          varchar2(100);
        o_row_wait_obj#               varchar2(100);
        o_row_wait_file#              varchar2(100);
        o_row_wait_block#             varchar2(100);
        o_row_wait_row#               varchar2(100);
        o_blocking_session_status     varchar2(100);
        o_blocking_instance           varchar2(100);
        o_blocking_session            varchar2(100);
        o_sql_hash_value              varchar2(100);
        o_sql_id                      varchar2(100);
        o_sql_child_number            varchar2(100);
        o_plsql_entry_object_id       varchar2(100);
        o_plsql_entry_subprogram_id   varchar2(100);
        o_plsql_object_id             varchar2(100);
        o_plsql_subprogram_id         varchar2(100);
        o_module                      varchar2(100);
        o_action                      varchar2(100);
        o_client_identifier           varchar2(100);
        o_service_name                varchar2(100);

        -- helper local vars
        l_ash_grouping                number := 0;
        l_output_line                 varchar2(4000);
        l_ash_header_line             varchar2(4000);

    begin

      -- bail out if no ASH samples recorded
      if g_ash.count = 0 then
          output('    <No active sessions captured during the sampling period>');
          return;
      end if;


      l_ash_header_line := 'Active%';

      -- ash,ash1,ash2,ash3 parameter column group tokenizer
      for s in (
          SELECT LEVEL
                 , SUBSTR
                   ( TOKEN
                    , DECODE(LEVEL, 1, 1, INSTR(TOKEN, DELIMITER, 1, LEVEL-1)+1)
                    , INSTR(TOKEN, DELIMITER, 1, LEVEL) -
                   DECODE(LEVEL, 1, 1, INSTR(TOKEN, DELIMITER, 1, LEVEL-1)+1)
                   ) TOKEN
          FROM ( SELECT REPLACE(  LOWER(p_ash_columns)  ,' ','')||'+' AS TOKEN
                 , '+'                        AS DELIMITER
                 FROM DUAL
          )
          CONNECT BY
              INSTR(TOKEN, DELIMITER, 1, LEVEL)>0
          ORDER BY
              LEVEL ASC
      ) loop

          case s.token
              -- actual column names in gv\$session
              when 'inst_id'                      then l_ash_grouping := l_ash_grouping + c_inst_id                  ; l_ash_header_line := l_ash_header_line || ' | ' || lpad('INST_ID'                   , w_inst_id                  , ' ');
              when 'sid'                          then l_ash_grouping := l_ash_grouping + c_sid                      ; l_ash_header_line := l_ash_header_line || ' | ' || lpad('SID'                       , w_sid                      , ' ');
              when 'username'                     then l_ash_grouping := l_ash_grouping + c_username                 ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('USERNAME'                  , w_username                 , ' ');
              when 'machine'                      then l_ash_grouping := l_ash_grouping + c_machine                  ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('MACHINE'                   , w_machine                  , ' ');
              when 'terminal'                     then l_ash_grouping := l_ash_grouping + c_terminal                 ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('TERMINAL'                  , w_terminal                 , ' ');
              when 'program'                      then l_ash_grouping := l_ash_grouping + c_program                  ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PROGRAM'                   , w_program                  , ' ');
              when 'event'                        then l_ash_grouping := l_ash_grouping + c_event                    ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('EVENT'                     , w_event                    , ' ');
              when 'wait_class'                   then l_ash_grouping := l_ash_grouping + c_wait_class               ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('WAIT_CLASS'                , w_wait_class               , ' ');
              when 'state'                        then l_ash_grouping := l_ash_grouping + c_state                    ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('STATE'                     , w_state                    , ' ');
              when 'p1'                           then l_ash_grouping := l_ash_grouping + c_p1                       ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('P1'                        , w_p1                       , ' ');
              when 'p2'                           then l_ash_grouping := l_ash_grouping + c_p2                       ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('P2'                        , w_p2                       , ' ');
              when 'p3'                           then l_ash_grouping := l_ash_grouping + c_p3                       ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('P3'                        , w_p3                       , ' ');
              when 'row_wait_obj#'                then l_ash_grouping := l_ash_grouping + c_row_wait_obj#            ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_OBJ#'             , w_row_wait_obj#            , ' ');
              when 'row_wait_file#'               then l_ash_grouping := l_ash_grouping + c_row_wait_file#           ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_FILE#'            , w_row_wait_file#           , ' ');
              when 'row_wait_block#'              then l_ash_grouping := l_ash_grouping + c_row_wait_block#          ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_BLOCK#'           , w_row_wait_block#          , ' ');
              when 'row_wait_row#'                then l_ash_grouping := l_ash_grouping + c_row_wait_row#            ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_ROW#'             , w_row_wait_row#            , ' ');
              when 'blocking_session_status'      then l_ash_grouping := l_ash_grouping + c_blocking_session_status  ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('BLOCKING_SESSION_STATUS'   , w_blocking_session_status  , ' ');
              when 'blocking_instance'            then l_ash_grouping := l_ash_grouping + c_blocking_instance        ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('BLOCKING_INSTANCE'         , w_blocking_instance        , ' ');
              when 'blocking_session'             then l_ash_grouping := l_ash_grouping + c_blocking_session         ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('BLOCKING_SESSION'          , w_blocking_session         , ' ');
              when 'sql_hash_value'               then l_ash_grouping := l_ash_grouping + c_sql_hash_value           ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SQL_HASH_VALUE'            , w_sql_hash_value           , ' ');
              when 'sql_id'                       then l_ash_grouping := l_ash_grouping + c_sql_id                   ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SQL_ID'                    , w_sql_id                   , ' ');
              when 'sql_child_number'             then l_ash_grouping := l_ash_grouping + c_sql_child_number         ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SQL_CHILD_NUMBER'          , w_sql_child_number         , ' ');
              when 'plsql_entry_object_id'        then l_ash_grouping := l_ash_grouping + c_plsql_entry_object_id    ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_ENTRY_OBJECT_ID'     , w_plsql_entry_object_id    , ' ');
              when 'plsql_entry_subprogram_id'    then l_ash_grouping := l_ash_grouping + c_plsql_entry_subprogram_id; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_ENTRY_SUBPROGRAM_ID' , w_plsql_entry_subprogram_id, ' ');
              when 'plsql_object_id'              then l_ash_grouping := l_ash_grouping + c_plsql_object_id          ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_OBJECT_ID'           , w_plsql_object_id          , ' ');
              when 'plsql_subprogram_id'          then l_ash_grouping := l_ash_grouping + c_plsql_subprogram_id      ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_SUBPROGRAM_ID'       , w_plsql_subprogram_id      , ' ');
              when 'module'                       then l_ash_grouping := l_ash_grouping + c_module                   ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('MODULE'                    , w_module                   , ' ');
              when 'action'                       then l_ash_grouping := l_ash_grouping + c_action                   ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ACTION'                    , w_action                   , ' ');
              when 'client_identifier'            then l_ash_grouping := l_ash_grouping + c_client_identifier        ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('CLIENT_IDENTIFIER'         , w_client_identifier        , ' ');
              when 'service_name'                 then l_ash_grouping := l_ash_grouping + c_service_name             ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SERVICE_NAME'              , w_service_name             , ' ');
              -- aliases for convenience (only either real name or alias should be used together at the same time)
              when 'user'                         then l_ash_grouping := l_ash_grouping + c_username                 ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('USERNAME'                  , w_username                 , ' ');
              when 'obj'                          then l_ash_grouping := l_ash_grouping + c_row_wait_obj#            ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_OBJ#'             , w_row_wait_obj#            , ' ');
              when 'file'                         then l_ash_grouping := l_ash_grouping + c_row_wait_file#           ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_FILE#'            , w_row_wait_file#           , ' ');
              when 'block'                        then l_ash_grouping := l_ash_grouping + c_row_wait_block#          ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_BLOCK#'           , w_row_wait_block#          , ' ');
              when 'row'                          then l_ash_grouping := l_ash_grouping + c_row_wait_row#            ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ROW_WAIT_ROW#'             , w_row_wait_row#            , ' ');
              when 'bss'                          then l_ash_grouping := l_ash_grouping + c_blocking_session_status  ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('BLOCKING_SESSION_STATUS'   , w_blocking_session_status  , ' ');
              when 'bsi'                          then l_ash_grouping := l_ash_grouping + c_blocking_instance        ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('BLOCKING_INSTANCE'         , w_blocking_instance        , ' ');
              when 'bs'                           then l_ash_grouping := l_ash_grouping + c_blocking_session         ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('BLOCKING_SESSION'          , w_blocking_session         , ' ');
              when 'sql'                          then l_ash_grouping := l_ash_grouping + c_sql_hash_value           ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SQL_HASH_VALUE'            , w_sql_hash_value           , ' ');
              when 'sqlid'                        then l_ash_grouping := l_ash_grouping + c_sql_id                   ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SQL_ID'                    , w_sql_id                   , ' ');
              when 'child'                        then l_ash_grouping := l_ash_grouping + c_sql_child_number         ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SQL_CHILD_NUMBER'          , w_sql_child_number         , ' ');
              when 'plsql_eoid'                   then l_ash_grouping := l_ash_grouping + c_plsql_entry_object_id    ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_ENTRY_OBJECT_ID'     , w_plsql_entry_object_id    , ' ');
              when 'plsql_esubpid'                then l_ash_grouping := l_ash_grouping + c_plsql_entry_subprogram_id; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_ENTRY_SUBPROGRAM_ID' , w_plsql_entry_subprogram_id, ' ');
              when 'plsql_oid'                    then l_ash_grouping := l_ash_grouping + c_plsql_object_id          ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_OBJECT_ID'           , w_plsql_object_id          , ' ');
              when 'plsql_subpid'                 then l_ash_grouping := l_ash_grouping + c_plsql_subprogram_id      ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('PLSQL_SUBPROGRAM_ID'       , w_plsql_subprogram_id      , ' ');
              when 'mod'                          then l_ash_grouping := l_ash_grouping + c_module                   ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('MODULE'                    , w_module                   , ' ');
              when 'act'                          then l_ash_grouping := l_ash_grouping + c_action                   ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('ACTION'                    , w_action                   , ' ');
              when 'cid'                          then l_ash_grouping := l_ash_grouping + c_client_identifier        ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('CLIENT_IDENTIFIER'         , w_client_identifier        , ' ');
              when 'service'                      then l_ash_grouping := l_ash_grouping + c_service_name             ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('SERVICE_NAME'              , w_service_name             , ' ');
              when 'wait_event'                   then l_ash_grouping := l_ash_grouping + c_event                    ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('EVENT'                     , w_event                    , ' ');
              when 'wait_state'                   then l_ash_grouping := l_ash_grouping + c_state                    ; l_ash_header_line := l_ash_header_line || ' | ' || rpad('STATE'                     , w_state                    , ' ');
          else
              null;
              -- raise_application_error(-20000, 'Invalid ASH column name');
          end case; -- case s.token

      end loop; -- tokenizer

      output(' ');
      output(lpad('-',length(l_ash_header_line),'-'));
      output(l_ash_header_line);
      output(lpad('-',length(l_ash_header_line),'-'));

      -- this is needed for "easy" sorting and group by ops (without any custom stored object types!)
      for i in (
          with /* get_aggregates_from_ash */ raw_records as (
             select column_value rec from table(cast(g_ash as sys.dbms_debug_vc2coll))
          ),
          ash_records as (
             select
                 substr(r.rec, instr(r.rec, '<', 1,  1)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  1)+1), '>')-1) inst_id
               , substr(r.rec, instr(r.rec, '<', 1,  2)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  2)+1), '>')-1) sid
               , substr(r.rec, instr(r.rec, '<', 1,  3)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  3)+1), '>')-1) username
               , substr(r.rec, instr(r.rec, '<', 1,  4)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  4)+1), '>')-1) machine
               , substr(r.rec, instr(r.rec, '<', 1,  5)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  5)+1), '>')-1) terminal
               , substr(r.rec, instr(r.rec, '<', 1,  6)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  6)+1), '>')-1) program
               , substr(r.rec, instr(r.rec, '<', 1,  7)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  7)+1), '>')-1) event
               , substr(r.rec, instr(r.rec, '<', 1,  8)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  8)+1), '>')-1) wait_class
               , substr(r.rec, instr(r.rec, '<', 1,  9)+1, instr (substr(r.rec, instr(r.rec, '<', 1,  9)+1), '>')-1) state
               , substr(r.rec, instr(r.rec, '<', 1, 10)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 10)+1), '>')-1) p1
               , substr(r.rec, instr(r.rec, '<', 1, 11)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 11)+1), '>')-1) p2
               , substr(r.rec, instr(r.rec, '<', 1, 12)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 12)+1), '>')-1) p3
               , substr(r.rec, instr(r.rec, '<', 1, 13)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 13)+1), '>')-1) row_wait_obj#
               , substr(r.rec, instr(r.rec, '<', 1, 14)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 14)+1), '>')-1) row_wait_file#
               , substr(r.rec, instr(r.rec, '<', 1, 15)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 15)+1), '>')-1) row_wait_block#
               , substr(r.rec, instr(r.rec, '<', 1, 16)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 16)+1), '>')-1) row_wait_row#
               , substr(r.rec, instr(r.rec, '<', 1, 17)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 17)+1), '>')-1) blocking_session_status
               , substr(r.rec, instr(r.rec, '<', 1, 18)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 18)+1), '>')-1) blocking_instance
               , substr(r.rec, instr(r.rec, '<', 1, 19)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 19)+1), '>')-1) blocking_session
               , substr(r.rec, instr(r.rec, '<', 1, 20)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 20)+1), '>')-1) sql_hash_value
               , substr(r.rec, instr(r.rec, '<', 1, 21)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 21)+1), '>')-1) sql_id
               , substr(r.rec, instr(r.rec, '<', 1, 22)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 22)+1), '>')-1) sql_child_number
               , substr(r.rec, instr(r.rec, '<', 1, 23)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 23)+1), '>')-1) plsql_entry_object_id
               , substr(r.rec, instr(r.rec, '<', 1, 24)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 24)+1), '>')-1) plsql_entry_subprogram_id
               , substr(r.rec, instr(r.rec, '<', 1, 25)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 25)+1), '>')-1) plsql_object_id
               , substr(r.rec, instr(r.rec, '<', 1, 26)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 26)+1), '>')-1) plsql_subprogram_id
               , substr(r.rec, instr(r.rec, '<', 1, 27)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 27)+1), '>')-1) module
               , substr(r.rec, instr(r.rec, '<', 1, 28)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 28)+1), '>')-1) action
               , substr(r.rec, instr(r.rec, '<', 1, 29)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 29)+1), '>')-1) client_identifier
               , substr(r.rec, instr(r.rec, '<', 1, 30)+1, instr (substr(r.rec, instr(r.rec, '<', 1, 30)+1), '>')-1) service_name
             from
                raw_records r
          )
          select * from (
            select
               decode(bitand(l_ash_grouping, power(2, s_inst_id                       )), 0, chr(0), inst_id                       ) as inst_id
             , decode(bitand(l_ash_grouping, power(2, s_sid                           )), 0, chr(0), sid                           ) as sid
             , decode(bitand(l_ash_grouping, power(2, s_username                      )), 0, chr(0), username                      ) as username
             , decode(bitand(l_ash_grouping, power(2, s_machine                       )), 0, chr(0), machine                       ) as machine
             , decode(bitand(l_ash_grouping, power(2, s_terminal                      )), 0, chr(0), terminal                      ) as terminal
             , decode(bitand(l_ash_grouping, power(2, s_program                       )), 0, chr(0), program                       ) as program
             , decode(bitand(l_ash_grouping, power(2, s_event                         )), 0, chr(0), event                         ) as event
             , decode(bitand(l_ash_grouping, power(2, s_wait_class                    )), 0, chr(0), wait_class                    ) as wait_class
             , decode(bitand(l_ash_grouping, power(2, s_state                         )), 0, chr(0), state                         ) as state
             , decode(bitand(l_ash_grouping, power(2, s_p1                            )), 0, chr(0), p1                            ) as p1
             , decode(bitand(l_ash_grouping, power(2, s_p2                            )), 0, chr(0), p2                            ) as p2
             , decode(bitand(l_ash_grouping, power(2, s_p3                            )), 0, chr(0), p3                            ) as p3
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_obj#                 )), 0, chr(0), row_wait_obj#                 ) as row_wait_obj#
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_file#                )), 0, chr(0), row_wait_file#                ) as row_wait_file#
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_block#               )), 0, chr(0), row_wait_block#               ) as row_wait_block#
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_row#                 )), 0, chr(0), row_wait_row#                 ) as row_wait_row#
             , decode(bitand(l_ash_grouping, power(2, s_blocking_session_status       )), 0, chr(0), blocking_session_status       ) as blocking_session_status
             , decode(bitand(l_ash_grouping, power(2, s_blocking_instance             )), 0, chr(0), blocking_instance             ) as blocking_instance
             , decode(bitand(l_ash_grouping, power(2, s_blocking_session              )), 0, chr(0), blocking_session              ) as blocking_session
             , decode(bitand(l_ash_grouping, power(2, s_sql_hash_value                )), 0, chr(0), sql_hash_value                ) as sql_hash_value
             , decode(bitand(l_ash_grouping, power(2, s_sql_id                        )), 0, chr(0), sql_id                        ) as sql_id
             , decode(bitand(l_ash_grouping, power(2, s_sql_child_number              )), 0, chr(0), sql_child_number              ) as sql_child_number
             , decode(bitand(l_ash_grouping, power(2, s_plsql_entry_object_id         )), 0, chr(0), plsql_entry_object_id         ) as plsql_entry_object_id
             , decode(bitand(l_ash_grouping, power(2, s_plsql_entry_subprogram_id     )), 0, chr(0), plsql_entry_subprogram_id     ) as plsql_entry_subprogram_id
             , decode(bitand(l_ash_grouping, power(2, s_plsql_object_id               )), 0, chr(0), plsql_object_id               ) as plsql_object_id
             , decode(bitand(l_ash_grouping, power(2, s_plsql_subprogram_id           )), 0, chr(0), plsql_subprogram_id           ) as plsql_subprogram_id
             , decode(bitand(l_ash_grouping, power(2, s_module                        )), 0, chr(0), module                        ) as module
             , decode(bitand(l_ash_grouping, power(2, s_action                        )), 0, chr(0), action                        ) as action
             , decode(bitand(l_ash_grouping, power(2, s_client_identifier             )), 0, chr(0), client_identifier             ) as client_identifier
             , decode(bitand(l_ash_grouping, power(2, s_service_name                  )), 0, chr(0), service_name                  ) as service_name
             , count(*)/g_ash_samples_taken average_active_samples
            from
               ash_records a
            group by
               decode(bitand(l_ash_grouping, power(2, s_inst_id                       )), 0, chr(0), inst_id                       ) -- inst_id
             , decode(bitand(l_ash_grouping, power(2, s_sid                           )), 0, chr(0), sid                           ) -- sid
             , decode(bitand(l_ash_grouping, power(2, s_username                      )), 0, chr(0), username                      ) -- username
             , decode(bitand(l_ash_grouping, power(2, s_machine                       )), 0, chr(0), machine                       ) -- machine
             , decode(bitand(l_ash_grouping, power(2, s_terminal                      )), 0, chr(0), terminal                      ) -- terminal
             , decode(bitand(l_ash_grouping, power(2, s_program                       )), 0, chr(0), program                       ) -- program
             , decode(bitand(l_ash_grouping, power(2, s_event                         )), 0, chr(0), event                         ) -- event
             , decode(bitand(l_ash_grouping, power(2, s_wait_class                    )), 0, chr(0), wait_class                    ) -- wait_class
             , decode(bitand(l_ash_grouping, power(2, s_state                         )), 0, chr(0), state                         ) -- state
             , decode(bitand(l_ash_grouping, power(2, s_p1                            )), 0, chr(0), p1                            ) -- p1
             , decode(bitand(l_ash_grouping, power(2, s_p2                            )), 0, chr(0), p2                            ) -- p2
             , decode(bitand(l_ash_grouping, power(2, s_p3                            )), 0, chr(0), p3                            ) -- p3
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_obj#                 )), 0, chr(0), row_wait_obj#                 ) -- row_wait_obj#
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_file#                )), 0, chr(0), row_wait_file#                ) -- row_wait_file#
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_block#               )), 0, chr(0), row_wait_block#               ) -- row_wait_block#
             , decode(bitand(l_ash_grouping, power(2, s_row_wait_row#                 )), 0, chr(0), row_wait_row#                 ) -- row_wait_row#
             , decode(bitand(l_ash_grouping, power(2, s_blocking_session_status       )), 0, chr(0), blocking_session_status       ) -- blocking_session_status
             , decode(bitand(l_ash_grouping, power(2, s_blocking_instance             )), 0, chr(0), blocking_instance             ) -- blocking_instance
             , decode(bitand(l_ash_grouping, power(2, s_blocking_session              )), 0, chr(0), blocking_session              ) -- blocking_session
             , decode(bitand(l_ash_grouping, power(2, s_sql_hash_value                )), 0, chr(0), sql_hash_value                ) -- sql_hash_value
             , decode(bitand(l_ash_grouping, power(2, s_sql_id                        )), 0, chr(0), sql_id                        ) -- sql_id
             , decode(bitand(l_ash_grouping, power(2, s_sql_child_number              )), 0, chr(0), sql_child_number              ) -- sql_child_number
             , decode(bitand(l_ash_grouping, power(2, s_plsql_entry_object_id         )), 0, chr(0), plsql_entry_object_id         ) -- plsql_entry_object_id
             , decode(bitand(l_ash_grouping, power(2, s_plsql_entry_subprogram_id     )), 0, chr(0), plsql_entry_subprogram_id     ) -- plsql_entry_subprogram_id
             , decode(bitand(l_ash_grouping, power(2, s_plsql_object_id               )), 0, chr(0), plsql_object_id               ) -- plsql_object_id
             , decode(bitand(l_ash_grouping, power(2, s_plsql_subprogram_id           )), 0, chr(0), plsql_subprogram_id           ) -- plsql_subprogram_id
             , decode(bitand(l_ash_grouping, power(2, s_module                        )), 0, chr(0), module                        ) -- module
             , decode(bitand(l_ash_grouping, power(2, s_action                        )), 0, chr(0), action                        ) -- action
             , decode(bitand(l_ash_grouping, power(2, s_client_identifier             )), 0, chr(0), client_identifier             ) -- client_identifier
             , decode(bitand(l_ash_grouping, power(2, s_service_name                  )), 0, chr(0), service_name                  ) -- service_name
           order by
              count(*)/g_ash_samples_taken desc
          )
          where rownum <= p_topn
      ) loop

          l_output_line := '';

          o_inst_id                     := CASE WHEN i.inst_id                        = chr(0) THEN null ELSE nvl(i.inst_id                       , ' ') END;
          o_sid                         := CASE WHEN i.sid                            = chr(0) THEN null ELSE nvl(i.sid                           , ' ') END;
          o_username                    := CASE WHEN i.username                       = chr(0) THEN null ELSE nvl(i.username                      , ' ') END;
          o_machine                     := CASE WHEN i.machine                        = chr(0) THEN null ELSE nvl(i.machine                       , ' ') END;
          o_terminal                    := CASE WHEN i.terminal                       = chr(0) THEN null ELSE nvl(i.terminal                      , ' ') END;
          o_program                     := CASE WHEN i.program                        = chr(0) THEN null ELSE nvl(i.program                       , ' ') END;
          o_event                       := CASE WHEN i.event                          = chr(0) THEN null ELSE nvl(i.event                         , ' ') END;
          o_wait_class                  := CASE WHEN i.wait_class                     = chr(0) THEN null ELSE nvl(i.wait_class                    , ' ') END;
          o_state                       := CASE WHEN i.state                          = chr(0) THEN null ELSE nvl(i.state                         , ' ') END;
          o_p1                          := CASE WHEN i.p1                             = chr(0) THEN null ELSE nvl(i.p1                            , ' ') END;
          o_p2                          := CASE WHEN i.p2                             = chr(0) THEN null ELSE nvl(i.p2                            , ' ') END;
          o_p3                          := CASE WHEN i.p3                             = chr(0) THEN null ELSE nvl(i.p3                            , ' ') END;
          o_row_wait_obj#               := CASE WHEN i.row_wait_obj#                  = chr(0) THEN null ELSE nvl(i.row_wait_obj#                 , ' ') END;
          o_row_wait_file#              := CASE WHEN i.row_wait_file#                 = chr(0) THEN null ELSE nvl(i.row_wait_file#                , ' ') END;
          o_row_wait_block#             := CASE WHEN i.row_wait_block#                = chr(0) THEN null ELSE nvl(i.row_wait_block#               , ' ') END;
          o_row_wait_row#               := CASE WHEN i.row_wait_row#                  = chr(0) THEN null ELSE nvl(i.row_wait_row#                 , ' ') END;
          o_blocking_session_status     := CASE WHEN i.blocking_session_status        = chr(0) THEN null ELSE nvl(i.blocking_session_status       , ' ') END;
          o_blocking_instance           := CASE WHEN i.blocking_instance              = chr(0) THEN null ELSE nvl(i.blocking_instance             , ' ') END;
          o_blocking_session            := CASE WHEN i.blocking_session               = chr(0) THEN null ELSE nvl(i.blocking_session              , ' ') END;
          o_sql_hash_value              := CASE WHEN i.sql_hash_value                 = chr(0) THEN null ELSE nvl(i.sql_hash_value                , ' ') END;
          o_sql_id                      := CASE WHEN i.sql_id                         = chr(0) THEN null ELSE nvl(i.sql_id                        , ' ') END;
          o_sql_child_number            := CASE WHEN i.sql_child_number               = chr(0) THEN null ELSE nvl(i.sql_child_number              , ' ') END;
          o_plsql_entry_object_id       := CASE WHEN i.plsql_entry_object_id          = chr(0) THEN null ELSE nvl(i.plsql_entry_object_id         , ' ') END;
          o_plsql_entry_subprogram_id   := CASE WHEN i.plsql_entry_subprogram_id      = chr(0) THEN null ELSE nvl(i.plsql_entry_subprogram_id     , ' ') END;
          o_plsql_object_id             := CASE WHEN i.plsql_object_id                = chr(0) THEN null ELSE nvl(i.plsql_object_id               , ' ') END;
          o_plsql_subprogram_id         := CASE WHEN i.plsql_subprogram_id            = chr(0) THEN null ELSE nvl(i.plsql_subprogram_id           , ' ') END;
          o_module                      := CASE WHEN i.module                         = chr(0) THEN null ELSE nvl(i.module                        , ' ') END;
          o_action                      := CASE WHEN i.action                         = chr(0) THEN null ELSE nvl(i.action                        , ' ') END;
          o_client_identifier           := CASE WHEN i.client_identifier              = chr(0) THEN null ELSE nvl(i.client_identifier             , ' ') END;
          o_service_name                := CASE WHEN i.service_name                   = chr(0) THEN null ELSE nvl(i.service_name                  , ' ') END;


          -- print the activity % as the first column
          l_output_line := lpad(to_char(round(i.average_active_samples*100))||'%', w_activity_pct, ' ');

          -- loop through ash columns to find what to print and in which order
          for s in (
              SELECT LEVEL
                     , SUBSTR
                       ( TOKEN
                        , DECODE(LEVEL, 1, 1, INSTR(TOKEN, DELIMITER, 1, LEVEL-1)+1)
                        , INSTR(TOKEN, DELIMITER, 1, LEVEL) -
                       DECODE(LEVEL, 1, 1, INSTR(TOKEN, DELIMITER, 1, LEVEL-1)+1)
                       ) TOKEN
              FROM ( SELECT REPLACE(  LOWER(p_ash_columns)  ,' ','')||'+' AS TOKEN
                     , '+'                        AS DELIMITER
                     FROM DUAL
              )
              CONNECT BY
                  INSTR(TOKEN, DELIMITER, 1, LEVEL)>0
              ORDER BY
                  LEVEL ASC
          ) loop
              l_output_line := l_output_line || ' | ' ||
                  case s.token
                      -- actual column names in gv\$session
                      when 'inst_id'                      then lpad(o_inst_id                   , w_inst_id                  , ' ')
                      when 'sid'                          then lpad(o_sid                       , w_sid                      , ' ')
                      when 'username'                     then rpad(o_username                  , w_username                 , ' ')
                      when 'machine'                      then rpad(o_machine                   , w_machine                  , ' ')
                      when 'terminal'                     then rpad(o_terminal                  , w_terminal                 , ' ')
                      when 'program'                      then rpad(o_program                   , w_program                  , ' ')
                      when 'event'                        then rpad(o_event                     , w_event                    , ' ')
                      when 'wait_class'                   then rpad(o_wait_class                , w_wait_class               , ' ')
                      when 'state'                        then rpad(o_state                     , w_state                    , ' ')
                      when 'p1'                           then rpad(o_p1                        , w_p1                       , ' ')
                      when 'p2'                           then rpad(o_p2                        , w_p2                       , ' ')
                      when 'p3'                           then rpad(o_p3                        , w_p3                       , ' ')
                      when 'row_wait_obj#'                then rpad(o_row_wait_obj#             , w_row_wait_obj#            , ' ')
                      when 'row_wait_file#'               then rpad(o_row_wait_file#            , w_row_wait_file#           , ' ')
                      when 'row_wait_block#'              then rpad(o_row_wait_block#           , w_row_wait_block#          , ' ')
                      when 'row_wait_row#'                then rpad(o_row_wait_row#             , w_row_wait_row#            , ' ')
                      when 'blocking_session_status'      then rpad(o_blocking_session_status   , w_blocking_session_status  , ' ')
                      when 'blocking_instance'            then rpad(o_blocking_instance         , w_blocking_instance        , ' ')
                      when 'blocking_session'             then rpad(o_blocking_session          , w_blocking_session         , ' ')
                      when 'sql_hash_value'               then rpad(o_sql_hash_value            , w_sql_hash_value           , ' ')
                      when 'sql_id'                       then rpad(o_sql_id                    , w_sql_id                   , ' ')
                      when 'sql_child_number'             then rpad(o_sql_child_number          , w_sql_child_number         , ' ')
                      when 'plsql_entry_object_id'        then rpad(o_plsql_entry_object_id     , w_plsql_entry_object_id    , ' ')
                      when 'plsql_entry_subprogram_id'    then rpad(o_plsql_entry_subprogram_id , w_plsql_entry_subprogram_id, ' ')
                      when 'plsql_object_id'              then rpad(o_plsql_object_id           , w_plsql_object_id          , ' ')
                      when 'plsql_subprogram_id'          then rpad(o_plsql_subprogram_id       , w_plsql_subprogram_id      , ' ')
                      when 'module'                       then rpad(o_module                    , w_module                   , ' ')
                      when 'action'                       then rpad(o_action                    , w_action                   , ' ')
                      when 'client_identifier'            then rpad(o_client_identifier         , w_client_identifier        , ' ')
                      when 'service_name'                 then rpad(o_service_name              , w_service_name             , ' ')
                      -- aliases for convenience (only either real name or alias should be used together at the same time)
                      when 'user'                         then rpad(o_username                  , w_username                 , ' ')
                      when 'obj'                          then rpad(o_row_wait_obj#             , w_row_wait_obj#            , ' ')
                      when 'file'                         then rpad(o_row_wait_file#            , w_row_wait_file#           , ' ')
                      when 'block'                        then rpad(o_row_wait_block#           , w_row_wait_block#          , ' ')
                      when 'row'                          then rpad(o_row_wait_row#             , w_row_wait_row#            , ' ')
                      when 'bss'                          then rpad(o_blocking_session_status   , w_blocking_session_status  , ' ')
                      when 'bsi'                          then rpad(o_blocking_instance         , w_blocking_instance        , ' ')
                      when 'bs'                           then rpad(o_blocking_session          , w_blocking_session         , ' ')
                      when 'sql'                          then rpad(o_sql_hash_value            , w_sql_hash_value           , ' ')
                      when 'sqlid'                        then rpad(o_sql_id                    , w_sql_id                   , ' ')
                      when 'child'                        then rpad(o_sql_child_number          , w_sql_child_number         , ' ')
                      when 'plsql_eoid'                   then rpad(o_plsql_entry_object_id     , w_plsql_entry_object_id    , ' ')
                      when 'plsql_esubpid'                then rpad(o_plsql_entry_subprogram_id , w_plsql_entry_subprogram_id, ' ')
                      when 'plsql_oid'                    then rpad(o_plsql_object_id           , w_plsql_object_id          , ' ')
                      when 'plsql_subpid'                 then rpad(o_plsql_subprogram_id       , w_plsql_subprogram_id      , ' ')
                      when 'mod'                          then rpad(o_module                    , w_module                   , ' ')
                      when 'act'                          then rpad(o_action                    , w_action                   , ' ')
                      when 'cid'                          then rpad(o_client_identifier         , w_client_identifier        , ' ')
                      when 'service'                      then rpad(o_service_name              , w_service_name             , ' ')
                      when 'wait_event'                   then rpad(o_event                     , w_event                    , ' ')
                      when 'wait_state'                   then rpad(o_state                     , w_state                    , ' ')
                  else
                      ''
                  end; -- case s.token

          end loop; -- ash parameter tokenizer

          output(l_output_line);

      end loop; -- grouped ash samples

  end out_ash;


-- and it begins!!!
begin

    -- get snappers own sid into g_mysid
    select sid into g_mysid from v\$mystat where rownum = 1;

    pagesize := nvl( getopt('&snapper_options', 'pagesize=' ), pagesize);
    --output ( 'Pagesize='||pagesize );

    lv_ash   := getopt('&snapper_options', 'ash');
    lv_stats := getopt('&snapper_options', 'stat');

    if lv_ash is not null then gather_ash := 1; end if;
    if lv_stats is not null then gather_stats := 1; end if;

    --output('all='||case when getopt('&snapper_options', 'all') = chr(0) then 'chr(0)' when getopt('&snapper_options', 'all') is null then 'null' else (getopt('&snapper_options','all')) end);
    -- some additional default value logic
    if getopt('&snapper_options', 'all') is not null then
        --output('setting stats to all due to option = all');
        gather_stats := 1;
        gather_ash   := 1;
    else
        if (lv_ash is null and lv_stats is null) then
            gather_stats := 0;
            gather_ash   := 1;
        end if;
    end if;

    -- determine which performance counters and stats to collect
    lv_gather := case nvl( lower(getopt ('&snapper_options', 'gather=')), 'stw')
                    when 'all'  then 'stw'
                    else nvl( lower(getopt ('&snapper_options', 'gather=')), 'stw')
                 end;

    --lv_gather:=getopt ('&snapper_options', 'gather=');
    --output('lv_gather='||lv_gather);

    g_snap_begin := lower(getopt('&snapper_options', 'begin' ));
    g_snap_end   := lower(getopt('&snapper_options', 'end' ));
    --output('g_snap_begin = '||g_snap_begin);
    --output('g_snap_end = '||g_snap_end);

    if pagesize > 0 then
        output(' ');
        output(' ');
    end if;

    -- initialize statistic and event name array
    -- fetch statistic names with their adjusted IDs
    select /* get_stat_names */ *
    bulk collect into sn_tmp
    from (
                                 select 'STAT' stype, statistic# - pls_adjust statistic#, name
                                 from v\$statname
                                 where (lv_gather like '%s%' or lv_gather like '%a%')
                                 --
                                 union all
                                 select 'WAIT',
                                        event# + (select count(*) from v\$statname) + 1 - pls_adjust, name
                                 from v\$event_name
                                 where (lv_gather like '%w%' or lv_gather like '%a%')
                                 --
                                 union all
                                 select 'TIME' stype, stat_id - pls_adjust statistic#, stat_name name
                                 from gv\$sys_time_model
                                 where (lv_gather like '%t%' or lv_gather like '%a%')
                                 --
                                 union all
                                 select 'LATG',
                                       l.latch# +
                                           (select count(*) from v\$statname) +
                                           (select count(*) from v\$event_name) +
                                           1 - pls_adjust statistic#,
                                       name
                                 from gv\$latch l
                                 where (lv_gather like '%l%' or lv_gather like '%a%')
                                 --
            &_IF_X_ACCESSIBLE    union all
            &_IF_X_ACCESSIBLE    select 'BUFG',
            &_IF_X_ACCESSIBLE          indx +
            &_IF_X_ACCESSIBLE              (select count(*) from v\$statname) +
            &_IF_X_ACCESSIBLE              (select count(*) from v\$event_name) +
            &_IF_X_ACCESSIBLE              (select count(*) from gv\$latch) +
            &_IF_X_ACCESSIBLE              1 - pls_adjust statistic#,
            &_IF_X_ACCESSIBLE         kcbwhdes name
            &_IF_X_ACCESSIBLE    from x\$kcbwh
            &_IF_X_ACCESSIBLE    where   (lv_gather like '%b%' or lv_gather like '%a%')
                                 --
                                 union all
                                 select 'ENQG',
                                       ascii(substr(e.eq_type,1,1))*256 + ascii(substr(e.eq_type,2,1)) +
                                           (select count(*) from v\$statname) +
                                           (select count(*) from v\$event_name) +
                                           (select count(*) from gv\$latch) +
            &_IF_X_ACCESSIBLE              (select count(*) from x\$kcbwh) +
                                           1 - pls_adjust statistic#,
                                           eq_type
                                 from (
                                       select es.eq_type
                                              ||' - '||lt.name
                                              eq_type,
                                              total_req#
                                       from
                                              gv\$enqueue_stat es
                                            , gv\$lock_type lt
                                       where es.eq_type = lt.type
                                 ) e
                                 where (lv_gather like '%e%' or lv_gather like '%a%')
    ) snapper_statnames
    order by stype, statistic#;

    -- store these into an index_by array organized by statistic# for fast lookup
    for i in 1..sn_tmp.count loop
        sn(sn_tmp(i).statistic#) := sn_tmp(i);
        sn_reverse(sn_tmp(i).stype||','||sn_tmp(i).name) := sn_tmp(i);
    end loop;


    -- main sampling loop
    for c in 1..&snapper_count loop

        -- sesstat and other performance counter sampling
        if gather_stats = 1 then

            -- print header if required
            gv_header_string :=
                      CASE WHEN output_header      = 1 THEN 'HEAD,'                        END
                   || CASE WHEN output_inst        = 1 THEN ' INST,'                       END
                   || CASE WHEN output_sid         = 1 THEN '    SID,'                     END
                   || CASE WHEN output_inst_sid    = 1 THEN ' SID @INST,'                  END
                   || CASE WHEN output_username    = 1 THEN ' USERNAME  ,'                 END
                   || CASE WHEN output_time        = 1 THEN ' SNAPSHOT START   ,'          END
                   || CASE WHEN output_seconds     = 1 THEN '  SECONDS,'                   END
                   || CASE WHEN output_stype       = 1 THEN ' TYPE,'                       END
                   || CASE WHEN output_sname       = 1 THEN rpad(' STATISTIC',59,' ')||',' END
                   || CASE WHEN output_delta       = 1 THEN '         DELTA,'              END
                   || CASE WHEN output_delta_s     = 1 THEN '  DELTA/SEC,'                 END
                   || CASE WHEN output_hdelta      = 1 THEN '     HDELTA,'                 END
                   || CASE WHEN output_hdelta_s    = 1 THEN ' HDELTA/SEC,'                 END
                   || CASE WHEN output_percent     = 1 THEN '    %TIME,'                   END
                   || CASE WHEN output_pcthist     = 1 THEN ' GRAPH       ,'               END
                   || CASE WHEN output_eventcnt    = 1 THEN ' NUM_WAITS,'                  END
                   || CASE WHEN output_eventcnt_s  = 1 THEN '  WAITS/SEC,'                 END
                   || CASE WHEN output_eventavg    = 1 THEN '   AVERAGES                                    ' END
            ;


            if g_snap_begin is null then
                if pagesize > 0 and mod(c-1, pagesize) = 0 then
                    output(rpad('-',length(gv_header_string),'-'));
                    output(gv_header_string);
                    output(rpad('-',length(gv_header_string),'-'));
                else
                    if pagesize = -1 and c = 1 then
                        output(gv_header_string);
                    end if;
                end if;
            else
                output('Taking BEGIN sample ...');
            end if;

            -- TODO raise an error if both begin and end are used together
            -- TODO conditionally comment out the refcursor use unless begin and end is used

            -- manual before/after snapshots (snapper v4)
            if g_snap_begin is not null or g_snap_end is not null then
                if g_snap_begin is not null then
                    get_sessions;
                    snap(d1,s1,l1,g_snap1);
&_MANUAL_SNAPSHOT   open :snapper for select column_value rec from table(g_snap1); -- if you see this error then run: "VAR SNAPPER REFCURSOR" first!
                    exit;
                end if;

                if g_snap_end is not null then
&_MANUAL_SNAPSHOT   fetch :snapper bulk collect into g_snap1; -- You should run snapper with BEGIN option first!
                    -- procedure snap_from_stats_string (p_string_stats in sys.dbms_debug_vc2coll, p_snapdate out date, p_stats out stab, l_stats out ltab)
                    snap_from_stats_string(g_snap1, d1, s1, l1);
                end if;
            else -- normal interval sampling
                if c = 1 then
                    get_sessions;
                    snap(d1,s1,l1,g_snap1);
                else
                    get_sessions;
                    d1 := d2;
                    s1 := s2;
                    g_snap1 := g_snap2;
                end if; -- c = 1
            end if;

        end if; -- gather_stats = 1



        -- ASH style sampling
&_USE_DBMS_LOCK ash_date1 := sysdate;
&_USE_DBMS_LOCK if gather_ash = 1 then
&_USE_DBMS_LOCK     while sysdate < (ash_date1 + (&snapper_sleep/86400)) loop
&_USE_DBMS_LOCK         -- get active session records from g_sessions
&_USE_DBMS_LOCK         get_sessions;
&_USE_DBMS_LOCK         extract_ash();
&_USE_DBMS_LOCK         -- sleep timeout backoff depending on the duration sampled (for up to 10 seconds total sampling time will get max 100 Hz sampling)
&_USE_DBMS_LOCK         -- for longer duration sampling the algorithm will back off and for long durations (over 100 sec) the sampling rate will stabilize
&_USE_DBMS_LOCK         -- at 1Hz
&_USE_DBMS_LOCK         dbms_lock.sleep( greatest(0.1,(least(1,&snapper_sleep*&snapper_count/100))) );
&_USE_DBMS_LOCK     end loop;
&_USE_DBMS_LOCK else
&_USE_DBMS_LOCK     dbms_lock.sleep( ((ash_date1+(&snapper_sleep/86400)) - sysdate)*86400 );
&_USE_DBMS_LOCK     null;
&_USE_DBMS_LOCK end if;
&_USE_DBMS_LOCK ash_date2 := sysdate;

        -- sesstat new sample and delta calculation
        if gather_stats = 1 then

            get_sessions;
            snap(d2,s2,l2,g_snap2);
            changed_values := 0;
            missing_values_s1 := 0;
            missing_values_s2 := 0;

            disappeared_sid := 0;

            i :=1; -- iteration counter (for debugging)
            a :=1; -- s1 array index
            b :=1; -- s2 array index

            if s2.count > 0 then lv_curr_sid := s2(b).sid; end if;

            while ( a <= s1.count and b <= s2.count ) loop

                if lv_curr_sid != 0 and lv_curr_sid != s2(b).sid then
                    if pagesize > 0 and mod(c-1, pagesize) = 0 then
                        -- if filtering specific stats, assuming that it's better to not leave spaces between every session data

                        if getopt('&snapper_options', 'sinclude=')||getopt('&snapper_options', 'tinclude=' )||getopt('&snapper_options', 'winclude=' ) is null then
                            output(' ');
                        end if;
                    end if;
                    lv_curr_sid := s2(b).sid;
                end if;

                delta := 0; -- don't print

                case
                    when s1(a).sid = s2(b).sid then

                        case
                            when s1(a).statistic# = s2(b).statistic# then

                                delta := s2(b).value - s1(a).value;
                                evcnt := s2(b).event_count - s1(a).event_count;

                                if delta != 0 then fout(); end if;

                                a := a + 1;
                                b := b + 1;

                            when s1(a).statistic# > s2(b).statistic# then

                                delta := s2(b).value;
                                evcnt := s2(b).event_count;
                                if delta != 0 then fout(); end if;

                                b := b + 1;

                            when s1(a).statistic# < s2(b).statistic# then

                                output('ERROR, s1(a).statistic# < s2(b).statistic#, a='||to_char(a)||' b='||to_char(b)||' s1.count='||s1.count||' s2.count='||s2.count||' s2.count='||s2.count);
                                a := a + 1;
                                b := b + 1;

                        else
                                output('ERROR, s1(a).statistic# ? s2(b).statistic#, a='||to_char(a)||' b='||to_char(b)||' s1.count='||s1.count||' s2.count='||s2.count||' s2.count='||s2.count);
                                a := a + 1;
                                b := b + 1;

                        end case; -- s1(a).statistic# ... s2(b).statistic#

                    when s1(a).sid > s2(b).sid then

                        delta := s2(b).value;
                        evcnt := s2(b).event_count;
                        if delta != 0 then fout(); end if;

                        b := b + 1;

                    when s1(a).sid < s2(b).sid then

                        if disappeared_sid != s1(a).sid then
                            output('WARN, Session has disappeared since previous snapshot, ignoring SID='||to_char(s1(a).sid)||' debug(a='||to_char(a)||' b='||to_char(b)||' s1.count='||s1.count||' s2.count='||s2.count||' s2.count='||s2.count||')');
                        end if;
                        disappeared_sid := s1(a).sid;
                        a := a + 1;

                    else
                        output('ERROR, Should not be here, SID='||to_char(s2(b).sid)||' a='||to_char(a)||' b='||to_char(b)||' s1.count='||s1.count||' s2.count='||s2.count||' s2.count='||s2.count);

                end case; -- s1(a).sid ... s2(b).sid

                i:=i+1;

                if  delta != 0 then

                    changed_values := changed_values + 1;

                end if; -- delta != 0

            end loop; -- while ( a <= s1.count and b <= s2.count )

            if pagesize > 0 and changed_values > 0 then
                output(' ');
                output('--  End of Stats snap '||to_char(c)||', end='||to_char(d2, 'YYYY-MM-DD HH24:MI:SS')||', seconds='||round(get_seconds(d2-d1), 1));
            end if;

            output(' ');

        end if; -- gather_stats = 1

        if gather_ash = 1 then

            -- get ASH sample grouping details
            g_ash_columns  := nvl( getopt('&snapper_options', 'ash='  ), g_ash_columns  );

            -- optional additional ASH groupings
            g_ash_columns1 := case when getopt('&snapper_options', 'ash1' ) is null then null when getopt('&snapper_options', 'ash1' ) = chr(0) then g_ash_columns1 else getopt('&snapper_options', 'ash1=' ) end;
            g_ash_columns2 := case when getopt('&snapper_options', 'ash2' ) is null then null when getopt('&snapper_options', 'ash2' ) = chr(0) then g_ash_columns2 else getopt('&snapper_options', 'ash2=' ) end;
            g_ash_columns3 := case when getopt('&snapper_options', 'ash3' ) is null then null when getopt('&snapper_options', 'ash3' ) = chr(0) then g_ash_columns3 else getopt('&snapper_options', 'ash3=' ) end;

            -- group ASH records and print report
            out_ash( g_ash_columns, 50 );
            -- group and print optional ASH reports
            if g_ash_columns1 is not null then out_ash( g_ash_columns1, 10 ); end if;
            if g_ash_columns2 is not null then out_ash( g_ash_columns2, 10 ); end if;
            if g_ash_columns3 is not null then out_ash( g_ash_columns3, 10 ); end if;


            if pagesize > 0 then
                output('--------------------------------------------------------------------------------------------------------------------------------------------------');
                output(' ');
            end if;

            reset_ash();

        end if; -- gather_ash = 1

    end loop; -- for c in 1..snapper_count

end;
/

undefine snapper_oraversion
undefine snapper_sleep
undefine snapper_count
undefine snapper_sid
undefine ssid_begin
undefine _IF_ORA11_OR_HIGHER
undefine _IF_LOWER_THAN_ORA11
undefine _NO_BLK_INST
undefine _YES_BLK_INST
undefine _NO_PLSQL_OBJ_ID
undefine _YES_PLSQL_OBJ_ID
undefine _IF_DBMS_SYSTEM_ACCESSIBLE
undefine _IF_X_ACCESSIBLE
undefine _MANUAL_SNAPSHOT
undefine _USE_DBMS_LOCK
col snapper_ora11higher clear
col snapper_ora11lower  clear
col dbms_system_accessible clear
set serveroutput off

prompt Start From $2 last $dur mintutes dba_hist_active_sess_history
prompt ON CPU User I/O Network Commit Application Concurrency Cluster Configuration Administrative System I/O Scheduler Queueing Other Others for Wait_class%
prompt ======================
set linesize 300 pages 50
col MACHINE for a25
col sql_text for a12
col "AAS" for 999
col sql_id for a13
col "Active%" for a7
col Sessions for 999
col COMMAND for a12
col "Wait_class%" for a75

with tmp as
    (select 1 value,
	a.inst_id as instance_id,
	a.SESSION_ID || ',' || a.SESSION_SERIAL# || '@'|| a.inst_id SESSION_ID,
    round((cast(a.sample_time as date)-a.sql_exec_start)*24*3600) SQL_ELAPSED_TIME,
	(select username from dba_users u where u.user_id = a.user_id) username,
	a.machine,
	a.program,
	--status,
	case a.SQL_OPCODE
	when 1 then 'CREATE TABLE'
	when 2 then 'INSERT'
	when 3 then 'SELECT'
	when 6 then 'UPDATE'
	when 7 then 'DELETE'
	when 9 then 'CREATE INDEX'
	when 11 then 'ALTER INDEX'
	when 15 then 'ALTER INDEX' else 'Others' end command,
	case when a.SQL_ID is null then 'Null' when a.SQL_ID is not null then a.sql_id end as SQL_ID,
	a.SQL_PLAN_HASH_VALUE,
	nvl(a.event, 'ON CPU') event,
	nvl(a.wait_class, 'ON CPU') wait_class,
	a.module,
	a.action,
    case when top_level_sql_id <> sql_id then top_level_sql_id
         when top_level_sql_id = sql_id then null end as top_level_sql_id,
	(select name from V\$ACTIVE_SERVICES s where s.NAME_HASH = a.SERVICE_HASH) SERVICE_NAME,
(select sql_text from gv\$sql s where s.sql_id = a.sql_id and rownum = 1) sql_text
   from gv\$active_session_history a
where a.SAMPLE_TIME between to_date('$2'||'00','yyyy/mm/dd hh24:mi:ss') and to_date('$2'||'59','yyyy/mm/dd hh24:mi:ss')+$dur/24/60)
select x.* from (
SELECT
sql_id,
lpad(round(100.0 * COUNT(*) / (select count(*) from gv\$active_session_history a where a.SAMPLE_TIME between to_date('$2'||'00','yyyy/mm/dd hh24:mi:ss')
                          and to_date('$2'||'59','yyyy/mm/dd hh24:mi:ss')+$dur/24/60) , 2 ) || '%', 6,' ') as "Active%",
CAST (round( 10.0 * COUNT(*) / (select count(*) from gv\$active_session_history a where a.SAMPLE_TIME between to_date('$2'||'00','yyyy/mm/dd hh24:mi:ss')
                          and to_date('$2'||'59','yyyy/mm/dd hh24:mi:ss')+$dur/24/60) , 2 ) AS REAL ) as "AAS",
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'ON CPU' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'User I/O' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Network' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Commit' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Application' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Concurrency' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Cluster' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Configuration' then 1 else 0 end)/count(*)) || '%',5,' ')||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Administrative' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'System I/O' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Scheduler' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Queueing' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS = 'Other' then 1 else 0 end)/count(*)) || '%',5,' ') ||
lpad(ROUND(100.0 * sum(case when WAIT_CLASS not in ('ON CPU','Other','Application','Configuration','Cluster','Administrative','Concurrency','Commit','Network','User I/O','System I/O','Scheduler','Queueing') then 1 else 0 end)/count(*)) || '%',5,' ')
as "Wait_class%",
-- substr(max(sql_text),0,10) as sql_text,
max(command) as command,
max(machine) as machine,
max(top_level_sql_id) as procedure_sql_id
FROM tmp GROUP BY sql_id ORDER BY COUNT (*) DESC
) x where rownum < 20;

prompt Which Object Caused The Library Cache Wait
col object_name for a30
col sid_and_serial# for a20
col event for a25
col username for a16
select ses.username,
       lob.KGLNAOBJ object_name,
       decode(lob.kglobtyp, 0, 'NEXT OBJECT', 1, 'INDEX', 2, 'TABLE', 3, 'CLUSTER',
                      4, 'VIEW', 5, 'SYNONYM', 6, 'SEQUENCE',
                      7, 'PROCEDURE', 8, 'FUNCTION', 9, 'PACKAGE',
                      11, 'PACKAGE BODY', 12, 'TRIGGER',
                      13, 'TYPE', 14, 'TYPE BODY',
                      19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
                      22, 'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',
                      28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30, 'JAVA RESOURCE',
                      32, 'INDEXTYPE', 33, 'OPERATOR',
                      34, 'TABLE SUBPARTITION', 35, 'INDEX SUBPARTITION',
                      40, 'LOB PARTITION', 41, 'LOB SUBPARTITION',
                      42, 'MATERIALIZED VIEW',
                      43, 'DIMENSION',
                      44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
                      48, 'CONSUMER GROUP',
                      51, 'SUBSCRIPTION', 52, 'LOCATION',
                      55, 'XML SCHEMA', 56, 'JAVA DATA',
                      57, 'SECURITY PROFILE', 59, 'RULE',
                      62, 'EVALUATION CONTEXT',
                     'UNDEFINED') object_type,
       ses.sid || ',' ||ses.serial# as "sid_and_serial#",
       pn.KGLPNMOD lock_mode_held,
       pn.KGLPNREQ lock_mode_requested,
       vsw.event
  FROM
       x\$kglpn pn,
       v\$session ses,
       x\$kglob lob,
       v\$session_wait vsw
  WHERE
   pn.KGLPNUSE = ses.saddr and
   pn.KGLPNHDL = lob.KGLHDADR
   and lob.kglhdadr = vsw.p1raw
  --and vsw.event like 'library cache%'
order by object_name, lock_mode_held desc
/
    $ECHO
    spool off
!
echo "instance_number=$INST"
echo "snapper group by sql_id,event ,from $btime, last $dur ,top 20 sql with event"
echo "./ora snapper <begin_time> <duration> [30]"
  exit 0
fi
################################################################################
if [ "$1" = "top_event" -o "$1" = "batch_event" ]; then

    if [ "$2" = ""  -o  "$3" = "" ]; then
      #echo "ora iostat <bid> <eid> "
      #exit 1
      bid="(select max(snap_id)-48 from dba_hist_snapshot)"
      eid="(select max(snap_id)    from dba_hist_snapshot)"
    else
       bid=$2
       eid=$3
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 300 pagesize 8
    col r1_event format a15 trunc
    col r2_event format a15 trunc
    col r3_event format a15 trunc
    col r4_event format a15 trunc
    col r5_event format a15 trunc
    col event format a30 trunc
    col inst_id format 9999
    col wait_class format a15
    col SNAP_END_TIME format a20
    --break on eid
    break on snap_end_time
    set trimspool on
    spool ora_batch_event_${INST}_$filedate.log
    with tmp_res as
    (select v1.instance_number as inst_id,--v1.begin_snap_id,
            v1.end_snap_id-1 as bid
           ,v2.snap_end_time
           ,event,wtfg as waits
           ,round(tmfg/1e6) as time_s
           ,round(wt_avg/1000,1) as wt_avg_ms
           ,wcls as wait_class
           ,round(v2.db_time/1e6) as db_time_s
           ,round(v1.tmfg/v2.db_time*100,1) as percent
           ,row_number() over (partition by v1.instance_number, v1.begin_snap_id,v1.end_snap_id order by v1.tmfg/v2.db_time desc) as rn
    from
    (--v1 begin:
        --other top 4 events
        select instance_number,begin_snap_id,end_snap_id,event,wtfg,tmfg,round(tmfg/wtfg) as wt_avg,wcls
        from
        (select  a.*,row_number() over (partition by instance_number,begin_snap_id,end_snap_id order by tmfg desc) as rn
         from
         (select e.instance_number,e.snap_id-1 as begin_snap_id,e.snap_id as end_snap_id,
                    e.event_name as event,
                   case when e.total_waits_fg is not null
                          then e.total_waits_fg -
                               nvl(lag(e.total_waits_fg) over (partition by e.event_name order by e.instance_number, e.snap_id),0)
                          else (e.total_waits
                                - nvl(lag(e.total_waits ) over (partition by e.event_name order by e.instance_number, e.snap_id),0)
                                - greatest(0,(nvl(ebg.total_waits,0)
                                - nvl(lag(ebg.total_waits)   over (partition by e.event_name order by e.instance_number, e.snap_id),0))))
                    end  wtfg ,
                    case when e.time_waited_micro_fg is not null
                          then e.time_waited_micro_fg -
                               nvl(lag(e.time_waited_micro_fg) over (partition by e.event_name order by e.instance_number, e.snap_id),0)
                          else
                          (e.time_waited_micro
                            - nvl(lag(e.time_waited_micro  ) over (partition by e.event_name order by e.instance_number, e.snap_id),0)
                            - greatest(0,(nvl(ebg.time_waited_micro,0)
                            - nvl(lag(ebg.time_waited_micro) over(partition by e.event_name order by e.instance_number, e.snap_id),0)))
                           )
                    end  tmfg,
                   e.wait_class  wcls
                from dba_hist_system_event e
                   , dba_hist_bg_event_summary ebg
               where
                     e.dbid          = (select dbid from v\$database)
                 and e.dbid            = ebg.dbid (+)
                 and e.snap_id  =       ebg.snap_id (+)
                 and e.instance_number = ebg.instance_number (+)
                 and e.instance_number = $INST
                 and e.event_id        = ebg.event_id (+)
                 and e.wait_class     <> 'Idle'
         ) a
        )where rn<=4 and wtfg>0--end other top 4
      union all --DB cpu begin,db_cpu is always in top 5
        select instance_number,begin_snap_id, end_snap_id,'DB CPU' as event,
        to_number(null) as wtfg,
        lag_value as tmfg,
        to_number(null) as wt_avg,
        to_char(null) as wcls
        from
        (  select sp.instance_number,
            sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
            sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time,
            (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
            value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
            sy.stat_name
            from dba_hist_snapshot sp, dba_hist_sys_time_model sy
            where sp.snap_id=sy.snap_id
              and sp.instance_number=sy.instance_number
              and sp.instance_number=$INST
              and sy.stat_name='DB CPU'
              and sp.snap_id >= $bid and sp.snap_id <=$eid  ----max 100 snapshot
        ) where  nvl(lag_value,0)>0 --DB cpu end
    )v1, --------------------------------------------top 10 events
    (
        select instance_number,begin_snap_id, end_snap_id,lag_value as db_time,snap_end_time
        from
        (  select sp.instance_number,
            sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
            sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time,
            (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
            value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
            sy.stat_name
            from dba_hist_snapshot sp, dba_hist_sys_time_model sy
            where sp.snap_id=sy.snap_id
              and sp.instance_number=sy.instance_number
              and sp.instance_number=$INST
              and sy.stat_name='DB time'
              and sp.snap_id >= $bid and sp.snap_id <=$eid --max 100 snapshot
        ) where   nvl(lag_value,0)>0
    )v2 ------------------------------------------db time
    where v1.instance_number = v2.instance_number
    and v1.end_snap_id=v2.end_snap_id
    )
    select * from tmp_res
    --pivot
    --(
    -- max(event) as event,max(waits) as waits ,max(round(time_s/1e6)) as time_s,max(percent) as pct
    -- for rn  in (1 as R1,2 as R2,
    --    3 as R3,4 as R4 ,
    --    5 as R5) --the other columns must have same content; gen 3 * 5 = 15 columns
    --)
    order by inst_id,bid,rn;

    $ECHO
    spool off
!
echo "instance_number=$INST"
echo "get batch awr top event for recent $snaps snapshots"
exit 0
fi


################################################################################
if [ "$1" = "big_by_tbs" ]; then

 if [ "$2" = "" ]; then
   echo "ora big_by_tbs <tablespace_name>"
   exit 1
 fi

  if [ "$3" = "" ]; then
    topn=20
  else
    topn=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    col tablespace_name format a20 trunc
    col owner format a20 trunc
    col segment_name format a30
    col segment_type format a20 trunc
    col pct format a10

    select  tablespace_name,
                      owner,
                      segment_name,
                     segment_type,
                     size_MB,partitions, round((RATIO_TO_REPORT (size_MB) OVER ()) *100,2)||'%' pct
    from
    (  select
                     tablespace_name,
                     owner ,
                     segment_name ,
                     segment_type,
                     round(SUM(bytes/1024/1024)) size_MB,
                     case when count(*)=1 then null else count(*) end  partitions
             from dba_segments
             where upper(tablespace_name) like upper('$2')  -- tablespace name
       group by      tablespace_name,
                     owner,
                     segment_name,
                     segment_type
             order by size_MB desc
    ) where rownum <= $topn;
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "dpr_risk" ]; then

  if [ "$2" = "" ]; then
    execs=24
  else
    execs=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    col small_value new_value small_value;
    def hisdays=1
    def ratio=0.8

    set linesize 200 pagesize 37
    set verify off

    --11203+; not include partition table
    Pro _small_table_threshold :
    col small_value format a30
    col owner format a20 trunc
    col table_name format a30
    set trimspool on
    spool ora_dpr_risk_$filedate.log
    select ksppstvl  as small_value
    from sys.x\$ksppi x, sys.x\$ksppcv y
    where (x.indx = y.indx)
    and ksppinm ='_small_table_threshold';

    --group by object_name:
    Pro list objects order by execs:
    select  v1.owner,v1.table_name,v1.blocks,round(v1.blocks/&small_value,1) as blocks_vs_threshold
           ,sum(executions_delta) as execs_total
           ,round(sum(executions_delta)*v1.blocks*8192/1024/1024) as total_scan_size_M
    from
    (select  distinct b.sql_id, a.owner,a.table_name,blocks
     from dba_tab_statistics a,dba_hist_sql_plan b
     where (( b.operation||b.options like 'TABLE ACCESS%FULL')or( b.operation||b.options='INDEX FAST FULL SCAN') )
           and a.owner=b.object_owner and a.table_name=b.object_name and a.blocks >=&small_value*&ratio
           and a.object_type='TABLE'
    ) v1,dba_hist_sqlstat  v2
    where v1.sql_id=v2.sql_id
    and v2.snap_id>=(select min(snap_id) from dba_hist_snapshot where end_interval_time>=sysdate-&hisdays)
    group by v1.owner,v1.table_name,v1.blocks
    having sum(executions_delta)>=$execs
    order by total_scan_size_M desc  ;
    $ECHO

    set pagesize 0
    col param_value format a50
    select 'parameter _serial_direct_read : '||ksppstvl  as param_value
    from sys.x\$ksppi x, sys.x\$ksppcv y
    where (x.indx = y.indx)
    and ksppinm ='_serial_direct_read';
    $ECHO
    spool off
!
echo "full scan executions more than $execs in 1 day"
exit 0
fi

################################################################################
if [ "$1" = "drop" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora drop patch|profile|baseline <name>"
    exit 1
  else
     type=$2
     name=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    declare
    drop_type varchar2(30);
    v_text PLS_INTEGER;
    begin
         drop_type:=upper('$type');
         if drop_type='PATCH' then
             dbms_sqldiag.drop_sql_patch('$name');
         elsif drop_type='PROFILE' then
               DBMS_SQLTUNE.drop_sql_profile (name=> '$name', ignore => TRUE);
         elsif drop_type='BASELINE' then
               v_text :=DBMS_SPM.drop_sql_plan_baseline(plan_name =>'$name');
         end if;
    end;
/
!
exit 0
fi



################################################################################
if [ "$1" = "stat" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     echo "ora stat <owner> <table_name>"
     exit 1
   else
     owner=$2
     tablename=$3
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180

    pro
    pro
    prompt dba_tab_modifications:

    col partition_name format a20 trunc
    col table_owner format a20 trunc
    col table_name format a30


    select b.table_owner,b.TABLE_NAME,b.partition_name
    ,b.INSERTS,b.UPDATES,b.DELETES
    ,to_char(b.TIMESTAMP,'yyyy-mm-dd hh24:mi:ss') as flush_time
    ,b.TRUNCATED
    --,b.DROP_SEGMENTS
    from dba_tab_modifications b
    where table_name=upper('$tablename') and table_owner=upper('$owner')
    order by partition_name;

    pro
    pro
    prompt Statistics history:

    col table_name format a20 trunc
    col owner format a10 trunc
    col savtime format a20

    SELECT *
      FROM (
    SELECT /*+ NO_MERGE LEADING(pt s t m) */
           t.table_name ,
           t.owner,
           'CURRENT' version_type,
           NULL savtime,
           t.last_analyzed analyzetime,
           t.num_rows rowcnt,
           t.sample_size samplesize,
           CASE WHEN t.num_rows > 0 THEN TO_CHAR(ROUND(t.sample_size * 100 / t.num_rows, 1), '99999990D0') END perc,
           t.blocks blkcnt,
           t.avg_row_len avgrln
      FROM  dba_tables t
     WHERE t.owner = upper('$owner') and
           t.table_name=upper('$tablename')
    UNION ALL
    SELECT /*+ NO_MERGE LEADING(s t m) */
           t.object_name,
           t.owner,
           'HISTORY' version_type,
           to_char(h.savtime, 'yyyy-mm-dd hh24:mi:ss') as savetime,
           h.analyzetime,
           h.rowcnt,
           h.samplesize,
           CASE WHEN h.rowcnt > 0 THEN TO_CHAR(ROUND(h.samplesize * 100 / h.rowcnt, 1), '99999990D0') END perc,
           h.blkcnt,
           h.avgrln
      FROM dba_objects t,
           sys.WRI\$_OPTSTAT_TAB_HISTORY h
     WHERE t.owner = upper('$owner')
       and t.object_name=upper('$tablename')
       AND t.object_id = h.obj#
       AND t.object_type = 'TABLE' )
     ORDER BY
           table_name,
           owner,
           savtime DESC NULLS FIRST;



    Pro Index statistics:
    set linesize 180 pagesize 100
    col idx_type format a10 trunc
    col deg format a3
    col vis format a3
    col cols format 99
    col lv format 99
    col index_name format a20 trunc
    col LAST_ANALYZED format a15
    col status format a6
    SELECT /*+ NO_MERGE LEADING(pt s i) */
          -- s.table_name,
          -- s.table_owner,
           s.index_name,
          -- s.owner,
           decode(i.index_type,'FUNCTION-BASED NORMAL','F_normal',i.index_type) as idx_type,
           i.partitioned,
           i.degree as deg,
           i.temporary,
           i.status,
           --decode(i.VISIBILITy,'VISIBLE','Y','N') as vis,
           decode(i.uniqueness,'NONUNIQUE','N','UNIQUE','Y','N/A') as uni,
           (SELECT COUNT(*)
              FROM dba_ind_columns c
             WHERE c.index_owner = s.owner
               AND c.index_name = s.index_name
               AND c.table_owner = s.table_owner
               AND c.table_name = s.table_name) cols,
           s.num_rows,
           --s.sample_size,
           --CASE WHEN s.num_rows > 0 THEN TO_CHAR(ROUND(s.sample_size * 100 / s.num_rows, 1), '99999990D0') END sample_size_perc,
           TO_CHAR(s.last_analyzed, 'YYYYMMDD HH24MISS') last_analyzed,
           s.distinct_keys as DK,
           s.blevel as lv,
           s.leaf_blocks as lf_blks,
           s.avg_leaf_blocks_per_key as LF_key,
           s.avg_data_blocks_per_key as DB_Key,
           s.clustering_factor as CF,
           --s.global_stats,
           --s.user_stats,
           s.stattype_locked as locked,
           s.stale_stats
      FROM --plan_tables pt,
           dba_ind_statistics s,
           dba_indexes i
     WHERE --pt.object_type = 'TABLE'
       --AND pt.object_owner = s.table_owner
       --AND pt.object_name = s.table_name
           s.table_owner=upper('$owner')
       AND s.table_name=upper('$tablename')
       AND s.object_type = 'INDEX'
       AND s.owner = i.owner
       AND s.index_name = i.index_name
       AND s.table_owner = i.table_owner
       AND s.table_name = i.table_name
     ORDER BY s.index_name;


    PRO
    pro
    pro Columns info:

    col owner format a12
    col table_name format a30
    col table_owner format a30
    col column_name format a30
    col data_type format a12
    col low_val_25 format a25
    col high_val_25 format a25
    col histogram format a15
    col LAST_ANALYZED format a20

    select --owner,table_name,
    column_name,NULLABLE,NUM_NULLS,data_type,num_distinct,
    substr(low_value,1,25) as low_val_25,substr(high_value,1,25) as high_val_25,
    to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
    histogram
    --,NUM_BUCKETS
    from dba_tab_columns
    where table_name=upper('$tablename') and owner=upper('$owner')
    order by column_name;

    Pro Table statistics:
    col stale_stats format a12
    select owner,table_name,partition_name,partition_position,num_rows,blocks
    ,last_analyzed,stattype_locked as locked,stale_stats
    from dba_tab_statistics
    where table_name=upper('$tablename') and owner=upper('$owner')
    order by partition_position;


    Pro Basic Info:
    col owner format a10
    col table_name format a30
    col degree format a7
    col temporary format a4
    col segment_created format a5
    col logging format a5
    col compression format a9
    col created format a20
    col last_analyzed format a20
    select a.owner,table_name,num_rows,blocks,trim(degree) as degree,a.temporary,
           a.logging,a.segment_created,a.partitioned,a.compression,
           to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
           to_char(b.created,'yyyy-mm-dd hh24:mi:ss') as created
    from dba_tables a,dba_objects b
    where table_name=upper('$tablename') and a.owner=upper('$owner')
          and a.owner=b.owner and b.object_name=a.table_name and b.object_type='TABLE';

    prompt Segment info:
    col segment_name format a30
    select owner,segment_name,round(sum(bytes)/1024/1024) seg_size_M ,count(*) as segment_cnt
    from dba_segments
    where  segment_name=upper('$tablename') and owner=upper('$owner')
    group by owner,segment_name;
    $ECHO
!
 echo "ora stat $owner $tablename"
 exit 0
fi


################################################################################
if [ "$1" = "sparse_index" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    set verify off

    column index_name format a50 trunc
    column part_name format a10 trunc
    column subpart_name format a10 trunc
    column last_ddl_time  format a20
    column x noprint new_value x
    column last_analyzed format a20
    column compression format a11
    col density format a8
    set trimspool on
    spool ora_sparse_index_$filedate.log

    define density='50'

    define obj = 'nvl(isp.obj#, nvl(ip.obj#,i.obj#))'
    define objp = 'nvl(ip.obj#,i.obj#)'
    define rowcnt = 'decode(&obj, isp.obj#, isp.rowcnt, ip.obj#, ip.rowcnt, i.rowcnt)'
    define leafcnt = 'decode(&obj, isp.obj#, isp.leafcnt, ip.obj#, ip.leafcnt, i.leafcnt)'
    define pctf = 'decode(&obj, isp.obj#, isp.pctfree$, ip.obj#, ip.pctfree$, i.pctfree$)'
    define initr = 'decode(&obj, isp.obj#, isp.initrans, ip.obj#, ip.initrans, i.initrans)'
    define last_analyzed = 'nvl(decode(&obj, isp.obj#, isp.analyzetime, ip.obj#, ip.analyzetime, i.analyzetime),to_date(''01.01.1900'',''dd.mm.yyyy''))'
    define compress = 'decode(&obj, isp.obj#, ''N/A'', ip.obj#, decode(bitand(ip.flags, 1024), 0, ''DISABLED'', 1024, ''ENABLED'',''N/A''), decode(bitand(i.flags, 32), 0, ''DISABLED'', 32, ''ENABLED'',''N/A''))'

    select  /*ORACONF*/ /*+ ordered */
      u.name ||'.'|| o.name  index_name,
      op.subname part_name,
      decode(&obj, isp.obj#, o.subname, '') subpart_name,
      to_char(100*(1 - floor( &leafcnt - &rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100)))/&leafcnt),'999.00') ||'%' density,
      floor( &leafcnt - &rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100)) ) extra_blocks,
      max(o.mtime) last_ddl_time,
      decode(max(&last_analyzed),to_date('01.01.1900','dd.mm.yyyy'),'not analyzed',max(&last_analyzed)) last_analyzed
      --,max(&compress) compression
    from
      sys.ind$  i,
      sys.icol$  ic,
      ( select obj#, part#, bo#, ts#, rowcnt, leafcnt, initrans, pctfree$, analyzetime, flags
        from sys.indpart$
        union all
        select  /*ORACONF*/ obj#, part#, bo#, defts#, rowcnt, leafcnt, definitrans, defpctfree, analyzetime, flags
         from sys.indcompart$
       ) ip,
      sys.indsubpart$ isp,
      ( select ts#, blocksize value
        from sys.ts$
       )  p,
      sys.hist_head$  h,
      sys.obj$  o,
      sys.user$  u,
      sys.obj$  op
    where
      i.obj# = ip.bo#(+) and
      ip.obj# = isp.pobj#(+) and
      &leafcnt > 1 and
      i.type# in (1) and -- exclude special types
      i.pctthres$ is null and -- exclude IOT secondary indexes
      decode(&obj, isp.obj#, isp.ts#, ip.obj#, ip.ts#, i.ts#) = p.ts# and
      ic.obj# = i.obj# and
      h.obj# = i.bo# and
      h.intcol# = ic.intcol# and
      o.obj# = &obj and
      o.owner# NOT IN
      (select USER# from sys.user$
       where NAME in ( 'ANONYMOUS', 'AURORA$', 'AURORA', 'CTXSYS', 'DBSNMP', 'DIP', 'DMSYS', 'DVSYS', 'EXFSYS',
       'LBACSYS', 'MDDATA', 'MDSYS', 'MGMT_VIEW', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'TRACESVR',
       'TSMSYS', 'WKPROXY', 'WKSYS', 'WK_TEST', 'WKUSER', 'WMSYS', 'XDB' )
      ) and
      u.user# = o.owner# and  op.obj# = &objp
    group by u.name,o.name,op.subname,
      decode(&obj, isp.obj#, o.subname, ''),
      &rowcnt,
      &leafcnt,
      &initr,
      &pctf,
      p.value
      having
         100*(1 - floor( &leafcnt -&rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100)))/&leafcnt) <= nvl('&density','70')
         and      floor( &leafcnt -&rowcnt * (sum(h.avgcln) + 10) / ((p.value - 66 - &initr * 24)*(1 - &pctf/100))) >= 50
        --fred liu modify >0 to >=50
    order by 4;
    $ECHO
    spool off
!
echo "For your reference only"
exit 0
fi

################################################################################
if [ "$1" = "sparse_table" ]; then

  if [ "$2" = "" ]; then
     min_segsize_M=10
  else
     min_segsize_M="$2"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set verify off
    col "Owner" format a11 wrap heading "Owner"
    col table_name format a30 wrap heading "Tablename"
    col "Partition" format a10 wrap heading "Partition"
    col "Blocks" format 99999999 heading "Used Blocks"
    col "Avg. kBytes/Block" format 99999D99 heading "Avg.|KBytes/Block"
    col "Pct used" format 999 heading "Pct|Used"
    col "Pct free" format 999 heading "Pct|Free"
    col "Freelists" format 999 heading "Free|lists"
    col "last_analyzed" format a11 heading "last|Analyzed"
    col "RowCount" format 9999999999 heading "Row Count"
    col "real_use_M" format 9999999999 heading "Real_use_M"
    col "Empty_Blk" format 9999999999 heading "Empty Blocks"
    col "Free_Spc" format 9999999999 heading "Free Block Space"
    col "Avg_Row_Len" format 999999999 heading "Avg |Row Length"
    col "HWM" format 999999999 heading "HWM"
    col "should_use_m" format 999999999 heading "Should_use_M"
    spool ora_sparse_table_$filedate.log
    SELECT ---table partition
     table_owner "Owner",
     table_name ,
     a.partition_name "Partition",
     trunc(a.num_rows * a.avg_row_len / a.blocks) / 1024 "Avg. kBytes/Block",
     a.num_rows "RowCount",
     a.avg_row_len "Avg_Row_Len",
     round((a.num_rows * a.avg_row_len) / 1024/1024) should_use_M,
     a.blocks "Blocks",
     b.bytes/1048576 "real_use_M",
     a.empty_blocks "Empty_Blk",
     --a.avg_space "Free_Spc",
     (b.blocks - a.empty_blocks - 1) hwm,
     --nvl(to_char(a.pct_used,999),'   -') "Pct used",
     nvl(to_char(a.pct_free,999),'   -') "Pct free",
     --nvl(to_char(a.freelists,9999),'    -') "Freelists",
     nvl(to_char(a.last_analyzed,'DD-MON-YY'),'not analyzed') "last_analyzed"
    FROM   dba_tab_partitions a,
           dba_segments       b
    WHERE  a.num_rows * a.avg_row_len * 2 < a.blocks *
           (SELECT VALUE
            FROM   v\$parameter
            WHERE  lower(NAME) = 'db_block_size'
            ) AND
           extents > 1 AND
           a.table_owner = b.owner AND
           b.owner NOT IN ( 'ANONYMOUS', 'AURORA$', 'AURORA', 'CTXSYS', 'DBSNMP', 'DIP', 'DMSYS', 'DVF', 'DVSYS', 'EXFSYS', 'HR', 'LBACSYS', 'MDDATA', 'MDSYS', 'MGMT_VIEW', 'ODM', 'ODM_MTR', 'OE', 'OLAPSYS', 'ORACLE_OCM', 'ORAWSM', 'ORDPLUGINS', 'ORDSYS', 'OSE', 'OUTLN', 'PERFSTAT', 'PM', 'QS', 'QS_ADM', 'QS_CB', 'QS_CBADM', 'QS_CS', 'QS_ES', 'QS_OS', 'QS_WS', 'REPADMIN', 'SCOTT', 'SH', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'TRACESVR', 'TSMSYS', 'WKPROXY', 'WKSYS', 'WK_TEST', 'WKUSER', 'WMSYS', 'XDB' ) AND
           a.table_name = b.segment_name AND
           a.partition_name = b.partition_name AND
           a.blocks > 100 AND
           a.num_rows >= 0 AND
           b.bytes/1024/1024 >=$min_segsize_M AND
           a.last_analyzed IS NOT NULL
    UNION ALL
    SELECT --table
     a.owner "Owner",
     table_name ,
     '' "Partition",
     trunc(a.num_rows * a.avg_row_len / a.blocks) / 1024 "Avg. kBytes/Block",
     a.num_rows "RowCount",
     a.avg_row_len "Avg_Row_Len",
     round((a.num_rows * a.avg_row_len) / 1024/1024) ,
     a.blocks "Blocks",
     b.bytes/1048576 "real_use_M",
     a.empty_blocks "Empty_Blk",
     --a.avg_space "Free_Spc",
     (b.blocks - a.empty_blocks - 1) hwm,
     --nvl(to_char(a.pct_used,999),'   -') "Pct used",
     nvl(to_char(a.pct_free,999),'   -') "Pct free",
     --nvl(to_char(a.freelists,9999),'    -') "Freelists",
     nvl(to_char(a.last_analyzed,'DD-MON-YY'),'not analyzed') "last_analyzed"
    FROM   dba_tables   a,
           dba_segments b
    WHERE  a.num_rows * a.avg_row_len * 2 < a.blocks *
           (SELECT VALUE
            FROM   v\$parameter
            WHERE  lower(NAME) = 'db_block_size'
            ) AND
           extents > 1 AND
           a.owner = b.owner AND
           b.owner NOT IN ( 'ANONYMOUS', 'AURORA$', 'AURORA', 'CTXSYS', 'DBSNMP', 'DIP', 'DMSYS', 'DVF', 'DVSYS', 'EXFSYS', 'HR', 'LBACSYS', 'MDDATA', 'MDSYS', 'MGMT_VIEW', 'ODM', 'ODM_MTR', 'OE', 'OLAPSYS', 'ORACLE_OCM', 'ORAWSM', 'ORDPLUGINS', 'ORDSYS', 'OSE', 'OUTLN', 'PERFSTAT', 'PM', 'QS', 'QS_ADM', 'QS_CB', 'QS_CBADM', 'QS_CS', 'QS_ES', 'QS_OS', 'QS_WS', 'REPADMIN', 'SCOTT', 'SH', 'SI_INFORMTN_SCHEMA', 'SYS', 'SYSMAN', 'SYSTEM', 'TRACESVR', 'TSMSYS', 'WKPROXY', 'WKSYS', 'WK_TEST', 'WKUSER', 'WMSYS', 'XDB' ) AND
           a.table_name = b.segment_name AND
           a.blocks > 100 AND
           a.num_rows >= 0 AND
           b.bytes/1024/1024 > =$min_segsize_M AND
           a.tablespace_name <> ' ' AND
           a.last_analyzed IS NOT NULL and
           a.iot_type IS NULL
    ORDER  BY "Avg. kBytes/Block" DESC;
    $ECHO
    spool off
!
echo "Filter: min_segsize_M=$min_segsize_M  (analyzed / blocks >100 / extents >1 / not sys users / half empty)"
echo usage : ora sparse_table 10
exit 0
fi


################################################################################
if [ "$1" = "hintname" -o "$1" = "hint" ]; then

 if [ "$2" = "" ]; then
   echo "ora hintname index"
   exit 1
 fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col name format a35 trunc
    col inverse format a35 trunc
    col version format a10
    col version_outline format a10 trunc
    select name,inverse,version,version_outline
    from v\$sql_hint where name like upper('%$2%')
    order by name;
    $ECHO
!
exit 0
fi


################################################################################
if [ "$1" = "print_table" ]; then

  if [ "$2" = "" ]; then
    echo "ora print_table  \"select * from t1 where object_name=''T1''\""
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected|successfully"

    connect $DBUSER

    set pagesize 30
    set linesize 150
--usage :  @print_table "select * from t1 where object_name=''T1''"
set verify off serveroutput on size unlimit
declare
    l_theCursor     integer default dbms_sql.open_cursor;
    l_columnValue   varchar2(4000);
    l_status        integer;
    l_descTbl       dbms_sql.desc_tab;
    l_colCnt        number;
    l_rowCnt        number;

    procedure execute_immediate( p_sql in varchar2 )
    is
    BEGIN
        dbms_sql.parse(l_theCursor,p_sql,dbms_sql.native);
        l_status := dbms_sql.execute(l_theCursor);
    END;
    procedure p ( p_str in varchar2 )
    is
        l_str   long := p_str;
    begin
        loop
            exit when l_str is null;
            dbms_output.put_line( substr( l_str, 1, 250 ) );
            l_str := substr( l_str, 251 );
        end loop;
    end;
begin
    execute_immediate( 'alter session set nls_date_format= ''yyyy-mm-dd hh24:mi:ss'' ');
    dbms_sql.parse(  l_theCursor,
                     replace( '$2', '"', ''''),
                     dbms_sql.native );

    dbms_sql.describe_columns( l_theCursor,l_colCnt, l_descTbl );
    l_rowCnt :=0;

    for i in 1 .. l_colCnt loop
        dbms_sql.define_column( l_theCursor, i, l_columnValue, 4000 );

    end loop;

    l_status := dbms_sql.execute(l_theCursor);
    --tiger add:limit with 1000 rows
    while ( dbms_sql.fetch_rows(l_theCursor) > 0 and l_rowCnt<1000) loop
        for i in 1 .. l_colCnt loop
            dbms_sql.column_value( l_theCursor, i, l_columnValue );
            p( rpad( l_descTbl(i).col_name, 30 ) || ': "' || l_columnValue || '"' );
        end loop;
        l_rowCnt:=l_rowCnt+1;
        dbms_output.put_line( '-----------------' );
    end loop;
    --execute_immediate( 'alter session set nls_date_format=''yyyy-mm-dd hh24:mi:ss'' ');
    dbms_output.put_line( 'total rows = '||l_rowCnt );
exception
    when others then
        execute_immediate( 'alter session set nls_date_format=''dd-MON-yy'' ');
        raise;
end;
/

!
#echo "example:ora print_table \"select * from gv\\\$sql_shared_cursor where sql_id=''69k5bhm12sz98''\""
exit 0
fi


################################################################################################################
if [ "$1" = "sharing" ]; then

  if [ "$2" = "" ]; then
    echo "ora sharing <sql_id>"
    exit 1
  fi

 ## ora print_table "select * from gv\$sql_shared_cursor where sql_id=''$2''"

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150

    Pro group by reason(summary or special sql_id):
    select reason_not_shared, count(*) Reasons
    from gv\$sql_shared_cursor
     unpivot --column to row
     (val for reason_not_shared in( --68 items 12.2
      UNBOUND_CURSOR,SQL_TYPE_MISMATCH,OPTIMIZER_MISMATCH,OUTLINE_MISMATCH,
      STATS_ROW_MISMATCH,LITERAL_MISMATCH,FORCE_HARD_PARSE,EXPLAIN_PLAN_CURSOR,
      BUFFERED_DML_MISMATCH,PDML_ENV_MISMATCH,INST_DRTLD_MISMATCH,SLAVE_QC_MISMATCH,
      TYPECHECK_MISMATCH,AUTH_CHECK_MISMATCH,BIND_MISMATCH,DESCRIBE_MISMATCH,
      LANGUAGE_MISMATCH,TRANSLATION_MISMATCH,BIND_EQUIV_FAILURE,INSUFF_PRIVS,
      INSUFF_PRIVS_REM,REMOTE_TRANS_MISMATCH,LOGMINER_SESSION_MISMATCH,INCOMP_LTRL_MISMATCH,
      OVERLAP_TIME_MISMATCH,EDITION_MISMATCH,MV_QUERY_GEN_MISMATCH,USER_BIND_PEEK_MISMATCH,
      TYPCHK_DEP_MISMATCH,NO_TRIGGER_MISMATCH,FLASHBACK_CURSOR,ANYDATA_TRANSFORMATION,
      PDDL_ENV_MISMATCH,TOP_LEVEL_RPI_CURSOR,DIFFERENT_LONG_LENGTH,LOGICAL_STANDBY_APPLY,
      DIFF_CALL_DURN,BIND_UACS_DIFF,PLSQL_CMP_SWITCHS_DIFF,CURSOR_PARTS_MISMATCH,
      STB_OBJECT_MISMATCH,CROSSEDITION_TRIGGER_MISMATCH,PQ_SLAVE_MISMATCH,TOP_LEVEL_DDL_MISMATCH,
      MULTI_PX_MISMATCH,BIND_PEEKED_PQ_MISMATCH,MV_REWRITE_MISMATCH,ROLL_INVALID_MISMATCH,
      OPTIMIZER_MODE_MISMATCH,PX_MISMATCH,MV_STALEOBJ_MISMATCH,FLASHBACK_TABLE_MISMATCH,
      LITREP_COMP_MISMATCH,PLSQL_DEBUG,LOAD_OPTIMIZER_STATS,ACL_MISMATCH,
      FLASHBACK_ARCHIVE_MISMATCH,LOCK_USER_SCHEMA_FAILED,REMOTE_MAPPING_MISMATCH,LOAD_RUNTIME_HEAP_FAILED,
      HASH_MATCH_FAILED,PURGED_CURSOR,BIND_LENGTH_UPGRADEABLE,USE_FEEDBACK_STATS)
    )
    where val = 'Y' and inst_id=$INST and sql_id='$2'
    group by reason_not_shared
    order by 2 desc;
    $ECHO
!
echo "instance_number=$INST"
echo "v#sql_shared_cursor : one cursor may have more than one reason."
exit 0
fi


################################################################################
if [ "$1" = "top_seg" -o "$1" = "topseg" ]; then

  ##if [ "$2" = "" -o "$3" = "" ]; then
  ##  bid="(select max(snap_id)-1 from dba_hist_snapshot)"
  ##  eid="(select max(snap_id)   from dba_hist_snapshot)"
  ##else
  ##   bid=$2
  ##   eid=$3
  ##fi

  if [ "$2" = "" -o "$3" = "" ]; then
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi

   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else
    bid=$2
    eid=$3
  fi



  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col owner format a15 trunc
    col tablespace_name format a15 trunc
    col object_name format a30
    col subobject_name format a30
    col OBJECT_TYPE format a20 trunc
    spool ora_topseg_$filedate.log
    PRO Top Logical Reads Objects:
    with sum_logical_reads as
    (select max(value)-min(value) as slr
    from dba_hist_sysstat
    where stat_name='session logical reads' and snap_id between $bid and $eid
    and dbid=(select dbid from v\$database)
    and instance_number=$INST
    )
    select owner, tablespace_name, object_name, subobject_name,
               object_type, logical_reads, ratio
        from (select n.owner, n.tablespace_name, n.object_name,
                     n.subobject_name, n.object_type, r.logical_reads,
                     round(decode(t.slr, 0, to_number(null), 100 * logical_reads / t.slr),2) ratio
                     --round((ratio_to_report(r.logical_reads) over ())*100,2) as ratio
              from dba_hist_seg_stat_obj n,
                   (select dataobj#, obj#, dbid,
                           sum(logical_reads_delta) logical_reads
                    from dba_hist_seg_stat
                    where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                      and snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                      and dbid    = (select dbid from v\$database)
                      and instance_number   = $INST
                    group by dataobj#, obj#, dbid
                   ) r,sum_logical_reads t
              where n.dataobj#      = r.dataobj#
                and n.obj#          = r.obj#
                and n.dbid          = r.dbid
                and r.logical_reads > 0
              order by r.logical_reads desc, object_name, owner, subobject_name
            )
        where rownum <= 10;

        PRO Top physical Reads Objects:
        with sum_physical_reads as
        (select max(value)-min(value) as phyr
        from dba_hist_sysstat
        where stat_name='physical reads' and snap_id between $bid and $eid
        and dbid=(select dbid from v\$database)
        and instance_number=$INST
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, physical_reads, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.physical_reads,
                         --round((ratio_to_report(r.physical_reads) over ())*100,2) as ratio
                         round(decode(p.phyr, 0, to_number(null),  100 * r.physical_reads / p.phyr),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(physical_reads_delta) physical_reads
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.physical_reads > 0
                  order by r.physical_reads desc, object_name, owner, subobject_name)
            where rownum <= 10;
      $ECHO

      PRO Top physical Read Requests Objects:
        with sum_physical_reads as
        (select max(value)-min(value) as phyr
        from dba_hist_sysstat
        where stat_name='physical read IO requests' and snap_id between $bid and $eid
        and dbid=(select dbid from v\$database)
        and instance_number=$INST
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, physical_read_requests, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.physical_read_requests,
                         round(decode(p.phyr, 0, to_number(null),  100 * r.physical_read_requests / p.phyr),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(PHYSICAL_READ_REQUESTS_DELTA) physical_read_requests
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.physical_read_requests > 0
                  order by r.physical_read_requests desc, object_name, owner, subobject_name)
            where rownum <= 10;
      $ECHO

      PRO Top Direct physical Reads Objects:
        with sum_physical_reads as
        (select max(value)-min(value) as phyr
        from dba_hist_sysstat
        where stat_name='physical reads direct' and snap_id between $bid and $eid
        and dbid=(select dbid from v\$database)
        and instance_number=$INST
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, direct_physical_reads, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.direct_physical_reads,
                         round(decode(p.phyr, 0, to_number(null),  100 * r.direct_physical_reads / p.phyr),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(PHYSICAL_READS_DIRECT_DELTA) direct_physical_reads
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.direct_physical_reads > 0
                  order by r.direct_physical_reads desc, object_name, owner, subobject_name)
            where rownum <= 10;
      $ECHO

        PRO Top Table Scans Objects:
        with sum_physical_reads as
        (select sum(scans) as scans from
            (select max(value)-min(value) as scans
            from dba_hist_sysstat
            where stat_name ='table scans (direct read)' and snap_id between $bid and $eid
            and dbid=(select dbid from v\$database)
            and instance_number=$INST
            union all
            select max(value)-min(value) as scans
            from dba_hist_sysstat
            where stat_name= 'index fast full scans (full)' and snap_id between $bid and $eid
            and dbid=(select dbid from v\$database)
            and instance_number=$INST
            )
        )
        select owner, tablespace_name, object_name, subobject_name,
                   object_type, table_scans, ratio
            from (select n.owner, n.tablespace_name, n.object_name,
                         n.subobject_name, n.object_type, r.table_scans,
                         round(decode(p.scans, 0, to_number(null),  100 * r.table_scans / p.scans),2) ratio
                  from dba_hist_seg_stat_obj n,
                       (select dataobj#, obj#, dbid,
                               sum(TABLE_SCANS_DELTA) table_scans
                        from dba_hist_seg_stat
                         where snap_id  > $bid--(select max(snap_id)-1 from dba_hist_snapshot)
                          and  snap_id <= $eid--(select max(snap_id)   from dba_hist_snapshot)
                          and dbid              = (select dbid from v\$database)
                          and instance_number   = $INST
                        group by dataobj#, obj#, dbid) r,sum_physical_reads p
                  where n.dataobj#      = r.dataobj#
                    and n.obj#          = r.obj#
                    and n.dbid          = r.dbid
                    and r.table_scans > 0
                  order by r.table_scans desc, object_name, owner, subobject_name)
            where rownum <= 10;
      $ECHO


      spool off
!
echo "instance_number=$INST"
echo "top_seg for snapshot $bid $eid"
exit 0
fi

################################################################################
if [ "$1" = "load" -o "$1" = "batch_load" ]; then

 ##if [ "$2" = "" ]; then
 ##   days=2
 ##else
 ##   days=$2
 ##fi

     if [ $# -eq 1 ]; then
       bid="(select max(snap_id)-48 from dba_hist_snapshot)"
       eid="(select max(snap_id)    from dba_hist_snapshot)"
     elif [ $# -eq 2 ]; then
       bid="(select max(snap_id)-$2 from dba_hist_snapshot)"
       eid="(select max(snap_id)    from dba_hist_snapshot)"
     elif [ $# -eq 3 ]; then
       bid=$2
       eid=$3
    fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set trims on
    col inst_id format 999
    col bid format 99999
    col elap format 9999
    col e_time format a11
    col rbs format 999
    col commits format 99999
    col execs format 999999
    col logons format 999
    col ior_m format 9999
    col iow_m format 9999
    col hard_p format 9999
    col SOFT_P format 999999
    col U_CALLS format 99999
    col redo_k format 999999
    col END_TIME format a20
    set trimspool on
    spool ora_batch_load_${INST}_${filedate}.log
    with tmp_stat as
    (select instance_number as inst_id,lag(snap_id) over (partition by dbid,instance_number,stat_id order by snap_id) as bid
           ,a.snap_id as eid,stat_name
           ,value-lag(value) over (partition by dbid,instance_number,stat_id order by snap_id) as delta_value
     from dba_hist_sysstat a
     where dbid=(select dbid from v\$database)
     and instance_number = $INST
     and snap_id >=$bid
     and snap_id <=$eid
     and a.stat_name in (
    'db block changes','execute count','logons cumulative','opened cursors cumulative','parse count (total)',
    'parse count (hard)','physical reads','physical writes','redo size','session cursor cache hits',
    'session logical reads','user calls','user commits','user rollbacks','workarea executions - optimal'
    ,'physical write total bytes','physical read total bytes'
    --,'DB time','CPU used by this session'
    )
    ),
    tmp_snap as
        (select instance_number as inst_id,snap_id-1 as bid,snap_id as eid,to_char(end_interval_time,'yymmdd-hh24mi') as end_time,
        (cast(end_interval_time as date) - cast(begin_interval_time as date))* 24 * 60 * 60 as secs
        from dba_hist_snapshot
        where snap_id >=$bid
          and snap_id<=$eid
          and dbid=(select dbid from v\$database)
          and instance_number=$INST
        ),
    tmp_before_pivot as
    (
     select a.inst_id,a.bid,b.end_time,a.eid,
           a.stat_name,round(b.secs/60) as elp_mins,round(a.delta_value/b.secs,1) as per_second
     from tmp_stat a,tmp_snap b
     where a.delta_value is not null
     and a.inst_id=b.inst_id
     and a.bid=b.bid and a.eid=b.eid and b.secs>0
    ),
    tmp_load1 as
    (
    select  inst_id
           ,BID,EID||'_'||end_time as end_time
           ,ELP_MINS as elap
           ,round(ior_m/1024/1024,1) as ior_m
           ,round(iow_m/1024/1024,1) as iow_m
           ,round(redo_size) as redo_size
           ,round(logical_reads) as l_reads
           ,round(Block_changes) as Blk_chgs
           ,round(physical_reads) as phy_reads
           ,round(physical_writes) as phy_writes
           ,round(user_calls) as u_calls
           ,round(parses) as soft_p
           ,round(hard_parses) as hard_p
           ,round(logons) as logons
           ,round(executions) as execs
           ,round(commits) as commits
           ,round(rollbacks) as rbs
    from tmp_before_pivot a
    pivot
        (max(per_second) for stat_name in
            (--'CPU used by this session' as cpu,'DB time' as db_time,
            'redo size' as redo_size,'session logical reads' as logical_reads,
            'db block changes' as Block_changes,    'physical reads' as physical_reads,
            'physical writes' as physical_writes,    'user calls' as user_calls,
            'parse count (total)' as parses,
            'parse count (hard)' as hard_parses,    'logons cumulative' as logons,
            'execute count' as executions,    --'parse time elapsed','session cursor cache hits',
            'user commits' as commits,    'user rollbacks' as rollbacks
            ,'physical write total bytes' as iow_M,'physical read total bytes' as ior_M
            )
        )
    ),
    tmp_load2 as
    (
    select * from
    (
    select sp.instance_number as inst_id,
    sp.snap_id-1 as begin_snap_id,
    sp.snap_id   as end_snap_id,
    to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
    to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time,
    (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
    value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
    sy.stat_name
    from dba_hist_snapshot sp, dba_hist_sys_time_model sy
    where sp.snap_id=sy.snap_id
      and sp.instance_number=sy.instance_number
      and sy.stat_name in ('DB CPU' ,'DB time')
      and sp.instance_number=$INST
    ) pivot (sum(lag_value) for stat_name in  ('DB CPU' as db_cpu ,'DB time' as db_time))
    where   nvl(db_cpu,0)>0 and nvl(db_time,0)>0
    )
select   a.inst_id,BID,end_time,elap
        ,round(db_cpu/60/1000000/interval_min,2) as db_cpu_s
        ,round(db_time/60/1000000/interval_min,2) as db_time_s
        ,ior_m,iow_m,round(redo_size/1024) as redo_k
        ,l_reads,Blk_chgs,phy_reads,phy_writes,u_calls
        ,soft_p,hard_p,logons,execs,commits,rbs
    from tmp_load1 a,tmp_load2 b
 where a.bid=b.begin_snap_id  and a.inst_id=b.inst_id order by 1,2;
 $ECHO
 spool off
!
echo "instance_number=$INST"
echo "ora load [<bid> <eid>]  (default value is recent 48 snaps)"
exit 0
fi



################################################################################
if [ "$1" = "tbs_last" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col tablespace_name format a20 trunc
    col rtime format a25
      select a.rtime,b.name as tablespace_name,
         round(a.tablespace_size*c.block_size/1024/1024) as total_size_M,
         round(a.tablespace_usedsize*c.block_size/1024/1024) as used_size_M,
         -- ,c.block_size
         round(a.tablespace_usedsize/a.tablespace_size*100,1) as used_percent
     from dba_hist_tbspc_space_usage a,v\$tablespace b,dba_tablespaces c
     where a.snap_id=(select max(snap_id) from dba_hist_snapshot)
     and b.ts#=A.TABLESPACE_ID and b.name=c.tablespace_name
     order by used_percent;
     $ECHO
!
echo get  tablespace_usedsize from dba_hist_tbspc_space_usage
exit 0
fi



################################################################################
if [ "$1" = "tbs_usage" ]; then
#undo tablespace maybe not displayed in DBA_TABLESPACE_USAGE_METRICS

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 40
    set linesize 150
    col tablespace_name format a20 trunc
    SELECT a.tablespace_name,
         --round(tablespace_size * b.block_size / 1024/1024) AS total_space_M ===> a.tablespace_size not suitable for autoextensible
         b.total_size_M,
         ROUND (a.used_space * b.block_size  / 1024 /1024) AS used_space_M,
         ROUND (a.used_space * b.block_size  / 1024 /1024/ total_size_M*100,1 ) as used_pct,
         --ROUND (a.used_percent,1) AS used_pct =====> a.used_percent not suitable for autoextensible
         b.autoext
    FROM DBA_TABLESPACE_USAGE_METRICS a, ---only get its used_space column
    (select tablespace_name,round(sum(bytes)/1024/1024) as total_size_M
           ,max(autoextensible) as autoext,max(bytes/blocks) as block_size from dba_data_files
           group by tablespace_name
    union all
          select tablespace_name,round(sum(bytes)/1024/1024) as total_size_M
         ,max(autoextensible) as autoext,max(bytes/blocks) as block_size from dba_temp_files
         group by tablespace_name
    )    b
    where a.tablespace_name=b.tablespace_name
    ORDER BY 4 ;
    $ECHO

!
echo get  tablespace_usedsize from DBA_TABLESPACE_USAGE_METRICS
exit 0
fi

################################################################################
if [ "$1" = "4031" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180

    col COMPONENT format a30
    set trimspool on
    spool ora_4031_$filedate.log

    REM === -- end of standard header -- ===
    REM
    SET PAGESIZE 9999
    SET LINESIZE 256
    SET TRIMOUT ON
    SET TRIMSPOOL ON
    COL 'Total Shared Pool Usage(M)' FORMAT 99999999999999999999999
    COL bytes FORMAT 999999999999999
    COL current_size FORMAT 999999999999999
    COL name FORMAT A40
    COL value FORMAT A20
    col OPER_TYPE format a12 trunc
    col OPER_MODE format a10 trunc
    ALTER SESSION SET nls_date_format='DD-MON-YYYY HH24:MI:SS';



    /* Current instance parameter values */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Current instance parameter values:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT n.ksppinm name, v.KSPPSTVL value
    FROM x\$ksppi n, x\$ksppsv v
    WHERE n.indx = v.indx
    AND (n.ksppinm LIKE '%shared_pool%' OR n.ksppinm IN ('_kghdsidx_count', '_ksmg_granule_size', '_memory_imm_mode_without_autosga'))
    ORDER BY 1;

    /* Current memory settings */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Current instance parameter values:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT component, current_size FROM v\$sga_dynamic_components;

    /* Memory resizing operations */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Memory resizing operations:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT start_time, end_time, component, oper_type, oper_mode, initial_size, target_size, final_size, status
    FROM v\$sga_resize_ops
    ORDER BY 1, 2;

    /* Historical memory resizing operations */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Historical memory resizing operations:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT start_time, end_time, component, oper_type, oper_mode, initial_size, target_size, final_size, status
    FROM dba_hist_memory_resize_ops
    ORDER BY 1, 2;

    /* Shared pool 4031 information */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Shared pool 4031 information:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT request_failures, last_failure_size FROM v\$shared_pool_reserved;

    /* Shared pool reserved 4031 information */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Shared pool reserved 4031 information:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT requests, request_misses, free_space, avg_free_size, free_count, max_free_size FROM v\$shared_pool_reserved;

    /* Shared pool memory allocations by size */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Shared pool memory allocations by size:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT name, bytes FROM v\$sgastat WHERE pool = 'shared pool' AND (bytes > 999999 OR name = 'free memory') ORDER BY bytes DESC;

    /* Total shared pool usage */
    SET HEADING OFF
    SELECT '**************************************************************************************************************' FROM dual
    UNION ALL
    SELECT 'Total shared pool usage:' FROM dual
    UNION ALL
    SELECT '**************************************************************************************************************' FROM dual;
    SET HEADING ON
    SELECT round(SUM(bytes)/1024/1024) "Total Shared Pool Usage(M)" FROM v\$sgastat WHERE pool = 'shared pool' AND name != 'free memory';

   -- /* Cursor sharability problems */
   -- /* This version is for >= 10g; for <= 9i substitute ss.kglhdpar for ss.address!!!! */
   -- SET HEADING OFF
   -- SELECT '**************************************************************************************************************' FROM dual
   -- UNION ALL
   -- SELECT 'Cursor sharability problems (this version is for >= 10g; for <= 9i substitute ss.kglhdpar for ss.address!!!!):' FROM dual
   -- UNION ALL
   -- SELECT '**************************************************************************************************************' FROM dual;
   -- SET HEADING ON
   -- SELECT sa.sql_text,sa.version_count,ss.*
   -- FROM v\$sqlarea sa,v\$sql_shared_cursor ss
   -- WHERE sa.address=ss.address AND sa.version_count > 50
   -- ORDER BY sa.version_count ;
   -- spool off

!
echo "current instance only"
exit 0
fi
#######################################4030 ####################################################

if [ "$1" = "4030" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 180

    col COMPONENT format a30
    set trimspool on
    spool ora_4030_$filedate.log
    prompt 863562.1

    SET PAGESIZE 9999
    SET LINESIZE 256
    SET TRIMOUT ON
    SET TRIMSPOOL ON
    COL statistic# FORM 999
    COL name HEADING "Name" FORM A50
    COL val HEADING "Value" FORM A20
    COL value HEADING "Value" FORM 9999999999999999
    COL totsga HEADING "Total SGA Size (Fixed + Variable; MB)" FORM 9999999999999999
    COL totpga HEADING "Total PGA Allocated (MB)" FORM 9999999999999999
    COL inactivepga HEADING "Inactive PGA (MB)" FORM 9999999999999999
    COL SID FORMAT 999999
    ALTER SESSION SET nls_date_format='DD-MON-YYYY HH24:MI:SS';
    BREAK ON sid

    /* Database identification */
    SELECT name, platform_id, database_role FROM v\$database;
    SELECT * FROM v\$version WHERE banner LIKE 'Oracle Database%';

    /* Current instance parameter values */
    SELECT n.ksppinm name, v.KSPPSTVL val
    FROM x\$ksppi n, x\$ksppsv v
    WHERE n.indx = v.indx
    AND (n.ksppinm LIKE '%pga%target%' OR n.ksppinm LIKE '%sga%target%' OR n.ksppinm LIKE '%memory%target%' OR n.ksppinm LIKE '%indirect%')
    ORDER BY 1;

    /* Current memory settings */
    SELECT component, current_size FROM v\$sga_dynamic_components;

    /* Memory resizing operations */
    SELECT start_time, end_time, component, oper_type, oper_mode, initial_size, target_size, final_size, status
    FROM v\$memory_resize_ops
    ORDER BY 1, 2;

    /* Historical memory resizing operations */
    SELECT start_time, end_time, component, oper_type, oper_mode, initial_size, target_size, final_size, status
    FROM dba_hist_memory_resize_ops
    ORDER BY 1, 2;

    /* Total SGA allocated */
    SELECT SUM(value) totsga FROM v\$sga;

    /* Total PGA allocated */
    SELECT SUM(pga_alloc_mem)/1024/1024 totpga
    FROM v\$process p, v\$session s
    WHERE p.addr = s.paddr;

    /* Inactive total process PGA memory use */
    SELECT SUM(pga_alloc_mem)/1024/1024 inactivepga
    FROM v\$process p, v\$session s
    WHERE p.addr = s.paddr
    AND s.status = 'INACTIVE';

    /* Inactive PGA memory use grouped per Oracle user */
    SELECT p.username, SUM(pga_alloc_mem)/1024/1024 inactivepga
    FROM v\$process p, v\$session s
    WHERE p.addr = s.paddr
    AND s.status = 'INACTIVE'
    GROUP BY p.username
    ORDER BY p.username, SUM(pga_alloc_mem) DESC;

    /* Get cumulative session memory statistics */
    SELECT n.name, s.value
    FROM (SELECT statistic#, SUM(value) value
          FROM v\$sesstat
          GROUP BY statistic#) s,
         v\$statname n
    WHERE s.statistic# = n.statistic#
    AND n.name LIKE '%memory%'
    ORDER BY s.statistic#;

    /* Get per-session memory statistics */
    SELECT s.sid, n.name, s.value
    FROM v\$sesstat s, v\$statname n
    WHERE s.statistic# = n.statistic#
    AND n.name LIKE 'session%memory%'
    ORDER BY s.sid, s.statistic#;

    /* UGA memory allocation cumulative statistics; necessary for Shared Server analysis */
    SELECT SUM(value) || ' Bytes' "Total UGA (All Sessions)"
    FROM v\$sesstat, v\$statname
    WHERE name = 'session uga memory'
    AND v\$sesstat.statistic# = v\$statname.statistic#;

    /* UGA maximum memory allocation cumulative statistics; necessary for Shared Server analysis */
    SELECT SUM(value) || ' Bytes' "Total Max UGA (All Sessions)"
    FROM v\$sesstat, v\$statname
    WHERE name = 'session uga memory max'
    AND v\$sesstat.statistic# = v\$statname.statistic#;

    /* Shared Server Wait Queue Statistics */
    SELECT DECODE(TOTALQ, 0, 'No Requests',
    WAIT/TOTALQ || ' Hundredths Of Seconds') "Average Wait Time Per Request"
    FROM V\$QUEUE
    WHERE TYPE = 'COMMON';

    /* Shared Server process count */
    SELECT COUNT(*) "Shared Server Processes"
    FROM V\$SHARED_SERVER
    WHERE STATUS != 'QUIT';
    spool off

!
echo "current instance only"
exit 0
fi

################10046 ###################
if [ "$1" = "10046" ]; then
  echo ""
  echo "Run 10046 Command "
  echo "======================"
  echo "1.Run 10046 trace;"
  echo "alter session set timed_statistics = true;"
  echo "alter session set statistics_level=all;"
  echo "alter session set max_dump_file_size = unlimited;"
  echo "alter session set events '10046 trace name context forever, level 12'; "
  echo "<Run your SQL here;>"
  echo "alter session set events '10046 trace name context off';"
  echo "2.Format your 10046 trace file:"
  echo "\$tkprof <trace file> <output file>"
  echo "For example:"
  echo "\$cd /u01/OracleAPP/oracle/admin/R1020/udump"
  echo "\$ls -ltr"
  echo "\$tkprof r1020_ora_9638.trc 9638.output"
  echo ""

  echo """
1. 开启10046跟踪语句
select
    'oradebug setospid ' || p.spid || chr(10) ||
    'oradebug unlimit' || chr(10) ||
    'oradebug event 10046 trace name context forever, level 12' Enable_CMD
from
    v\$session s,
    v\$process p
where
    s.paddr = p.addr
and
    s.program like '%(J0%'
/

-- Close 10046
select
    'oradebug setospid ' ||  p.spid || chr(10) ||
    'oradebug event 10046 trace name context off;' || chr(10) ||
    'oradebug tracefile_name' Disable_CMD
from
   v\$session s,
   v\$process p
where
    s.paddr = p.addr
and
    s.program like '%(J0%'
/
  """

exit 1
fi
################################################################################
if [ "$1" = "pid" ]; then

  if [ "$2" = "" ]; then
    echo "ora pid os_pid"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

col username format a10 trunc
col machine format a10 trunc
col program format a10 trunc
col event format a15 trunc
col sid format 999999
col serial# format 999999
col wait_s format 999999
col sql_id format a13
col b_status format a5 trunc
col B_inst_id format 99
col b_sid format 999999
col sql_text format a20 trunc
col sql_id new_value sql_id
col logon_time format a16
col status format a8

SELECT a.username,
       a.sql_id,
       --a.prev_sql_id,
      a.machine,
      a.program,
      a.sid,
      a.serial#,
      to_char(logon_time,'yyyymmdd hh24miss') logon_time,
      event,
      seconds_in_wait as wait_s,
      a.status,
      round(b.pga_used_mem/1024/1024) as pga_used_M,
      round(b.pga_alloc_mem/1024/1024) as pga_alloc_M,
      BLOCKING_INSTANCE as b_inst_id,
      BLOCKING_SESSION as b_sid,
      BLOCKING_SESSION_STATUS as b_status,
      substr(c.sql_text,1,100 )as sql_text
FROM  gv\$session a,
      gv\$process b,
      gv\$sql c
WHERE b.spid=$2
  AND b.addr=a.paddr
  and a.sql_id=c.sql_id(+)
  and a.inst_id=b.inst_id
  and a.inst_id=c.inst_id(+)
  and a.inst_id=$INST
  and a.sql_child_number=c.child_number(+);
  $ECHO

!
echo "instance_number=$INST"
exit 0
fi


################################################################################
if [ "$1" = "check" ]; then

 # if [ "$2" = "" ]; then
 #   echo "ora check xxx"
 #   exit 1
 # fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col owner format a20 trunc
    col table_name format a30
    col table_owner format a20 trunc
    col index_name format a30
    col index_owner format a30
    col partition_name format a20 trunc
    set trimspool on
    spool ora_check_$filedate.log

    Pro Unusable Index:
    select owner,table_name,table_owner,index_name from dba_indexes where status='UNUSABLE';
    $ECHO

    Pro Unusabel index partition :
    select index_owner,index_name,partition_name from dba_ind_partitions where status='UNUSABLE';
    $ECHO

    Pro Unusabel index subpartition:
    select index_owner,index_name,partition_name,subpartition_name from dba_ind_subpartitions where status='UNUSABLE';
    $ECHO

    Pro Invisible Index:
    select owner,table_name,table_owner,index_name from dba_indexes where visibility='INVISIBLE';
    $ECHO

    pro
    pro
    Prompt "Invalid objects by owner and type:"
    prompt =========================
    col owner format a30
    col object_type format a30
    select owner,object_type,count(*) invalid_cnt
    from dba_objects
    where status='INVALID'
    group by owner,object_type
    order by 1,2;
    $ECHO

    Pro Table with Columns more than 255:
    select owner,table_name,count(*) as col_cnt from dba_tab_columns
    group by owner,table_name having count(*) >255
    order by 1,2;
    $ECHO

    Pro Bitmap index:
    select table_owner,table_name,index_name
    from dba_indexes where index_type='BITMAP'
    order by 1,2;
    $ECHO


    Pro foreign key column no index:
    col FK_COLUMNS format a35 trunc
    col OWNER format a20 trunc
    col CONSTRAINT_NAME format a30
    select fk.* from
    (SELECT   b.owner,B.TABLE_NAME,B.CONSTRAINT_NAME, count(*) column_cnt,
                   listagg(COLUMN_NAME, ',') within group (order by POSITION) fk_columns
              FROM DBA_CONS_COLUMNS A,
                   DBA_CONSTRAINTS B
             WHERE b.owner not in ('SYS','SYSTEM','WMSYS','SYSMAN','MDSYS','CTXSYS','OLAPSYS','DBSNMP','XDB','ORDDATA','EXFSYS')
                 and b.owner not like 'APEX%'
               AND A.CONSTRAINT_NAME = B.CONSTRAINT_NAME
               AND A.owner= b.owner
               AND B.CONSTRAINT_TYPE = 'R'
             GROUP BY b.owner,B.TABLE_NAME, B.CONSTRAINT_NAME
    )fk,
    ( select table_owner,table_name,index_name,count(*) column_cnt,
     listagg(COLUMN_NAME, ',') within group (order by COLUMN_POSITION) idx_columns
    from dba_ind_columns
    where table_owner not in ('SYS','SYSTEM','WMSYS','SYSMAN','MDSYS','CTXSYS','OLAPSYS','DBSNMP','XDB')
          and table_owner not like 'APEX%'
    group by table_owner,table_name,index_name
    )idx
    where fk.owner=idx.table_owner(+) and fk.table_name=idx.table_name(+) and fk.fk_columns=idx.idx_columns(+)
    and idx.table_owner is null
    order by 1,2,3;
    $ECHO
    spool off

!
ora degree
ora feature
ora big
ora file
ora pc
ora pc2
ora stats
ora tbs
ora tbsinc
ora rman
ora dg
ora lob
ora redo
ora temp
ora undo
exit 0
fi


################################################################################
if [ "$1" = "tabidx" ]; then

  if [ "$2" = "" ]; then
    echo "ora tabidx table_name"
    exit 1
  fi

  ver2=`get_ver 2`
  if [ $ver2 -lt 11 ]; then
    ver2='--'
  else
    ver2=''
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 150 pagesize 200
    col column_name format a30
    col table_owner format a20
    col table_name format a30
    col index_name format a30
    col partitioned format a11

    break on TABLE_OWNER skip 1


    Pro index info :

    select table_owner,table_name,index_name,status,partitioned,
        $ver2 visibility,
        index_type
    from dba_indexes
    where table_name=upper('$2')
    order by 1,2,3;
    $ECHO

     break on index_name skip 1
     Pro index columns :
    select table_owner,table_name,index_name,COLUMN_POSITION,column_name
    from dba_ind_columns
    where  table_name=upper('$2')
    order by 1,2,3,4;
    $ECHO


!
exit 0
fi

################################################################################
if [ "$1" = "event2sqlid" ]; then

  if [ "$2" = "" -o "$3" = "" -o "$4" = "" ]; then
    echo "ora event2sqlid event_name {bid} {eid}"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set feedback off

    select * from
    (
    select sql_id,count(*) as cnt
    from dba_hist_active_sess_history
    where event='$2' and snap_id >$3 and snap_id<=$4
    group by sql_id order by cnt desc
    ) where rownum<=5;
    $ECHO

!
echo "full nodes"
echo "usage: ora event2sqlid \"direct path read\" 8888 8890"
echo "then login sqlplus and run @cursor"
exit 0
fi

################################################################################
if [ "$1" = "gather" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "usage:ora gather owner table_name"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set feedback off

    exec dbms_stats.gather_table_stats('$2','$3',cascade=>true,no_invalidate=>false);

!
   echo "dbms_stats.gather_table_stats('$2','$3',cascade=>true,no_invalidate=>false); command executed"
exit 0
fi

################################################################################
if [ "$1" = "top" ]; then

    if [ "$2" = "" ]; then
      dur=10
    else
      dur=$2
    fi

    if [ "$3" = "" ]; then
      per_buffer_gets=10000
    else
      per_buffer_gets=$3
    fi

    if [ "$4" = "" ]; then
      execution=10
    else
      execution=$4
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set trimspool on
    spool ora_topash_$filedate.log
    prompt
    prompt Displays the latest $dur Minutes and More Than $per_buffer_gets logical_read/per ,Execution > $execution SQL
    prompt=========================
    set linesize 1000
    set pages 1000
    col username for a18
    col FIRST_LOAD_TIME for a16
    col LAST_LOAD_TIME for a15
    col LAST_ACTIVE_TIME for a16
    col last_day for 9999
    SELECT * FROM (SELECT
    A.PARSING_SCHEMA_NAME as username,
    A.SQL_ID,
    A.PLAN_HASH_VALUE AS PLAN_HASH,
    ROUND(A.BUFFER_GETS / EXECUTIONS) AS LOGICAL_READ,
    A.BUFFER_GETS,
    A.EXECUTIONS,
    (round(to_number(a.last_active_time-to_date(a.FIRST_LOAD_TIME,'yy-mm-dd/hh24:mi:ss')),0)+ 1) AS last_day,
    round(a.EXECUTIONS / (round(to_number(a.last_active_time-to_date(a.FIRST_LOAD_TIME,'yy-mm-dd/hh24:mi:ss')),0)+ 1)) AS exe_per_day,
    -- A.SQL_FULLTEXT AS SQL,
    to_char(to_date(a.FIRST_LOAD_TIME,'yy-mm-dd/hh24:mi:ss'),'yymmdd hh24:mi:ss') as first_load_time,
    to_char(A.LAST_LOAD_TIME,'yymmdd hh24:mi:ss') as LAST_LOAD_TIME,
    to_char(A.LAST_ACTIVE_TIME,'yymmdd hh24:mi:ss') as LAST_ACTIVE_TIME
    FROM v\$SQLAREA A,
       (SELECT DISTINCT SQL_ID, SQL_PLAN_HASH_VALUE
          FROM v\$ACTIVE_SESSION_HISTORY
         WHERE SAMPLE_TIME > sysdate-$dur/60/24) B
 WHERE A.SQL_ID = B.SQL_ID
   AND A.PLAN_HASH_VALUE = B.SQL_PLAN_HASH_VALUE
   AND A.BUFFER_GETS > 10000
   AND round(a.EXECUTIONS / (round(to_number(a.last_active_time-to_date(a.FIRST_LOAD_TIME,'yyyy-mm-dd/hh24:mi:ss')),0)+ 1)) > 1
   AND ROUND(A.BUFFER_GETS / EXECUTIONS) > $per_buffer_gets
 ORDER BY ROUND(A.BUFFER_GETS / EXECUTIONS) DESC,
	  round(a.EXECUTIONS / (round(to_number(a.last_active_time-to_date(a.FIRST_LOAD_TIME,'yyyy-mm-dd/hh24:mi:ss')),0)+ 1)) DESC
) WHERE EXE_PER_DAY > $execution;

    $ECHO
    spool off

!
echo "instance_number=$INST"
echo "Usage: ./ora topash [10]"
echo "Usage: ./ora -i 2 topash 10"
exit 0
fi

################################################################################
if [ "$1" = "idx2sqlid" ]; then

  if [ "$2" = "" ]; then
    echo "ora idx2sqlid index_name"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    col text_120 format a120


    Pro dba_hist_sql_plan and gv\$sql_plan*******************************:
    select sql_id,replace(replace(to_nchar(SUBSTR(sql_text,1,120)),chr(10),''),chr(13),'') as text_120
    from dba_hist_sqltext
    where sql_id in
    (
      select sql_id from dba_hist_sql_plan where object_name=upper('$2')
    )
    union
    select sql_id,replace(replace(to_nchar(SUBSTR(sql_text,1,120)),chr(10),''),chr(13),'') as text_120
    from gv\$sql
    where sql_id in
    (
      select sql_id from gv\$sql_plan where object_name=upper('$2')
    ) order by 1;
$ECHO

!
exit 0
fi

################################################################################
if [ "$1" = "ashdump" ]; then

  if [ "$2" = "" ]; then
     dur=1
  else
     dur=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    ALTER SYSTEM SET events 'immediate trace name ashdump level $dur';

    prompt "Trace file is :"
    col value format a100
    SELECT value FROM v\$diag_info WHERE name = 'Default Trace File';

!
echo "instance_number=$INST"
echo "dump ash records for recent $dur minutes."
exit 0
fi

################################################################################
if [ "$1" = "systemdump" -o "$1" = "hanganalyze" -o "$1" = "hang" ]; then
  echo ""
  echo "Collect systemtemp and hanganalyze!"
  echo "========================="
  # sqlplus -prelim / as sysdba
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    oradebug setmypid
    oradebug unlimit
    oradebug hanganalyze 3
    oradebug dump systemstate 266
    exec dbms_lock.sleep(30);
    oradebug hanganalyze 3
    oradebug dump systemstate 266
    oradebug tracefile_name
!
echo "on current instance"
echo "risk operation,commented! If need , uncomment"
exit 0
fi

################################################################################
if [ "$1" = "outline" ]; then

  if [ "$2" = "" -o "$3" = ""  ]; then
    echo "ora outline {profile|patch} {name}"
    exit 1
  fi

  name=$3
  if [ "$2" = "profile" ]; then
    vname=dba_sql_profiles
    type=1
  else
    vname=dba_sql_patches
    type=3
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    col name format a30
    col outline_hints format a80

    select name, hint as outline_hints
    from (select p.name, p.signature, p.category, row_number()
          over (partition by sd.signature, sd.category order by sd.signature) row_num,
          extractValue(value(t), '/hint') hint
    from sys.sqlobj\$data sd, $vname p,
         table(xmlsequence(extract(xmltype(sd.comp_data),
                                '/outline_data/hint'))) t
    where sd.obj_type = $type
    and p.signature = sd.signature
    and p.category = sd.category
    and p.name='$name'
    )
    order by row_num;
    $ECHO


    --select name,hint as outline_hints
    --from (select p.name, p.signature, p.category, row_number()
    --      over (partition by sd.signature, sd.category order by sd.signature) row_num,
    --      extractValue(value(t), '/hint') hint
    --from sys.sqlobj$data sd, dba_sql_profiles p,
    --     table(xmlsequence(extract(xmltype(sd.comp_data), '/outline_data/hint'))) t
    --where sd.obj_type = 1
    --and p.signature = sd.signature
    --and p.category = sd.category
    --and p.name = ('$name'))
    --order by row_num;

    --sql plan baseline:
    --select plan_name,plan_id,row_num,hint as outline_hints
    --from (select p.plan_name, p.signature, plan_id,row_number()
    --      over (partition by sd.signature,plan_id order by sd.signature) row_num,
    --      extractValue(value(t), '/hint') hint
    --from sys.sqlobj$data sd, dba_sql_plan_baselines p,
    --     table(xmlsequence(extract(xmltype(sd.comp_data), '/outline_data/hint'))) t
    --where sd.obj_type = 2
    --and p.signature = sd.signature
    --and p.plan_name = ('&name'))
    --order by plan_id,row_num;

!
echo "show outline hint for given sql profile or sql patch name".
exit 0
fi


################################################################################
if [ "$1" = "top_level" ]; then

  if [ "$2" = "" ]; then
    echo "ora top_level [sqlid of plsql] <bid> <eid>"
    exit 1
  fi

    if [ "$3" = "" -o "$4" = "" ]; then
    echo "ora top_level [sqlid] <begin_snapid> <end_snapid> (default is last two snap) "
    bid="(select max(snap_id)-1 from dba_hist_snapshot)"
    eid="(select max(snap_id)   from dba_hist_snapshot)"
   else
    bid=$3
    eid=$4
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    set linesize 200 pagesize 100
    select sql_id,
    count(distinct SQL_PLAN_HASH_VALUE) as phv_cnt,
    --sum(TIME_WAITED) as ,
    --sum(TM_DELTA_TIME),
    round(sum(TM_DELTA_DB_TIME)/1e6) as db_time,
    round(sum(TM_DELTA_CPU_TIME)/1e6) as cpu_time,
    round(sum(DELTA_READ_IO_REQUESTS)/1e3) as read_IO_requsts_k
    --round(sum(DELTA_TIME)
    from dba_hist_active_sess_history
    where TOP_LEVEL_SQL_ID='$2'
    --and sample_time between trunc(sysdate-1) and trunc(sysdate)
    and snap_id >=$bid and snap_id <=$eid
    and sql_id<>'$2'
    group by sql_id
    order by cpu_time;
    $ECHO

!
exit 0
fi



################################################################################
if [ "$1" = "high_version" ]; then
#usage ora high_version 100
  if [ "$2" = "" ]; then
    cnt=100
  else
    cnt=$2
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    Pro Group by sql_id (having count(*)>$cnt):
    select sql_id, count(*) reasons_not_cursors
    from gv\$sql_shared_cursor
     unpivot --column to row
     (val for reason_not_shared in( --68 items 12.2
      UNBOUND_CURSOR,SQL_TYPE_MISMATCH,OPTIMIZER_MISMATCH,OUTLINE_MISMATCH,
      STATS_ROW_MISMATCH,LITERAL_MISMATCH,FORCE_HARD_PARSE,EXPLAIN_PLAN_CURSOR,
      BUFFERED_DML_MISMATCH,PDML_ENV_MISMATCH,INST_DRTLD_MISMATCH,SLAVE_QC_MISMATCH,
      TYPECHECK_MISMATCH,AUTH_CHECK_MISMATCH,BIND_MISMATCH,DESCRIBE_MISMATCH,
      LANGUAGE_MISMATCH,TRANSLATION_MISMATCH,BIND_EQUIV_FAILURE,INSUFF_PRIVS,
      INSUFF_PRIVS_REM,REMOTE_TRANS_MISMATCH,LOGMINER_SESSION_MISMATCH,INCOMP_LTRL_MISMATCH,
      OVERLAP_TIME_MISMATCH,EDITION_MISMATCH,MV_QUERY_GEN_MISMATCH,USER_BIND_PEEK_MISMATCH,
      TYPCHK_DEP_MISMATCH,NO_TRIGGER_MISMATCH,FLASHBACK_CURSOR,ANYDATA_TRANSFORMATION,
      PDDL_ENV_MISMATCH,TOP_LEVEL_RPI_CURSOR,DIFFERENT_LONG_LENGTH,LOGICAL_STANDBY_APPLY,
      DIFF_CALL_DURN,BIND_UACS_DIFF,PLSQL_CMP_SWITCHS_DIFF,CURSOR_PARTS_MISMATCH,
      STB_OBJECT_MISMATCH,CROSSEDITION_TRIGGER_MISMATCH,PQ_SLAVE_MISMATCH,TOP_LEVEL_DDL_MISMATCH,
      MULTI_PX_MISMATCH,BIND_PEEKED_PQ_MISMATCH,MV_REWRITE_MISMATCH,ROLL_INVALID_MISMATCH,
      OPTIMIZER_MODE_MISMATCH,PX_MISMATCH,MV_STALEOBJ_MISMATCH,FLASHBACK_TABLE_MISMATCH,
      LITREP_COMP_MISMATCH,PLSQL_DEBUG,LOAD_OPTIMIZER_STATS,ACL_MISMATCH,
      FLASHBACK_ARCHIVE_MISMATCH,LOCK_USER_SCHEMA_FAILED,REMOTE_MAPPING_MISMATCH,LOAD_RUNTIME_HEAP_FAILED,
      HASH_MATCH_FAILED,PURGED_CURSOR,BIND_LENGTH_UPGRADEABLE,USE_FEEDBACK_STATS)
    )
    where val = 'Y' and inst_id=$INST
    group by sql_id having count(*)>=$cnt
    order by 2 desc;
    $ECHO

!
echo "instance_number=$INST"
echo "display information for reasons cursor not shared more than $cnt."
exit 0
fi



################################################################################
if [ "$1" = "feature" -o  "$1" = "features" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col table_name format a30
    col table_owner format a30 trunc

    spool ora_feature_$filedate.log

    prompt =========================================================================================
    prompt "V\$DATABASE:"
    prompt =========================================================================================
    col F_LOG format a5
    col DB_UNIQUE_NAME format a10 trunc
    col DB_ROLE format a10
    col FLASHB_ON format a10
    col OPEN_MODE format a10
    col PROT_MODE format a20
    select DB_UNIQUE_NAME,DATABASE_ROLE DB_ROLE,FORCE_LOGGING F_LOG
          ,FLASHBACK_ON FLASHB_ON,LOG_MODE,OPEN_MODE,
          GUARD_STATUS GUARD,PROTECTION_MODE PROT_MODE
    from v\$database;


    pro
    pro
    prompt =========================================================================================
    prompt "CHARACTERSET:"
    prompt =========================================================================================
    col value format a30
    select value\$ as value from sys.props\$ where name='NLS_CHARACTERSET';

    pro
    pro
    prompt =========================================================================================
    prompt "All DB links:"
    prompt =========================================================================================
    col owner format a20
    col db_link format a30
    col username format a20
    col host format a50
    select owner,db_link,username,host from dba_db_links;
    $ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "Trigger(+sys +system, -other xxSYS users) by owner and event:"
    prompt =========================================================================================
    col TRIGGERING_EVENT format a40

    select owner,triggering_event,count(*)
    from dba_triggers
    where owner not in ('EXFSYS','MDSYS','OLAPSYS','WMSYS','SYSMAN','XDB')
    group by owner,triggering_event
    order by 1;
    $ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "Compressed Tables ,table partitions and table subpartitions count:"
    prompt =========================================================================================
    --select * from
    --(
    select owner,'NORMAL' as table_type,count(*) from dba_tables where compression='ENABLED' group by owner order by 3;
    --union
    select table_owner,'PARTITION',count(*)  from dba_tab_partitions where compression='ENABLED' group by table_owner order by 3;
    --union
    select table_owner,'SUBPARTITION',count(*) from dba_tab_subpartitions where compression='ENABLED' group by table_owner order by 3;
    --)
    --order by owner,table_name;
    --$ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "partitions(no sys) by owner,table_name(top partitions 5 by owner):"
    prompt =========================================================================================
    with tmp as
    (
    select table_owner,table_name,count(*)  partition_cnt
    from dba_tab_partitions where table_owner not in('SYS','SYSTEM')
    group by table_owner,table_name
    )
    select table_owner,table_name, partition_cnt from
    (select t.*,row_number() over (partition by table_owner order by partition_cnt desc ) as rn
      from tmp t)
     where rn<=5
    order by 1,3 desc;
    $ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "subpartitions(no sys) by owner,table_name:"
    prompt =========================================================================================
    select table_owner,table_name,count(*) sub_partition_cnt
    from dba_tab_subpartitions where table_owner not in('SYS','SYSTEM')
    group by table_owner,table_name
    order by 1,3;
    $ECHO



    pro
    pro
    prompt =========================================================================================
    Prompt "all sql patches:"
    prompt =========================================================================================
    col description format a40
    col name format a30
    col created format a19
    col sql_text format a30 trunc
    col status format a8
    col DESCRIPTION format a20 trunc
    set linesize 200
    select name,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
    ,status,force_matching,description,substr(sql_text,1,30)  as sql_text
    from dba_sql_patches
    order by created;
    $EChO

    pro
    pro
    prompt =========================================================================================
    Prompt "sql profiles(recent created 20):"
    prompt =========================================================================================
    col signature format a20
    col created format a19
    col name format a30
    col sql_text format a20 trunc
    select * from
    (
    select  name ,to_char(signature) as signature
          ,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
          ,substr(sql_text,1,20) as sql_text
          ,status,force_matching
    from DBA_SQL_profiles
    order by created desc)
    where rownum<=20;
    $ECHO


    pro
    pro
    prompt =========================================================================================
    Prompt "sql plan baselines(recent created 20):"
    prompt =========================================================================================
    col signature format a20
    col parse_name format a10 trunc
    col plan_name format a30
    col origin format a20 trunc
    col created format a19
    --col sql_text format a30 trunc
    select * from
    (
    select parsing_schema_name as parse_name,plan_name,to_char(signature) as signature
          ,origin
          ,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
          ,substr(sql_text,1,20) as sql_text
          ,enabled,accepted,fixed
    from DBA_SQL_PLAN_BASELINES
    order by created desc)
    where rownum<=20
    order by parse_name;
    $ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "materialized views by owner:"
    prompt =========================================================================================
    col MVIEW_NAME format a30
    col STALENESS format a10
    select owner,mview_name,refresh_mode,last_refresh_date,staleness
    from dba_mviews
    order by owner;
    $ECHO


    pro
    pro
    prompt =========================================================================================
    Prompt "index type summary(no sys users,not normal) by owner:"
    prompt =========================================================================================
    select owner,
    index_type,count(*)
    from dba_indexes
    where owner not in ('SYS','EXFSYS','CTXSYS','WMSYS','MDSYS','DBSNMP','SYSMAN','SYSTEM','ORDSYS','OLAPSYS','XDB','OUTLN','ORDDATA')
    and owner not like 'APEX%'
    and index_type <>'NORMAL'
    group by  index_type,owner
    order by owner;
    $ECHO

    pro
    pro
    prompt =========================================================================================
    Prompt "table type summary(no sys users):"
    prompt =========================================================================================
    select sum(case when logging='NO' then 1 else 0 end) as nologging_cnt
          ,sum(case when iot_type like 'IOT%' then 1 else 0 end) as IOT_cnt
          ,sum(case when temporary ='Y' then 1 else 0 end) as temporary_cnt
          ,sum(case when compression ='ENABLED' then 1 else 0 end) as Normal_compressed_cnt
          ,sum(case when Partitioned ='YES' then 1 else 0 end) as partitioned_cnt
          --,sum(case when  ='ENABLED' then 1 else 0 end) as xxx_cnt
       from dba_tables
       where owner not in ('SYS','EXFSYS','CTXSYS','WMSYS','MDSYS','DBSNMP','SYSMAN','SYSTEM','ORDSYS','OLAPSYS','XDB');

    pro
    pro
    prompt =========================================================================================
    Prompt "external tables by owner:"
    prompt =========================================================================================
    SELECT owner ,count(*)
    FROM dba_external_tables
    group by owner
    order by 1,2;
    $ECHO
    spool off

!
exit 0
fi


################################################################################
if [ "$1" = "raw" ]; then

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora raw number C30F5544 / ora raw date 78660A010D2A32 / ora raw varchar2 415045585F303530313030"
    exit 1
  fi

  if [ "$2" = "varchar2" ]; then
    dtype="varchar2(100)"
  else
    dtype=$2
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set serveroutput on feedback off

    declare
    v_ret $dtype;
    v_result varchar2(100);
    begin
         dbms_stats.convert_raw_value('$3',v_ret);
         select
         case when '$dtype'='date' then to_char(v_ret,'yyyy-mm-dd hh24:mi:ss')
              when '$dtype'='varchar2(100)' then to_char(v_ret)
              when '$dtype'='number' then to_char(v_ret) end into v_result
         from dual;
         dbms_output.put_line('raw data $3 convert to $dtype is: '||v_result);
    end;
    /
!
exit 0
fi

##new add method 03:
################################################################################
if [ "$1" = "sql_patch" ]; then

   if [ "$2" = "" ]; then
      sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col name format a30
    col created format a20
    col description format a40
    col sql_text format a50 trunc
    select * from (select NAME,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss'),STATUS,FORCE_MATCHING, DESCRIPTION,SQL_TEXT
    from dba_sql_patches order by created desc) where rownum<=20;
!
    echo "ora sql_patch sql_id [monitor|bind_aware]"
    echo "ora sql_patch sql_id \"opt_param('_fix_control' '13345888:off')\""
    echo "ora sql_patch 0wqx6mfuhashb \"opt_param('_optimizer_use_feedback','false')\""
    echo "ora sql_patch <sql_id> \"parallel(4)\""
    exit 1
  fi

  if [ "$2" = "" -o "$3" = "" ]; then
    echo "ora sql_patch sql_id [monitor|bind_aware]"
    exit 1
  fi

     version=`echo "select 12345||trim(version) as ver from PRODUCT_COMPONENT_VERSION where product like 'Oracle%';" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
     v2=`echo $version|cut -c 1-2`
     v4=`echo $version|cut -c 1-4`


   if [ "$v2" = "11" -o  "$v4" = "12.1" ]; then
  # echo $3
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

SET DEF ON TERM OFF ECHO ON FEED OFF VER OFF HEA ON LIN 2000 PAGES 100 LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUMF "" SQLP SQL>;
SET SERVEROUT ON SIZE UNL;
SET TERM ON ECHO OFF;

DEF sql_id_1 = '$2';

--DEF hint_text = '$3';

--pro &&hint_text

--SET TERM OFF ECHO ON;
--SELECT TRIM(NVL(REPLACE('hint_text_2.', '"', ''''''), 'def_hint_text.')) hint_text FROM dual;
--WHENEVER SQLERROR EXIT SQL.SQLCODE;

-- trim sql_id parameter
COL sql_id NEW_V sql_id FOR A30;
SELECT TRIM('&&sql_id_1.') sql_id FROM DUAL;

VAR sql_text CLOB;
VAR sql_text2 CLOB;
EXEC :sql_text := NULL;
EXEC :sql_text2 := NULL;

pro get sql_text from memory
DECLARE
  l_sql_text VARCHAR2(32767);
BEGIN -- 10g see bug 5017909
  FOR i IN (SELECT DISTINCT piece, sql_text
              FROM gv\$sqltext_with_newlines
             WHERE sql_id = TRIM('&&sql_id.')
             ORDER BY 1, 2
            )
  LOOP
    IF :sql_text IS NULL THEN
      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    END IF;
    l_sql_text := REPLACE(i.sql_text, CHR(00), ' '); -- removes NUL characters
    DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
  END LOOP;
  -- if found in memory then sql_text is not null
  IF :sql_text IS NOT NULL THEN
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

col sql_text format a80
SELECT :sql_text as sql_text FROM DUAL;

-- get sql_text2 from awr(in case of sql not in memory)
DECLARE
  l_sql_text VARCHAR2(32767);
  l_clob_size NUMBER;
  l_offset NUMBER;
BEGIN
  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
    SELECT sql_text
      INTO :sql_text2
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&&sql_id.')
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
  -- if found in awr then sql_text2 is not null
  IF :sql_text2 IS NOT NULL THEN
    l_clob_size := NVL(DBMS_LOB.GETLENGTH(:sql_text2), 0);
    l_offset := 1;
    DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
    DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    -- store in clob as 64 character pieces
    WHILE l_offset < l_clob_size
    LOOP
      IF l_clob_size - l_offset > 64 THEN
        l_sql_text := REPLACE(DBMS_LOB.SUBSTR(:sql_text2, 64, l_offset), CHR(00), ' ');
      ELSE -- last piece
        l_sql_text := REPLACE(DBMS_LOB.SUBSTR(:sql_text2, l_clob_size - l_offset + 1, l_offset), CHR(00), ' ');
      END IF;
      DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
      l_offset := l_offset + 64;
    END LOOP;
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

col sql_text_awr format a100
SELECT :sql_text2 as sql_text_awr FROM DUAL;


-- validate sql_text
BEGIN
  IF :sql_text IS NULL THEN
    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for SQL_ID &&sql_id. was not found in memory (gv\$sqltext_with_newlines) or AWR (dba_hist_sqltext).');
  END IF;
END;
/

PRO generate SQL Patch for SQL "&&sql_id." with CBO Hints : $3


-- create SQL Patch
PRO you have to connect as SYS
BEGIN
  SYS.DBMS_SQLDIAG_INTERNAL.I_CREATE_PATCH (
    sql_text    => :sql_text,
    hint_text   => q'[ $3]',
    name        => 'coe_&&sql_id.',
    category    => 'DEFAULT',
    description => q'[/*+ $3 */]'
  );
END;
/

col description format a40
col name format a30
set linesize 200
select name,to_char(created,'yyyy-mm-dd hh24:mi:ss') as created
,status,force_matching,description,substr(sql_text,1,50)  as sql_text
from dba_sql_patches
order by created;

WHENEVER SQLERROR CONTINUE;

PRO coe_gen_sql_patch completed.

!
fi

## for version 12.2+
if [ "$v4" = "12.2" -o  "$v2" = "18" -o "$v2" = "19" ]; then
    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    declare patch_name varchar2(30);
begin
patch_name := dbms_sqldiag.create_sql_patch(
     sql_id=>'$2',
     hint_text=>' $3 ');
end;
/
!
fi
echo ora sql_patch sql_id  hint_info
exit 0
fi


################################################################################
if [ "$1" = "sqlhc" ]; then

  if [ "$2" = "" ]; then
    echo "ora sqlhc <sqlid1> <sqlid2>..."
    exit 1
  fi

  if [ ! -e ora_sqlhc.sql ]; then
   echo "file ora_sqlhc.sql is missing!"
   exit 1
  fi

  shift
  for sqlid in $@
  do

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    prompt generate sqlhc for sql_id : $sqlid...........................
    @ora_sqlhc T $sqlid
    --prompt @sqlhc T $sqlid

!
done
echo "need ora_sqlhc.sql in the curret directory!"
exit 0
fi

#####################################################################################################

if [ "$1" = "tophis" ]; then

   if [ "$2" = "" -o "$2" = "cpu" -o "$2" = "CPU" ]; then
       orderby=cpu_s
   elif [ "$2" = "read" ]; then
       orderby=reads_k
   elif [ "$2" = "time" ]; then
       orderby=etime_s
   fi

   if [ "$3" = "" -o "$4" = "" ]; then
       defeid=`echo "select trim(12345||max(snap_id)) as eid from dba_hist_snapshot ;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
       let defbid=defeid-1
       read -p "Please input begin snap_id[$defbid]:" bid
        if [ -z "${bid}" ];then
             bid=$defbid
        fi
       read -p "Please input end   snap_id[$defeid]:" eid
        if [ -z "${eid}" ];then
             eid=$defeid
        fi

       if [ ${bid} -ge ${eid} ];then
          echo begin_snap_id:$bid end_snap_id:$eid  input error!
          exit 1
       fi
       else
        bid=$3
        eid=$4
   fi

   if [ "$5" = "" ]; then
     deftopn=50
     read -p "Please input top sql count[$deftopn]:" topn
        if [ -z "${topn}" ];then
             topn=$deftopn
        fi
     else
      topn=$5
   fi


### if [ "$3" = "" -o "$4" = "" ]; then
###  echo "ora tophis cpu|read|time [begin_snapid] [end_snapid](default is last two snap) "
###  bid="(select max(snap_id)-1 from dba_hist_snapshot)"
###  eid="(select max(snap_id)   from dba_hist_snapshot)"
### else
###  bid=$3
###  eid=$4
### fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set linesize 200 pagesize 30
    set tab off
    col rn format 999
    col min_schema format a10 trunc
    col sqltext format a30 trunc
    col sql_id format a14
    col plans format 99
    col app_s format 999
    col conc_s format 9999
    col clu_s format 9999
    col plsql_s format 99999
    col sorts format 999999
    set trimspool on
    spool ora_tophis_${INST}_${bid}_${eid}_${orderby}.log

    with sql_stat as
    (
     select rownum as RN,v.* from
      (select
          round(sum(cpu_time_delta)/1e6)  as CPU_S,
          round(sum(DISK_READS_DELTA)/1000)  as reads_k,
          sql_id,
          round(sum(ELAPSED_TIME_DELTA)/1e6)  as etime_s,
          case when sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1) >=1
               then round(sum(ELAPSED_TIME_DELTA)/1e3/greatest(sum(executions_delta),1))
               else  1  end as avg_elap_ms,
          min(PARSING_SCHEMA_NAME) as min_schema,
          sum(executions_delta) as execs,
          count(distinct plan_hash_value) as  plans,
          --max(plan_hash_value) as phv,
          round(sum(BUFFER_GETS_DELTA)/greatest(sum(executions_delta),1))  as avg_BUF,
          round(sum(ROWS_PROCESSED_DELTA)/greatest(sum(executions_delta),1),1)  as avg_ROW
          --substr(min(MODULE),1,10) as module,
          --round(sum(IOWAIT_DELTA)/1e6)  as sum_IO_s,
    $DEFNODISP ,round(sum(APWAIT_DELTA)/1e6)  as App_s
    $DEFNODISP ,round(sum(CCWAIT_DELTA)/1e6)  as ConC_s
    $DEFNODISP ,round(sum(CLWAIT_DELTA)/1e6)  as CLu_s
    $DEFNODISP ,round(sum(PLSEXEC_TIME_DELTA)/1e6)  as PLSQL_s
          --round(sum(JAVEXEC_TIME_DELTA)/1e6)  as sum_JAVA_s,
          --round(sum(DIRECT_WRITES_DELTA))  as sum_DIRECT_W,
          --round(sum(PHYSICAL_READ_REQUESTS_DELTA))  as sum_PHY_R_Req,---not support in 10g
          --round(sum(PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
          --round(sum(PHYSICAL_WRITE_REQUESTS_DELTA))  as sum_PHY_W_Req,--not support in 10g
          --round(sum(PX_SERVERS_EXECS_DELTA))  as sum_PX_Svr,
    $DEFNODISP ,round(sum(SORTS_DELTA))  as SORTS
           from dba_hist_sqlstat a
           where snap_id > $bid
             and snap_id <=$eid--(select max(snap_id)   from dba_hist_snapshot)
             and INSTANCE_NUMBER=$INST
          group by sql_id
          order by $orderby desc
      ) v where rownum<=$topn
    )
    select ltrim(nvl( b.sql_text, (' ** SQL Text Not Available ** '))) SqlText
           ,a.*
    from sql_stat a,(select distinct sql_id,replace(replace(to_nchar(SUBSTR(sql_text,1,50)),chr(10),''),chr(13),'') as sql_text
                     from dba_hist_sqltext) b
    where a.sql_id=b.sql_id
    order by rn;
    $ECHO

    --select max(snap_id) as max_snap_id  from dba_hist_snapshot;
    spool off
!
echo "usage: ora tophis [cpu]|<read>|<time> bid eid"
echo "Get top sql ,ordered by $orderby . Begin snap_id=$bid ; End snap_id=$eid "
echo "instance_number=$INST"
exit 0
fi



################################################################################################################
if [ "$1" = "purge" ]; then

  if [ "$2" = "" ]; then
    echo "ora purge <sqlid>"
    exit 1
  fi

  sqlid=$2

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    set verify off

    PRO *** before flush ***
    SELECT inst_id, loaded_versions, invalidations, address, hash_value
    FROM gv\$sqlarea WHERE sql_id = '$sqlid' ORDER BY 1;

    SELECT inst_id, child_number, plan_hash_value, executions, is_shareable
    FROM gv\$sql WHERE sql_id = '$sqlid' ORDER BY 1, 2;

    BEGIN
      FOR i IN (SELECT address, hash_value
                  FROM gv\$sqlarea WHERE sql_id = '$sqlid')
      LOOP
        SYS.DBMS_SHARED_POOL.UNKEEP(name => i.address||','||i.hash_value, flag => 'C');
        SYS.DBMS_SHARED_POOL.PURGE(name => i.address||','||i.hash_value, flag => 'C');
      END LOOP;
    END;
    /

    PRO *** after flush ***
    SELECT inst_id, loaded_versions, invalidations, address, hash_value
    FROM gv\$sqlarea WHERE sql_id = '$sqlid' ORDER BY 1;

    SELECT inst_id, child_number, plan_hash_value, executions, is_shareable
    FROM gv\$sql WHERE sql_id = '$sqlid' ORDER BY 1, 2;

!
echo "instance_number=$INST"
exit 0
fi

################################################################################
if [ "$1" = "sql_profile" -o "$1" = "coe_profile" -o "$1" = "coe" ]; then

     if [ "$2" = "" ]; then
      sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col name format a30
    col created format a20
    col description format a40
    col sql_text format a50 trunc
    select * from
    (select NAME,to_char(CREATED,'yyyy-mm-dd hh24:mi:ss') as created
            ,STATUS,FORCE_MATCHING, DESCRIPTION,SQL_TEXT
           from dba_sql_profiles order by created desc
     ) where rownum<=20;
!
    echo "ora sql_profile sql_id_1 sql_id_2 phv"
    exit 1
  fi

  if [ "$2" = "" -o  "$3" = "" -o "$4" = "" ]; then
    echo "ora sql_profile sql_id_1 sql_id_2 phv"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


SET DEF ON TERM OFF ECHO ON FEED OFF VER OFF HEA ON LIN 2000 PAGES 100
set LONG 8000000 LONGC 800000 TRIMS ON TI OFF TIMI OFF SERVEROUT ON SIZE 1000000 NUM 20 SQLP SQL>;
SET SERVEROUT ON SIZE UNL;
SET TERM ON ECHO OFF;
DEF original_sql_id = '$2'
DEF modified_sql_id = '$3';

WITH
p AS (
SELECT plan_hash_value
  FROM gv\$sql_plan
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND other_xml IS NOT NULL
 UNION
SELECT plan_hash_value
  FROM dba_hist_sql_plan
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND other_xml IS NOT NULL ),
m AS (
SELECT plan_hash_value,
       SUM(elapsed_time)/SUM(executions) avg_et_secs
  FROM gv\$sql
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND executions > 0
 GROUP BY
       plan_hash_value ),
a AS (
SELECT plan_hash_value,
       SUM(elapsed_time_total)/SUM(executions_total) avg_et_secs
  FROM dba_hist_sqlstat
 WHERE sql_id = TRIM('&&modified_sql_id.')
   AND executions_total > 0
 GROUP BY
       plan_hash_value )
SELECT p.plan_hash_value,
       ROUND(NVL(m.avg_et_secs, a.avg_et_secs)/1e6, 3) avg_et_secs
  FROM p, m, a
 WHERE p.plan_hash_value = m.plan_hash_value(+)
   AND p.plan_hash_value = a.plan_hash_value(+)
 ORDER BY
       avg_et_secs NULLS LAST;

DEF plan_hash_value = '$4';

WHENEVER SQLERROR EXIT SQL.SQLCODE;
SET TERM OFF ECHO ON;

-- trim parameters
COL original_sql_id NEW_V original_sql_id FOR A30;
COL modified_sql_id NEW_V modified_sql_id FOR A30;
COL plan_hash_value NEW_V plan_hash_value FOR A30;
SELECT TRIM('&&original_sql_id.') original_sql_id, TRIM('&&modified_sql_id.') modified_sql_id,
TRIM('&&plan_hash_value.') plan_hash_value FROM DUAL;

-- open log file
--SPO coe_load_sql_profile_&&original_sql_id..log;
--GET coe_load_sql_profile.log;
--.

-- get user
COL connected_user NEW_V connected_user FOR A30;
SELECT USER connected_user FROM DUAL;

VAR sql_text CLOB;
VAR other_xml CLOB;
VAR signature NUMBER;
VAR name VARCHAR2(30);

EXEC :sql_text := NULL;
EXEC :other_xml := NULL;
EXEC :signature := NULL;
EXEC :name := NULL;

-- get sql_text from memory
DECLARE
  l_sql_text VARCHAR2(32767);
BEGIN -- 10g see bug 5017909
  FOR i IN (SELECT DISTINCT piece, sql_text
              FROM gv\$sqltext_with_newlines
             WHERE sql_id = TRIM('&&original_sql_id.')
             ORDER BY 1, 2)
  LOOP
    IF :sql_text IS NULL THEN
      DBMS_LOB.CREATETEMPORARY(:sql_text, TRUE);
      DBMS_LOB.OPEN(:sql_text, DBMS_LOB.LOB_READWRITE);
    END IF;
    l_sql_text := REPLACE(i.sql_text, CHR(00), ' ');
    DBMS_LOB.WRITEAPPEND(:sql_text, LENGTH(l_sql_text), l_sql_text);
  END LOOP;
  IF :sql_text IS NOT NULL THEN
    DBMS_LOB.CLOSE(:sql_text);
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from memory: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- get sql_text from awr
BEGIN
  IF :sql_text IS NULL OR NVL(DBMS_LOB.GETLENGTH(:sql_text), 0) = 0 THEN
    SELECT REPLACE(sql_text, CHR(00), ' ')
      INTO :sql_text
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&&original_sql_id.')
       AND sql_text IS NOT NULL
       AND ROWNUM = 1;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting original sql_text from awr: '||SQLERRM);
    :sql_text := NULL;
END;
/

-- sql_text as found
col sql_text format a150
SELECT :sql_text as sql_text FROM DUAL;

-- check is sql_text for original sql is available
SET TERM ON;
BEGIN
  IF :sql_text IS NULL THEN
    RAISE_APPLICATION_ERROR(-20100, 'SQL_TEXT for original SQL_ID &&original_sql_id. was not found in memory (gv\$sqltext_with_newlines) or AWR (dba_hist_sqltext).');
  END IF;
END;
/
SET TERM OFF;

-- get other_xml from memory
BEGIN
  FOR i IN (SELECT other_xml
              FROM gv\$sql_plan
             WHERE sql_id = TRIM('&&modified_sql_id.')
               AND plan_hash_value = TO_NUMBER(TRIM('&&plan_hash_value.'))
               AND other_xml IS NOT NULL
             ORDER BY
                   child_number, id)
  LOOP
    :other_xml := i.other_xml;
    EXIT; -- 1st
  END LOOP;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting modified other_xml from memory: '||SQLERRM);
    :other_xml := NULL;
END;
/

-- get other_xml from awr
BEGIN
  IF :other_xml IS NULL OR NVL(DBMS_LOB.GETLENGTH(:other_xml), 0) = 0 THEN
    FOR i IN (SELECT other_xml
                FROM dba_hist_sql_plan
               WHERE sql_id = TRIM('&&modified_sql_id.')
                 AND plan_hash_value = TO_NUMBER(TRIM('&&plan_hash_value.'))
                 AND other_xml IS NOT NULL
               ORDER BY
                     id)
    LOOP
      :other_xml := i.other_xml;
      EXIT; -- 1st
    END LOOP;
  END IF;
EXCEPTION
  WHEN OTHERS THEN
    DBMS_OUTPUT.PUT_LINE('getting modified other_xml from awr: '||SQLERRM);
    :other_xml := NULL;
END;
/

-- other_xml as found
col other_xml format a150
SELECT :other_xml as other_xml FROM DUAL;

-- validate other_xml
SET TERM ON;
BEGIN
  IF :other_xml IS NULL THEN
    RAISE_APPLICATION_ERROR(-20101, 'PLAN for modified SQL_ID &&modified_sql_id. and PHV &&plan_hash_value. was not found in memory (gv\$sql_plan) or AWR (dba_hist_sql_plan).');
  END IF;
END;
/

SET ECHO OFF;
DECLARE
  h SYS.SQLPROF_ATTR := SYS.SQLPROF_ATTR ();
  idx INTEGER := 0;
  l_pos NUMBER;
  l_hint VARCHAR2(32767);
  description VARCHAR2(500);

  PROCEDURE add_hint (p_hint IN VARCHAR2)
  IS
  BEGIN
    idx := idx + 1;
    DBMS_OUTPUT.PUT_LINE(LPAD(idx, 4, '0')||' '||p_hint);
    h.EXTEND;
    h(idx) := p_hint;
  END add_hint;

BEGIN
  add_hint('BEGIN_OUTLINE_DATA');
  FOR i IN (SELECT /*+ opt_param('parallel_execution_enabled', 'false') */
                   SUBSTR(EXTRACTVALUE(VALUE(d), '/hint'), 1, 4000) hint
              FROM TABLE(XMLSEQUENCE(EXTRACT(XMLTYPE(:other_xml), '/*/outline_data/hint'))) d)
  LOOP
    l_hint := i.hint;
    WHILE NVL(LENGTH(l_hint), 0) > 0
    LOOP
      IF LENGTH(l_hint) <= 500 THEN
        add_hint(l_hint);
        l_hint := NULL;
      ELSE
        l_pos := INSTR(SUBSTR(l_hint, 1, 500), ' ', -1);
        add_hint(SUBSTR(l_hint, 1, l_pos));
        l_hint := '   '||SUBSTR(l_hint, l_pos);
      END IF;
    END LOOP;
  END LOOP;
  add_hint('END_OUTLINE_DATA');

  :signature := DBMS_SQLTUNE.SQLTEXT_TO_SIGNATURE(:sql_text);
  :name := UPPER(TRIM('&&original_sql_id.'))||'_'||TRIM('&&plan_hash_value.');
  description := UPPER('original:'||TRIM('&&original_sql_id.')||' modified:'||TRIM('&&modified_sql_id.')||' phv:'||TRIM('&&plan_hash_value.')||' signature:'||:signature||' created by coe_load_sql_profile.sql');

  -- create custom sql profile for original sql using plan from modified sql
  DBMS_SQLTUNE.IMPORT_SQL_PROFILE (
    sql_text    => :sql_text, -- original sql
    profile     => h, -- plan from modified sql
    name        => :name,
    description => description,
    category    => 'DEFAULT',
    validate    => TRUE,
    replace     => TRUE,
    force_match => TRUE /* TRUE:FORCE (match even when different literals in SQL). FALSE:EXACT (similar to CURSOR_SHARING) */
    );

END;
/
    -- profile_name
    COL profile_name NEW_V profile_name FOR A30;
    SELECT :name profile_name FROM DUAL;


    SELECT signature, name, category, type, status,force_matching
      FROM dba_sql_profiles WHERE name = :name;

    col description format a130
    SELECT description
      FROM dba_sql_profiles WHERE name = :name;

!
exit 0
fi


################################################################################
if [ "$1" = "dbtime" -o "$1" = "db_time" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    set verify off

    pro db time by day:
    define statname='DB time'
    set linesize 200 pagesize 1000
    set trims on
    set trimspool on
    spool ora_dbtime_$filedate.log

    with stat_time as
    (   select instance_number,begin_snap_id, end_snap_id,
        snap_begin_time, snap_end_time,
        round(interval_min) as interval_min,
        round(lag_value/60/1000000) as stat_time_min ,
        round(lag_value/60/1000000/interval_min) as stat_time_per_sec
        from
        (
        select sp.instance_number,
        sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
        sp.snap_id   as end_snap_id,   to_char(end_interval_time-1/24/60,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, --1 minute ahead for 00:00:xx,it belongs to prev day
        (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
        value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
        sy.stat_name
        from dba_hist_snapshot sp, dba_hist_sys_time_model sy
        where sp.snap_id=sy.snap_id
          and sp.instance_number=sy.instance_number
          and sy.stat_name='&statname'
        ) where   nvl(lag_value,0)>0
    )
select instance_number,substr(snap_end_time,1,10) as stat_time_day,sum(stat_time_min) as total_dbtime_day
from stat_time group by instance_number,substr(snap_end_time,1,10)
order by stat_time_day desc;
$ECHO

Pro top 20 dbtime :
with stat_time as
(
select instance_number,begin_snap_id, end_snap_id,
snap_begin_time, snap_end_time,
round(interval_min) as interval_min,
round(lag_value/60/1000000,2) as DB_time_min ,
round(lag_value/60/1000000/interval_min,2) as DB_time_per_sec
from
(
select sp.instance_number,
sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time,
(cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
sy.stat_name
from dba_hist_snapshot sp, dba_hist_sys_time_model sy
where sp.snap_id=sy.snap_id
  and sp.instance_number=sy.instance_number
  and sy.stat_name='&statname'
) where   nvl(lag_value,0)>0)
select * from
(
select a.* ,row_number() over ( partition by instance_number order by DB_time_per_sec desc) as rank
 from stat_time a
) where rank<=20;
$ECHO
spool off

!
echo "show dbtime by day and top 10 by snapshots"
exit 0
fi

################################################################################
if [ "$1" = "sysmetric" ]; then

#AIX not support date  -d
  if [ "$2" = "" ]; then
     #echo "ora sysmetric \"`date +"%Y/%m/%d %H:%M" -d "-1hour"`\" 30"
     echo "ora sysmetric \"`date +"%Y/%m/%d %H:%M"`\" 30"
    exit 1
  fi

   if [ "$3" = "" ]; then
    defdur=30
   else
     defdur=$3
  fi

  btime=$2

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col inst format 99
    col exec_p_s format 999999
    col uc_s format 99999
    col ut_s format 99999
    col start_time format a20

    spool ora_sysmetirc_$filedate.log

select instance_number as inst,
       to_char(begin_time,'mmdd hh24miss')as start_time,--end_time,
       round(avg_act_sess) as act_sess,
       round(avg_syn_read) as syn_read,
       round(exec_s) as exec_p_s ,
       round(io_m_s,1) as io_m_s,
       round(iops) as iops,
       round(logon_s,1) as logon_s,
       round(net_vol_s) as net_s,
       round(phy_r_s) as phy_r_s,
       round(phy_w_s) as phy_w_s,
       round(redo_s) as redo_s,
       round(sql_res,4) as sql_res,
       round(user_call_s) as uc_s,
       round(user_trx_s) as ut_s
from
(select instance_number,begin_time,end_time,metric_name,value
 from DBA_HIST_SYSMETRIC_HISTORY
where begin_time > = to_date('$btime','yyyy/mm/dd hh24:mi')
  and  begin_time <= to_date('$btime','yyyy/mm/dd hh24:mi')+$defdur/60/24
  and instance_number=$INST
  and metric_name in
('Average Active Sessions',
'Average Synchronous Single-Block Read Latency',
'Executions Per Sec',
'I/O Megabytes per Second',
'I/O Requests per Second',
'Logons Per Sec',
'Network Traffic Volume Per Sec',
'Physical Reads Per Sec',
'Physical Writes Per Sec',
'Redo Generated Per Sec',
'SQL Service Response Time',
'User Calls Per Sec',
'User Transaction Per Sec')
)
pivot
(max(value) for metric_name in
('Average Active Sessions' as avg_act_sess,
'Average Synchronous Single-Block Read Latency' as avg_syn_read,
'Executions Per Sec' as exec_s,
'I/O Megabytes per Second' as IO_M_s,
'I/O Requests per Second' as IOPS,
'Logons Per Sec' as logon_s,
'Network Traffic Volume Per Sec' as net_vol_s,
'Physical Reads Per Sec' as PHY_R_s,
'Physical Writes Per Sec'as phy_w_s,
'Redo Generated Per Sec' as redo_s,
'SQL Service Response Time' as sql_res,
'User Calls Per Sec'as user_call_s,
'User Transaction Per Sec'as user_trx_s)
) order by 1,2;
$ECHO
spool off

!
echo "instance_number=$INST"
exit 0
fi


################################################################################
if [ "$1" = "recover" -o "$1" = "recover_state" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 100
alter session set NLS_DATE_FORMAT='DD-MON-YYYY HH24:MI:SS';
select usn,
       state,
       undoblockstotal "Total",
       undoblocksdone "Done",
       undoblockstotal - undoblocksdone "ToDo",
       decode(cputime, 0, 'unknown', sysdate + (((undoblockstotal - undoblocksdone) / (undoblocksdone / cputime)) / 86400)) "Estimated time to complete"
from gv\$fast_start_transactions;
$ECHO

!
exit 0
fi



################################################################################
if [ "$1" = "ddl" ]; then

  ##if [ "$2" = "" -o "$3" = ""  ]; then
  ##  echo "ora ddl owner object_name object_type"
  ##  exit 1
  ##fi

    if [ "$2" = ""  ]; then
      read -p "Please input object_name:" name
       if [ -z "${name}" ];then
       echo "No input,exit!"
       exit 1
       fi
    else
        name=$2
    fi

   if [ "$3" = ""  ]; then
    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_objects
     where object_name=upper('$name') and object_type not like '%PARTITION' and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    if [ -z "${defowner}" ];then
       echo "Object_name $name not found in any schema,please check again!"
       exit 1
    fi
   read -p "Please input object_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
       owner=$defowner
    fi
   else
      owner=$3
  fi

  #owner=$2
  #name=$3

  ##type=$4

  if [ "$4" = ""  ]; then

   deftype=`echo "select trim(12345||LISTAGG (object_type,',') WITHIN GROUP (ORDER BY null)) AS obj_type from dba_objects
          where owner=upper('$owner') and object_type not like '%PARTITION' and object_name=upper('$name') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
   if [ -z "${deftype}" ];then
      echo "object $owner.$name not found,please check again!"
      exit 1
   fi

   read -p "Please input object_type,default is [$deftype]:" type
   if [ -z "${type}" ];then
        type=$deftype
   fi
  else
   type=$4
  fi



  echo DDL of $owner.$name TYPE is : $type

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 600 pagesize 0
    set trims on
    set long 99999999
    set feedback off
    col a for a600 wrapped word

    spool ora_DDL_${type}_${owner}_${name}.log

    begin
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'STORAGE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'TABLESPACE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'SEGMENT_ATTRIBUTES', false);
       DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,'PRETTY',true);
    end;
    /
    select dbms_metadata.get_ddl(upper('$type'),upper('$name'),upper('$owner'))||';' a from dual;

    spool off

!

   if [ "${type}" = "table" -o "${type}" = "TABLE" ]; then

   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 600 pagesize 0
    set trims on
    set long 99999999
    set feedback off
    col a for a600 wrapped word

    spool ora_DDL_${type}_${owner}_${name}.log append

    begin
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'STORAGE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'TABLESPACE',false);
       --dbms_metadata.set_transform_param (dbms_metadata.session_transform,'SEGMENT_ATTRIBUTES', false);
       DBMS_METADATA.SET_TRANSFORM_PARAM(DBMS_METADATA.SESSION_TRANSFORM,'PRETTY',true);
    end;
    /
    select dbms_metadata.get_ddl('INDEX',index_name,upper('$owner'))||';' a
    from dba_indexes where table_name=upper('$name') and owner=upper('$owner')
    ;

    spool off
!
   fi


exit 0
fi



###############################get_ddl#################################################
if [ "$1" = "get_ddl" -o "$1" = "ddl" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

  set serveroutput on size 1000000
  set timing off
  set serveroutput on
  set feedback off
  set verify off
  set linesize 500
  set trimspool on
  undefine object_name
  spool ora_redo_$filedate.log
  var object_name varchar2(100);
  var owner varchar2(100);
  alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
  begin
    :object_name := upper('$2');
  end;
  /
declare

   cursor c_obj is select owner,object_type from dba_objects where object_name = :object_name;
   v_obj c_obj%rowtype;
   cursor c_ddl is select dbms_metadata.get_ddl(case when object_type like 'PACKAGE%' then 'PACKAGE'
                                                     when object_type like 'DATABASE LINK' then 'DB_LINK'
                                                     when object_type like 'MATERIALIZED VIEW' then 'MATERIALIZED_VIEW'
                                                     when object_type = 'INDEX' then 'INDEX'
                                                     else object_type end,
                                                object_name, owner) as object_ddl
                    from dba_objects
                    where object_name = :object_name
                    AND object_type not like '%PARTITION';

   v_ddl c_ddl%rowtype;

  cursor c_cons is select case when co.constraint_type <> 'R'
            then dbms_metadata.get_ddl('CONSTRAINT',co.constraint_name,co.owner)
            when co.constraint_type = 'R'
            then dbms_metadata.get_ddl('REF_CONSTRAINT',co.constraint_name,co.owner) end as text
  from dba_constraints co, dba_cons_columns cc
  where co.owner              = cc.owner
  and co.table_name         = cc.table_name
  and co.constraint_name    = cc.constraint_name
  and co.table_name = :object_name
  order by co.owner, co.table_name, co.constraint_type, co.constraint_name;
  v_cons c_cons%rowtype;

begin
  dbms_metadata.set_transform_param( dbms_metadata.session_transform,'SQLTERMINATOR', TRUE);
  dbms_output.put_line('
Display The Object Type in The Database');
  dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------------------');
  dbms_output.put_line('| OWNER            |' || ' OBJECT_TYPE                     '   || '|');
  dbms_output.put_line('------------------------------------------------------');
  open c_obj;
    loop fetch c_obj into v_obj;
    exit when c_obj%notfound;
    dbms_output.put_line('| ' || rpad(v_obj.OWNER,16) ||' | '|| rpad(v_obj.object_type,32) || '|');
    dbms_output.put_line('------------------------------------------------------');
    end loop;
  close c_obj;


  dbms_output.put_line('
Show The Object DDL Information)');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OBJECT DDL                                                                                                      |');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  open c_ddl;
    loop fetch c_ddl into v_ddl;
    exit when c_ddl%notfound;
    dbms_output.put_line(v_ddl.object_ddl);
    dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
    end loop;
  close c_ddl;
  if v_obj.object_type like 'TABLE%' then

  dbms_output.put_line('
Constraint DDL Information if The Object is A Table');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| Constraint DDL                                                                                                  |');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  open c_cons;
    loop fetch c_cons into v_cons;
    exit when c_cons%notfound;
    dbms_output.put_line(v_cons.text);
    dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
    end loop;
  close c_cons;
   end if;
end;
/
 spool off
 $ECHO

!
exit 0
fi



################################################################################
if [ "$1" = "undo" ]; then


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    col inst_id format a7
    col TABLESPACE_NAME format a20 trunc
    col owner format a20 trunc
    col SEGMENT_NAME format a30
    col status format a10
    set trimspool on
    spool ora_undo_$filedate.log

    SELECT A.INSTANCE_NUM as inst_id,
      A.TABLESPACE_NAME ,
       A.OWNER,
       --A.SEGMENT_NAME ROLL_NAME,
       --A.INITIAL_EXTENT,
       A.SEGMENT_NAME,
      -- A.SEGMENT_ID,
       --A.FILE_ID,
      -- A.BLOCK_ID,
       A.status,
       round(B.BYTES/1024/1024) as size_M,
       B.EXTENTS EXTENTS,
       D.SHRINKS SHRINKS,
       D.WRAPS WRAPS,
       D.OPTSIZE
  FROM DBA_ROLLBACK_SEGS A
  LEFT OUTER JOIN DBA_SEGMENTS B
    ON A.SEGMENT_NAME = B.SEGMENT_NAME
  LEFT OUTER JOIN V\$ROLLNAME C
    ON A.SEGMENT_NAME = C.NAME
  LEFT OUTER JOIN V\$ROLLSTAT D
    ON C.USN = D.USN
 ORDER BY A.INSTANCE_NUM, A.TABLESPACE_NAME, A.SEGMENT_NAME;

prompt search rollback segments online and offline cnt：
    select tablespace_name,status,sum(bytes)/1024/1024 sum_size_mb,sum(blocks) sum_blocks
    from DBA_UNDO_EXTENTS
    group by tablespace_name,status
    order by tablespace_name,status;

    select max(bb.tot_cnt),max(bb.offline_cnt),max(online_cnt)
    from (select count(*) over () tot_cnt,
                 case when status='OFFLINE' then count(*) over (partition by status) end offline_cnt,
                 case when status='ONLINE' then count(*) over (partition by status) end online_cnt
          from DBA_ROLLBACK_SEGS aa)
    bb;
    set   serveroutput   on   size   1000000

prompt Shows undo usage every 10 minutes since 24 hours ago...

col undo_used_mb for a20
col name for a30
col END_TIME for a24
col con_id for 9999
col inst_id for 999999
set linesize 500
set pages 100
SELECT INST_ID,
       to_char(BEGIN_TIME,'yyyy-mm-dd hh24:mi:ss') as BEGIN_TIME,
       to_char(END_TIME,'yyyy-mm-dd hh24:mi:ss') as END_TIME,
       lpad(TRUNC(UNDOBLKS * (SELECT VALUE FROM V\$PARAMETER WHERE NAME = 'db_block_size' AND ROWNUM = 1) / 1024 / 1024,
             2) || ' MB',12) AS undo_used_mb
  FROM GV\$UNDOSTAT
 WHERE BEGIN_TIME > SYSDATE - 1
 ORDER BY BEGIN_TIME;

set serveroutput on

declare
  l_start    number;
  l_end      number;
  v_KTUXEUSN number;
  v_KTUXESLT number;
  v_value    number;
  v_value1   varchar2(20);
  v_cnt      number;
  v_roll_cnt number;

  cursor c_roll is select vs.sid || ',' || vs.serial# as sid, vs.username, rn.name roll_name, vt.start_time, vt.log_io, vt.phy_io, vt.used_ublk,
        round(vt.used_ublk * (select value/1024/1024 from v\$parameter where name='db_block_size' and ROWNUM = 1),2) as used_usize, vt.used_urec, vt.recursive
  from
  v\$transaction vt,
  v\$session vs,
  v\$rollname rn
  where vt.addr = vs.taddr
  and vt.xidusn = rn.usn order by used_urec desc;
  v_roll c_roll%rowtype;

  cursor c_seg is select
  dba_segments.owner,
  dba_segments.tablespace_name,
  dba_rollback_segs.file_id,
  dba_rollback_segs.segment_id,
  dba_segments.segment_type,
  dba_segments.segment_name,
  round(dba_segments.bytes/1024/1024,2) as mb,
  dba_segments.extents,
  dba_rollback_segs.status
from
  sys.dba_segments,
  sys.dba_rollback_segs
where
  dba_segments.bytes/1024/1024 > 10 and -- only show > 10M
  dba_segments.segment_name = dba_rollback_segs.segment_name
order by sys.dba_rollback_segs.segment_id;
  v_seg c_seg%rowtype;
  cursor c_t_stat is select KTUXECFL,count(*) as cnt from x\$ktuxe group by KTUXECFL;
  v_t_stat c_t_stat%rowtype;

  cursor c_trx is select
       r.usn as USN,
       r.name rollback_name,
       q.sql_id,
       case when s.sid is null then 'None' else s.sid || ',' || s.serial# end as sid_and_serial,
       round(seg.bytes/1024/1024,2) as mb ,
       seg.TABLESPACE_NAME,
       l.addr as TADDR,
        substr(q.sql_text,0,40) as sql_text
  from v\$lock l,
     v\$session s,
     v\$rollname r,
     dba_segments seg,
     v\$sql q
  where   l.addr = s.taddr(+)
  and     trunc(l.id1(+)/65536)=r.usn
  and     l.type(+) = 'TX'
  and     l.lmode(+) = 6
  and     r.name = seg.segment_name
  and     s.sql_hash_value = q.hash_value
  and     s.sql_address = q.address
  and     seg.bytes > 1*1024*1024*1024
  order by bytes desc;
  v_trx c_trx%rowtype;

  cursor c_ktu is SELECT KTUXEUSN USN,
  KTUXESIZ,
  KTUXESLT,
  KTUXESQN,
  KTUXESTA,
  KTUXERDBF FILE_ID,
  KTUXERDBB BLOCK_ID
  FROM sys.x\$KTUXE WHERE KTUXECFL = 'DEAD';

  v_ktu c_ktu%rowtype;

begin
  dbms_output.enable(buffer_size => NULL);
  select ksppstvl into v_value from x\$ksppi x, x\$ksppcv y where x.indx = y.indx and ksppinm = '_rollback_segment_count';
  select count(*) into v_cnt from v\$rollname;
  select value into v_value1 from v\$parameter where name = 'fast_start_parallel_rollback';
  dbms_output.put_line('
_rollback_segment_count and Current Node rollback segments Count(From v\$rollname)
If RAC System Node Count > 3 be carefull!!! Oracle Max Rollback Segments is 32760');
  dbms_output.put_line('======================');
  dbms_output.put_line('fast_start_parallel_rollback        ' || ' : ' || v_value1);
  dbms_output.put_line('_rollback_segment_count             ' || ' : ' || v_value);
  dbms_output.put_line('Current Node rollback segments Count' || ' : ' || v_cnt );


  select count(*) into v_roll_cnt from
  v\$transaction vt,
  v\$session vs,
  v\$rollname rn
  where vt.addr = vs.taddr
  and vt.xidusn = rn.usn;
  if v_roll_cnt > 0 then
  dbms_output.put_line('
Active transaction,rollback segments Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('|     sid_and_serial# |' || ' USERNAME      ' || '| ROLL_SEGMENT_NAME         |' || ' START_TIME        ' || '| LOGICAL_IO |' || ' PHYSICAL IO ' || '| USED_UBLK |' || ' USED_UNDO(MB) ' || '| used_urec |' || ' recursive ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_roll;
    loop fetch c_roll into v_roll;
    exit when c_roll%notfound;
    dbms_output.put_line('| ' || lpad(v_roll.sid,19) ||' | '|| rpad(v_roll.username,13) || ' | ' || rpad(v_roll.roll_name,25) || ' | '|| rpad(v_roll.start_time,17) || ' | '|| lpad(v_roll.log_io,10) || ' | '|| lpad(v_roll.phy_io,11) || ' | '|| lpad(v_roll.used_ublk,9) || ' | '|| lpad(v_roll.used_usize,13) || ' | '|| lpad(v_roll.used_urec,9) || ' | '|| lpad(v_roll.recursive,10) || '|');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_roll;
  else
    dbms_output.put_line('
These is no Transaction Use rollback segments,No Transaction');
  dbms_output.put_line('======================');
  end if;

   dbms_output.put_line('
Rollback Segments Basic Status Information(only Show the Rollback Segment Size > 10M)
USN means Rollback Segments number');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER |' || ' TABLESPACE_NAME  ' || '| FILE# |' || ' USN        ' || '| SEGMENT_TYPE |' || ' ROLLBACK_SEGMENT_NAME                             ' || '| ROLLBACK_SEGMENT_SIZE(MB) |' || ' EXTENTS ' || '| STATUS    ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_seg;
    loop fetch c_seg into v_seg;
    exit when c_seg%notfound;
    dbms_output.put_line('| ' || rpad(v_seg.owner,5) ||' | '|| rpad(v_seg.tablespace_name,16) || ' | ' || lpad(v_seg.file_id,5) || ' | '|| lpad(v_seg.segment_id,10) || ' | '|| rpad(v_seg.segment_type,12) || ' | '|| rpad(v_seg.segment_name,49) || ' | '|| lpad(v_seg.mb,25) || ' | '|| lpad(v_seg.extents,7) || ' | ' || rpad(v_seg.status,10) || '|');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_seg;

    dbms_output.put_line('
Active Transaction Rollback Segments Information(Only Show Rollback segment > 1G per transaction desc)');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| USN |' || ' ROLLBACK_NAME   ' || '| SQL_ID        |' || '    SID_AND_SERIAL# ' || '| TRX_SIZE(MB) |' || ' TABLESPACE_NAME     ' || '| TADDR(v$session) |' || ' SQL_TEXT                                     ' || ' |');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_trx;
    loop fetch c_trx into v_trx;
    exit when c_trx%notfound;
    dbms_output.put_line('| ' || lpad(v_trx.USN,3) ||' | '|| rpad(v_trx.rollback_name,15) || ' | ' || lpad(v_trx.sql_id,13) || ' | '|| lpad(v_trx.sid_and_serial,18) || ' | '|| lpad(v_trx.mb,12) || ' | '|| rpad(v_trx.TABLESPACE_NAME,19) || ' | '|| lpad(v_trx.TADDR,16) || ' | ' || rpad(v_trx.SQL_TEXT,45) || ' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_trx;
   dbms_output.put_line('
Transaction Status CNT Information(x$ktuxe)
The ktuxecfl column means the Flag of Status, such as DEAD transaction');
  dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------');
  dbms_output.put_line('| KTUXECFL             |' || '           COUNT ' || '|');
  dbms_output.put_line('------------------------------------------');
  open c_t_stat;
    loop fetch c_t_stat into v_t_stat;
    exit when c_t_stat%notfound;
    dbms_output.put_line('| ' || rpad(v_t_stat.KTUXECFL,20) ||' | '|| lpad(v_t_stat.CNT,16) || '|');
    end loop;
    dbms_output.put_line('------------------------------------------');
  close c_t_stat;


   dbms_output.put_line('
Dead Transaction Information(x$ktuxe)
USN means Rollback Segments number
KUTXESIZ means the remaining number of undo blocks required for rollback
KTUXESLT means the transaction slot number
KTUXESQN means the xid Sequence number
KTUXESTA means the transaction status
');
  dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('|   USN |' || ' KTUXESIZ(BLOCK) ' || '| KTUXESLT   |' || ' KTUXESQN     ' || '| KTUXESTA(STATUS) |' || ' FILE_ID ' || '|        BLOCK_ID ' || '|');
  dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  open c_ktu;
    loop fetch c_ktu into v_ktu;
    exit when c_ktu%notfound;
    dbms_output.put_line('| ' || lpad(v_ktu.USN,5) ||' | '|| lpad(v_ktu.KTUXESIZ,15) || ' | ' || lpad(v_ktu.KTUXESLT,10) || ' | '|| lpad(v_ktu.KTUXESQN,12) || ' | '|| rpad(v_ktu.KTUXESTA,16) || ' | '|| lpad(v_ktu.FILE_ID,7) || ' | ' || lpad(v_ktu.BLOCK_ID,15) || ' |');
    end loop;
    dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  close c_ktu;

  dbms_output.put_line('
How long does it take to roll back(Minutes)');
  dbms_output.put_line('======================');
  select KTUXEUSN,KTUXESLT into v_KTUXEUSN,v_KTUXESLT from x\$ktuxe where KTUXESIZ <>0 and ktuxecfl ='DEAD';
  select ktuxesiz into l_start from x\$ktuxe where KTUXEUSN = v_KTUXEUSN and KTUXESLT = v_KTUXESLT;
  dbms_lock.sleep(60);
  select ktuxesiz into l_end from x\$ktuxe where KTUXEUSN = v_KTUXEUSN and KTUXESLT = v_KTUXESLT;
    dbms_output.put_line('------------------------------------------------------------------------------------------------------');
    dbms_output.put_line('| Estimated remaining Minutes: '|| round(l_end/(l_start -l_end)) || ' min' || '                    |'         );
    dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  -- exception
  -- when others then
  --  dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  --  dbms_output.put_line('| There are no transactions that need to be rolled back at the moment.  ' || substr(SQLERRM,1,80) || '     |');
  --  dbms_output.put_line('------------------------------------------------------------------------------------------------------');
end;
/
spool off
 $ECHO

!
exit 0
fi

#CURDATE=`date +"%Y%m%d"`
#echo $CURDATE

################################################################################
if [ "$1" = "redo" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    --set sqlnumber off : no use for -e

col h00 format 999
col h01 format 999
col h02 format 999
col h03 format 999
col h04 format 999
col h05 format 999
col h06 format 999
col h07 format 999
col h08 format 999
col h09 format 999
col h10 format 999
col h11 format 999
col h12 format 999
col h13 format 999
col h14 format 999
col h15 format 999
col h16 format 999
col h17 format 999
col h18 format 999
col h19 format 999
col h20 format 999
col h21 format 999
col h22 format 999
col h23 format 999
set trimspool on
spool ora_redo_$filedate.log
PRO redo log swith count by hour:
col day format a5
col weekday format a3
col total format 9999
col inst_id format 9999
SELECT  a.inst_id, SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH:MI:SS'),1,5)  as  Day,TO_CHAR (first_time, 'Dy') as weekday,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'00',1,0)) H00,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'01',1,0)) H01,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'02',1,0)) H02,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'03',1,0)) H03,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'04',1,0)) H04,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'05',1,0)) H05,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'06',1,0)) H06,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'07',1,0)) H07,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'08',1,0)) H08,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'09',1,0)) H09,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'10',1,0)) H10,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'11',1,0)) H11,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'12',1,0)) H12,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'13',1,0)) H13,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'14',1,0)) H14,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'15',1,0)) H15,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'16',1,0)) H16,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'17',1,0)) H17,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'18',1,0)) H18,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'19',1,0)) H19,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'20',1,0)) H20,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'21',1,0)) H21,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'22',1,0)) H22,
       SUM(DECODE(SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH24:MI:SS'),10,2),'23',1,0)) H23,
       COUNT(*) TOTAL
FROM gv\$log_history  a
 WHERE first_time>=TO_CHAR(sysdate-30) and thread# = inst_id
    group by a.inst_id,
 SUBSTR(TO_CHAR(first_time, 'MM/DD/RR HH:MI:SS'),1,5),TO_CHAR (first_time, 'Dy')
order by 1,2 ;
$ECHO

pro Redo Log File Information
pro alter database add logfile thread 1 '+DATA' size 2G;
pro alter database add logfile thread 2 '+DATA' size 2G;
pro ======================
col status format a8
col member format a60
SELECT
       a.THREAD#,
       a.group#,
       a.SEQUENCE#,
       round(bytes / 1024 / 1024) size_m,
       a.status,
       a.ARCHIVED,
       a.MEMBERS,
       b.member,
       --TO_CHAR(listagg(b.MEMBER,',') within group(order by MEMBER))  MEMBER,
       b.type
FROM   gv\$log     a,
       gv\$logfile b
WHERE  b.GROUP# = a.GROUP#
AND    a.THREAD# = b.INST_ID
AND    a.inst_id = b.inst_id
order by 1,2;
$ECHO
spool off

!
exit 0
fi
################################################################################
if [ "$1" = "seq" -o "$1" = "sequence" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30 linesize 200
    col sequence_owner format a30
    col sequence_name format a30
    set trimspool on
    spool ora_seq_$filedate.log

    select sequence_owner,sequence_name,order_flag,cache_size
    from dba_sequences
    where sequence_owner not in ('SYS','SYSTEM','MDSYS','OLAPSYS','SYSMAN','WMSYS','XDB','ORDDATA')
    and (order_flag='Y' or cache_size<=20)
    order by order_flag,sequence_owner,sequence_name;
    $ECHO
    spool off

!
exit 0
fi


################################################################################
if [ "$1" = "job" -o  "$1" = "jobs" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 20
    set linesize 240

    col schema_user format a30
    col interval format a30
    col what format a50 trunc

    SELECT  instance,schema_user,next_date,failures,broken,interval,what
    FROM  dba_jobs
    ORDER BY schema_user;

col job_action format a30 trunc
col program_owner format a30
col program_name format a25 trunc
col repeat_interval format a44
col interval format a30
col job_creator format a10 trunc
col owner format a10 trunc
col job_name format a24 trunc
col spid format a5
col job_state format a8 trunc
set trimspool on
spool ora_job_$filedate.log

SELECT --j.JOB_CREATOR,
       j.OWNER,
       j.job_name,
       j.state job_STATE,
       DECODE(J.STATE, 'RUNNING', 'Y', 'N') is_running,
       --j.job_type,
       --j.job_action,
       --j.JOB_STYLE,
       --j.PROGRAM_OWNER,
       j.PROGRAM_NAME,
       --j.schedule_type,
       j.repeat_interval,
       --TO_CHAR(j.start_date, 'YYYY-MM-DD HH24:mi:ss') start_date,
       --TO_CHAR(j.end_date, 'YYYY-MM-DD HH24:mi:ss') end_date,
       TO_CHAR(J.NEXT_RUN_DATE, 'YYYY-MM-DD HH24:mi:ss') NEXT_RUN_DATE,
       TO_CHAR(J.last_start_date, 'YYYY-MM-DD HH24:mi:ss') last_start_date,
       --(J.LAST_RUN_DURATION) LAST_RUN_DURATION,
       j.run_count,
       --j.NUMBER_OF_ARGUMENTS,
       j.ENABLED,
       --j.AUTO_DROP,
       --j.max_run_duration,
       --j.max_failures,
       --j.max_runs,
       --j.LOGGING_LEVEL,
       --j.SYSTEM is_systemjob,
       --j.comments,
       RJ.running_instance as inst_id,
       --RJ.cpu_used,
       --B.username,
       B.SID,
       B.SERIAL#,
       --(SELECT nb.spid FROM gv\$process nb WHERE nb.ADDR = b.SADDR) spid,
       b.STATUS
       --B.COMMAND,
       --B.LOGON_TIME
       --,B.OSUSER
  FROM dba_scheduler_jobs j
  LEFT OUTER JOIN dba_scheduler_running_jobs rj
    ON j.JOB_NAME = rj.JOB_NAME
  LEFT OUTER JOIN gv\$session b
    ON (rj.session_id = b.SID AND  rj.RUNNING_INSTANCE = b.INST_ID)
ORDER BY b.INST_ID, j.STATE, j.owner, j.JOB_NAME;




select client_name,job_name,job_start_time from dba_autotask_job_history;

select job || ' '|| what, failures from dba_jobs where failures > 0
union all
select JOB_NAME, count(*)
FROM dba_scheduler_job_log
where
log_date > sysdate - 300/86400 and
STATUS != 'SUCCEDED'
group by job_name;



col jobs_what head WHAT for a50
col jobs_interval head INTERVAL for a40

col jobs_job_name head JOB_NAME for a40
col jobs_program_name head PROGRAM_NAME for a40

select * from dba_jobs_running;

select
    job_name      jobs_job_name
  , program_name  jobs_program_name
  , state         jobs_state
  , to_char(start_date, 'YYYY-MM-DD HH24:MI') start_date
  , to_char(next_run_date, 'YYYY-MM-DD HH24:MI') next_run_date
  , enabled
from
    dba_scheduler_jobs
where
    state = 'RUNNING';

$ECHO
spool off

!
exit 0
fi


##############################################################################
if [ "$1" = "fulltext" -o "$1" = "full_text" ]; then
## spool to sqltext_$2.sql

  if [ "$2" = "" ]; then
    echo "ora fulltext <sql_id>"
    exit 1
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set serveroutput on size unlimited
    set feedback off verify off
    set trim off
    set linesize 180
    def sql_id=$2

    COL sql_id NEW_VALUE get_sql_id

    SELECT sql_id
      FROM gv\$sqlarea
     WHERE sql_id = TRIM('&sql_id')
     UNION
    SELECT sql_id
      FROM dba_hist_sqltext
     WHERE sql_id = TRIM('&sql_id');

    VAR get_sql_id VARCHAR2(13);
    EXEC :get_sql_id := '&get_sql_id';

    --SET TERM ON;
    WHENEVER SQLERROR EXIT SQL.SQLCODE;

    BEGIN
      IF '&get_sql_id' IS NULL THEN
          RAISE_APPLICATION_ERROR(-20200, 'SQL_ID &sql_id not found in memory nor in AWR.');
      END IF;
    END;
    /

    --no error, sql_id must exist in awr or memory!
    spool ora_sqltext_&sql_id..log

    declare
      l_sql_text CLOB ;
      l_sql_id varchar2(13);
      l_pos NUMBER;
    BEGIN
      l_sql_id := '&sql_id';
      select nvl((select sql_text from dba_hist_sqltext where sql_id=l_sql_id),'NOT_IN_AWR')
           into l_sql_text from dual;

      if l_sql_text='NOT_IN_AWR' then
        select SQL_FULLTEXT into l_sql_text from gv\$sql where sql_id=l_sql_id and rownum=1;
      end if;

      --only chr(10) found in sql text. no chr(13)
      WHILE NVL(LENGTH(l_sql_text), 0) > 0
      LOOP
        l_pos := INSTR(l_sql_text, CHR(10));
        --DBMS_OUTPUT.PUT_LINE('position:'||l_pos);
        IF l_pos > 0 THEN
          DBMS_OUTPUT.PUT_LINE(SUBSTR(l_sql_text, 1, l_pos - 1));
          l_sql_text := SUBSTR(l_sql_text, l_pos + 1);
        ELSE
          DBMS_OUTPUT.PUT_LINE(l_sql_text);
          l_sql_text := NULL;
        END IF;
      END LOOP;
    EXCEPTION
      WHEN OTHERS THEN
        --cu32d197864an
        --select sql_id,length(sql_text) from dba_hist_sqltext where length(sql_text)>32767 and instr(sql_text,chr(10))=0;
        DBMS_OUTPUT.PUT_LINE('sql length more than 32767 and no chr(10) in entire sql text.use fulltext_long.sql');
    END;
    /
    spool off

!

exit 0
fi


#####################################################################################################

if [ "$1" = "text2sqlid" ]; then
#use  "" for text ; only find in first 1000 char ; use double ' replace single '

  if [ "$2" = "" ]; then
    echo "ora text2sqlid "piece of sql text""
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 600
    col sql_text format a150 trunc
    col sql_id format a14

    select *
    from
    (select
      'sqlarea' as sql_loc  , sql_id
    , to_char(substr(sql_text,1,200)) as sql_text
    from
      gv\$sqlarea
    where
      upper(SQL_TEXT) like upper('%$2%')
      and SQL_TEXT not like '%SQL_TEXT%'
    union
    select
      'sql_his'  , sql_id
    , to_char(substr(sql_text,1,200))
    from
     dba_hist_sqltext
    where
     upper(SQL_TEXT) like upper('%$2%')
     --and SQL_TEXT not like '%SQL_TEXT%'
    ) where rownum<=100;
    $ECHO

!
echo "only random 100 listed"
  exit 0
fi

###############################################################################################

if [ "$1" = "sql" -o "$1" = "cursor" ] ; then

    #if [ "$2" = "" ]; then
    #  echo "ora sql <sqlid> [typical]|<adv> "
    #  exit 1
    #fi

     if [ "$2" = ""  ]; then
      read -p "Please input sqlid:" sqlid
       if [ -z "${sqlid}" ];then
         echo "No input,exit!"
         exit 1
       fi
    else
        sqlid=$2
    fi


     if [ "$3" = "adv" ]; then
      format=advanced
     else
      format=typical
    fi

     #sqlid=$2

     sqlplus -s /NOLOG << !  | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set verify off
    set feedback off;
    set linesize 150 pagesize 35
    spool ora_SQL_${sqlid}_${filedate}.log

    col sql_id format a13


    $DEFNODISP col sql_text_100 format a100
    $DEFNODISP col sql_text_800 format a100
    $DEFNODISP
    $DEFNODISP pro sql_text from gv\$sql:
    $DEFNODISP
    $DEFNODISP select substr(sql_text,1,100) as sql_text_100 from gv\$sql where sql_id='$sqlid' and rownum<=1;
    $DEFNODISP pro
    $DEFNODISP
    $DEFNODISP
    $DEFNODISP pro sql_text from dba_hist_sqlstat:
    $DEFNODISP select substr(sql_text,1,800) as sql_text_800 from dba_hist_sqltext where sql_id='$sqlid' and rownum<=1;


    PRO
    PRO DBA_HIST_SQLSTAT detail(recent 15 days):
    PRO

     col  snap_id format 9999999
     col inst format 99
     col cpu_s format 999999
     col execs format 99999999
     col DISK_R format 999999999
     col io_s  format 999999
     col ms_pe format 99999999
     col snap_date format a20
     select
      a.snap_id,
      to_char(b.end_interval_time,'yyyymmdd hh24:mi') as snap_date,
      a.instance_number as inst,
      plan_hash_value as phv,
      round((cpu_time_delta)/1e6)  as cpu_s,
      (executions_delta) as execs,
      --BUFFER_GETS_DELTA as buffs,
      --ROWS_PROCESSED_DELTA as rows_processed,
      round((BUFFER_GETS_DELTA)/greatest((executions_delta),1))  as Buf_pe,
      round((ROWS_PROCESSED_DELTA)/greatest((executions_delta),1),1)  as Row_pe,
      --round((BUFFER_GETS_DELTA)/greatest((ROWS_PROCESSED_DELTA ),1),1) as buf_per_row,
      case when (ELAPSED_TIME_DELTA)/1e3/greatest((executions_delta),1) <1
           then round((ELAPSED_TIME_DELTA)/1e3/greatest((executions_delta),1),2)
           else round((ELAPSED_TIME_DELTA)/1e3/greatest((executions_delta),1)) end  as ms_pe,
      round((DISK_READS_DELTA))  as DISK_R,
      round((IOWAIT_DELTA)/1e6)  as IO_s,
      round((APWAIT_DELTA)/1e3)  as App_ms
      --round((CCWAIT_DELTA)/1e3)  as ConC_ms,
      --round((CLWAIT_DELTA)/1e3)  as CLu_ms
      --round((PLSEXEC_TIME_DELTA)/1e3)  as PLSQL_ms
      --round((JAVEXEC_TIME_DELTA)/1e3)  as JAVA_ms,
      --round((CPU_TIME_DELTA))  as CPU_TIME_D,
      --round((DIRECT_WRITES_DELTA))  as DIRECT_W,
      --round((END_OF_FETCH_COUNT_DELTA))  as END_FET_cnt,
      --round((FETCHES_DELTA))  as FETCHES,
      --round((INVALIDATIONS_DELTA))  as INVALID,
      --round((IO_INTERCONNECT_BYTES_DELTA))  as IO_INTERCO,
      --round((IO_OFFLOAD_ELIG_BYTES_DELTA))  as IO_OFFLOAD_elig,
      --round((IO_OFFLOAD_RETURN_BYTES_DELTA))  as IO_OFFLOAD_return,
      --round((LOADS_DELTA))  as LOADS,
      --round((OPTIMIZED_PHYSICAL_READS_DELTA))  as OPT_phy_rds,
      --round((PARSE_CALLS_DELTA))  as PARSE_CALL,
      --round((PHYSICAL_READ_BYTES_DELTA))  as PHYSICAL_RB,
      --round((PHYSICAL_READ_REQUESTS_DELTA))  as PHY_R_Req,
      --round((PHYSICAL_WRITE_BYTES_DELTA))  as PHYSICAL_WB,
      --round((PHYSICAL_WRITE_REQUESTS_DELTA))  as PHY_W_Req,
      ---round((PX_SERVERS_EXECS_DELTA))  as PX_Svr,
      ---round((SORTS_DELTA))  as SORTS
       from dba_hist_sqlstat a,dba_hist_snapshot b
       where sql_id='$sqlid' and a.snap_id=b.snap_id and a.instance_number=b.instance_number
             and b.end_interval_time>sysdate-15
    order by snap_id;
    $ECHO

    col SqlText format a120
    $DEFNODISP PRO
    $DEFNODISP PRO
    $DEFNODISP PRO SQL count with same FORCE_MATCHING_SIGNATURE in AWR :
    $DEFNODISP PRO
    $DEFNODISP select count(distinct sql_id) from dba_hist_sqlstat
    $DEFNODISP   where FORCE_MATCHING_SIGNATURE>0 and
    $DEFNODISP       FORCE_MATCHING_SIGNATURE=
    $DEFNODISP   (select FORCE_MATCHING_SIGNATURE from dba_hist_sqlstat where sql_id='$sqlid' and rownum=1);
    $DEFNODISP
    $DEFNODISP $ECHO
    $DEFNODISP
    $DEFNODISP
    $DEFNODISP PRO
    $DEFNODISP PRO
    $DEFNODISP PRO Other sqls with same plan_hash_value  in AWR(rownum<=10):
    $DEFNODISP col sqltext format a120
    $DEFNODISP select sql_id,
    $DEFNODISP    nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,120)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** ')) SqlText
    $DEFNODISP from dba_hist_sqltext b where sql_id in
    $DEFNODISP (select distinct sql_id from dba_hist_sqlstat
    $DEFNODISP where plan_hash_value>0 and
    $DEFNODISP       plan_hash_value in(select plan_hash_value from dba_hist_sqlstat where sql_id='$sqlid')
    $DEFNODISP     --and FORCE_MATCHING_SIGNATURE<>(select FORCE_MATCHING_SIGNATURE from dba_hist_sqlstat where sql_id='$sqlid' and rownum=1)
    $DEFNODISP ) and sql_id<> '$sqlid' and rownum<=10;
    $DEFNODISP $ECHO

    $DEFNODISP PRO
    $DEFNODISP PRO
    $DEFNODISP PRO Other sqls with same plan_hash_value and not full binded  in v#sql (only)(rownum<=10):
    $DEFNODISP select sql_id,
    $DEFNODISP    nvl(replace(replace(to_nchar(SUBSTR(b.sql_text,1,120)),chr(10),''),chr(13),'') , (' ** SQL Text Not Available ** ')) SqlText
    $DEFNODISP from gv\$sqltext b where sql_id in
    $DEFNODISP (select distinct sql_id from gv\$sql
    $DEFNODISP where plan_hash_value>0 and
    $DEFNODISP       plan_hash_value in(select plan_hash_value from gv\$sql where sql_id='$sqlid')
    $DEFNODISP       and FORCE_MATCHING_SIGNATURE=exact_matching_signature
    $DEFNODISP ) and sql_id<> '$sqlid' and rownum<=10;
    $DEFNODISP $ECHO



    PRO
    PRO

    Pro SQL top event in gv_active_session_history:
    col event format a50
    select * from
    (select inst_id,event,count(*) cnt from gv\$active_session_history where sql_id='$sqlid'
      group by inst_id,event order by cnt desc
    )where rownum<=5;
    pro
    pro

    set pagesize 180

    PRO
    PRO Historical SQL plans in AWR:
    PRO

    col PLAN_TABLE_OUTPUT format a180
    select * from table(dbms_xplan.display_awr('$sqlid',format=>'$format -projection'));

    PRO
    PRO


    set pagesize 180

    PRO
    PRO Current SQL plans in Curor:
    PRO

    col PLAN_TABLE_OUTPUT format a180
    select * from table(dbms_xplan.display_cursor('$sqlid',format=>'$format -projection allstats last'));

    PRO
    Pro
    Pro Historical Plans Summary(dba_hist_sqlstat):
    col AVG_CPU_S format a12
    col avg_etime_s format a12
    col first_snap format a19
    col last_snap format a19
    col rn forma 999
    SELECT ROWNUM as rn,
       v.plan_hash_value,
       TO_CHAR(v.avg_elapsed_time_secs, '9999990D990') as avg_etime_s,
       TO_CHAR(v.avg_cpu_time_secs, '9999990D990') as avg_cpu_s,
       --TO_CHAR(v.avg_user_io_wait_time_secs, '99999999999990D990') as avg_iowait_s,
       --TO_CHAR(v.avg_concurrency_wait_time_secs, '99999999999990D990') as avg_conc_s,
       --TO_CHAR(v.avg_application_wait_time_secs, '99999999999990D990') as avg_app_s,
       --TO_CHAR(v.avg_cluster_wait_time_secs, '99999999999990D990') as avg_clu_s,
       --TO_CHAR(v.avg_plsql_exec_time_secs, '99999999999990D990') as avg_plsql_s,
       --TO_CHAR(v.avg_java_exec_time_secs, '99999999999990D990') as avg_java_s,
       v.avg_buffer_gets as avg_buffers,
       v.avg_disk_reads as avg_reads,
       --v.avg_direct_writes,
       v.avg_rows_processed as avg_rows,
       v.delta_executions as execs,
       --v.min_optimizer_cost as min_cost,
       --DECODE(v.min_optimizer_cost, v.max_optimizer_cost, NULL, v.max_optimizer_cost) as max_cost,
       --v.min_optimizer_env_hash_value as min_opt_env,
       --DECODE(v.min_optimizer_env_hash_value, v.max_optimizer_env_hash_value, NULL, v.max_optimizer_env_hash_value) as max_opt_env,
       TO_CHAR(v.first_snap_time, 'YYYY-MM-DD HH24:MI:SS') as first_snap,
       TO_CHAR(v.last_snap_time, 'YYYY-MM-DD HH24:MI:SS') as last_snap
  FROM
(
SELECT /*+ NO_MERGE */
       h.plan_hash_value,
       ROUND((SUM(h.elapsed_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_elapsed_time_secs,
       ROUND((SUM(h.cpu_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_cpu_time_secs,
       ROUND((SUM(h.iowait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_user_io_wait_time_secs,
       ROUND((SUM(h.ccwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_concurrency_wait_time_secs,
       ROUND((SUM(h.apwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_application_wait_time_secs,
       ROUND((SUM(h.clwait_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_cluster_wait_time_secs,
       ROUND((SUM(h.plsexec_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_plsql_exec_time_secs,
       ROUND((SUM(h.javexec_time_delta)/SUM(GREATEST(h.executions_delta, 1))) / 1e6, 3) avg_java_exec_time_secs,
       ROUND(SUM(h.buffer_gets_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_buffer_gets,
       ROUND(SUM(h.disk_reads_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_disk_reads,
       ROUND(SUM(h.direct_writes_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_direct_writes,
       ROUND(SUM(h.rows_processed_delta)/SUM(GREATEST(h.executions_delta, 1))) avg_rows_processed,
       SUM(GREATEST(h.executions_delta, 1)) delta_executions,
       --SUM(h.fetches_delta) delta_fetches,
       --SUM(h.loads_delta) delta_loads,
       --SUM(h.invalidations_delta) delta_invalidations,
       --SUM(h.parse_calls_delta) delta_parse_calls,
       MIN(h.optimizer_cost) min_optimizer_cost,
       MAX(h.optimizer_cost) max_optimizer_cost,
       MIN(h.optimizer_env_hash_value) min_optimizer_env_hash_value,
       MAX(h.optimizer_env_hash_value) max_optimizer_env_hash_value,
       MIN(s.end_interval_time) first_snap_time,
       MAX(s.end_interval_time) last_snap_time
  FROM dba_hist_sqlstat h,
       dba_hist_snapshot s
 WHERE h.sql_id = '$sqlid'
   AND h.snap_id = s.snap_id
   AND h.dbid = s.dbid
   AND h.instance_number = s.instance_number
 GROUP BY
       h.plan_hash_value
 ORDER BY  2
) v;
$ECHO

      PRo
      Pro
      PRO Current Plans Summary(gv_sql):
      col first_load_time format a20
      col last_load_time format a20
      col last_active format a20
      col rn format 99
      SELECT  ROWNUM as rn,
       v.plan_hash_value,
       TO_CHAR(v.avg_elapsed_time_secs, '9999990D990') as avg_etime_s,
       TO_CHAR(v.avg_cpu_time_secs, '9999990D990') as avg_cpu_s,
       --TO_CHAR(v.avg_user_io_wait_time_secs, '99999999999990D990') as avg_iowait_s,
       --TO_CHAR(v.avg_concurrency_wait_time_secs, '99999999999990D990') as avg_conc_s,
       --TO_CHAR(v.avg_application_wait_time_secs, '99999999999990D990') as avg_app_s,
       --TO_CHAR(v.avg_cluster_wait_time_secs, '99999999999990D990') as avg_clu_s,
       --TO_CHAR(v.avg_plsql_exec_time_secs, '99999999999990D990') as avg_plsql_s,
       --TO_CHAR(v.avg_java_exec_time_secs, '99999999999990D990') as avg_java_s,
       v.avg_buffer_gets as avg_buffers,
       v.avg_disk_reads as avg_reads,
       --v.avg_direct_writes,
       v.avg_rows_processed as avg_rows,
       v.total_executions as total_exec,
       --v.total_fetches,
       --v.total_loads,
       --v.total_invalidations,
       --v.total_parse_calls,
       --v.child_cursors,
       --v.min_optimizer_cost,
       --DECODE(v.min_optimizer_cost, v.max_optimizer_cost, NULL, v.max_optimizer_cost) as max_cost,
       --v.min_optimizer_env_hash_value,
       --DECODE(v.min_optimizer_env_hash_value, v.max_optimizer_env_hash_value, NULL, v.max_optimizer_env_hash_value) as max_opt_env,
       v.first_load_time,
       --v.last_load_time,
       TO_CHAR(v.last_active_time, 'YYYY-MM-DD HH24:MI:SS') as last_active
  FROM (
SELECT /*+ NO_MERGE */
       plan_hash_value,
       ROUND((SUM(elapsed_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_elapsed_time_secs,
       ROUND((SUM(cpu_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_cpu_time_secs,
       ROUND((SUM(user_io_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_user_io_wait_time_secs,
       ROUND((SUM(concurrency_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_concurrency_wait_time_secs,
       ROUND((SUM(application_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_application_wait_time_secs,
       ROUND((SUM(cluster_wait_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_cluster_wait_time_secs,
       ROUND((SUM(plsql_exec_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_plsql_exec_time_secs,
       ROUND((SUM(java_exec_time)/SUM(GREATEST(executions, 1))) / 1e6, 3) avg_java_exec_time_secs,
       ROUND(SUM(buffer_gets)/SUM(GREATEST(executions, 1))) avg_buffer_gets,
       ROUND(SUM(disk_reads)/SUM(GREATEST(executions, 1))) avg_disk_reads,
       ROUND(SUM(direct_writes)/SUM(GREATEST(executions, 1))) avg_direct_writes,
       ROUND(SUM(rows_processed)/SUM(GREATEST(executions, 1))) avg_rows_processed,
       SUM(GREATEST(executions, 1)) total_executions,
       SUM(fetches) total_fetches,
       SUM(loads) total_loads,
       SUM(invalidations) total_invalidations,
       SUM(parse_calls) total_parse_calls,
       COUNT(*) child_cursors,
       MIN(optimizer_cost) min_optimizer_cost,
       MAX(optimizer_cost) max_optimizer_cost,
       MIN(optimizer_env_hash_value) min_optimizer_env_hash_value,
       MAX(optimizer_env_hash_value) max_optimizer_env_hash_value,
       MIN(first_load_time) first_load_time,
       MAX(last_load_time) last_load_time,
       MAX(last_active_time) last_active_time
  FROM gv\$sql
 WHERE sql_id = '$sqlid'
 GROUP BY
       plan_hash_value
 ORDER BY
       2) v;
    $ECHO

    pro
    pro
    PRO Tables involved(used objects may not exists now):
    PRO
    col table_owner format a30
    col table_name format a30
    col LAST_ANALYZED format a20
    with tmp_tbs as
    (
        select table_owner,table_name from dba_indexes where
        (owner,index_name) in
          (select object_owner,object_name from dba_hist_sql_plan where sql_id='$sqlid' and object_type like 'INDEX%'
           union all
           select object_owner,object_name from gv\$sql_plan where sql_id='$sqlid' and object_type like 'INDEX%'
           )
        union
        select object_owner,object_name from dba_hist_sql_plan where sql_id='$sqlid' and object_type = 'TABLE'
        union
        select object_owner,object_name from gv\$sql_plan where sql_id='$sqlid' and object_type = 'TABLE'
    )
    select a.*,b.num_rows,to_char(b.last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
       (select round(sum(bytes)/1024/1024)
          from dba_segments c where a.table_owner=c.owner and a.table_name=c.segment_name
       ) as size_m
    from tmp_tbs a,dba_tab_statistics b
    where a.table_owner=b.owner and a.table_name=b.table_name
    and b.object_type='TABLE';
    $ECHO
    PRO
    PRO
    spool off
!
echo "Above is sql info for sql_id :$sqlid ,plan format is $format. for advanced plan ,use ora sql <sqlid> adv"
exit 0
fi
##############################################################################################

if [ "$1" = "repeat" ]; then

  shift;
  interval=$1
  shift
  count=$1
  shift

  while [ 1 = 1 ]; do
    echo
    CURDATE=`date +"%D %T"`
    echo "######################## $CURDATE ########################"
    $ORA_PROG $ARGS $*
    if [ $? -eq 1 ]; then
      exit 1
    fi

    if [ "$count" = "forever" ]; then
      continue;
    else
       let "count=count-1"
       if [ $count -le 0 ]; then
        break;
       fi;
    fi;

    sleep $interval

  done;
  exit 0
fi

#####################################################################################################

if [ "$1" = "sessions" ]; then

  if [ "$2" = "" -o "$2" = "active" ]; then
    PRED=" and status='ACTIVE' and type<>'BACKGROUND' "
    echo "active sessions and not BACKGROUND:"
  else
    PRED=""
    echo "all sessions:"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200
    col username format A15 trunc
    col inst_id format 9999
    col sid format 999999
    col serial# format 999999
    col pid format a6
    col cl_pid format A10
    col module format A8 trunc
    col program format a8 trunc
    col event format a15 trunc
    col sql_id format A13
    col logon_time format a20
    col status format a8
    col bl_i format 999999
    col bl_s format 999999

    select s.inst_id,s.sid,s.serial#--, s.PROCESS cl_pid
           , p.spid pid, s.username,status
           ,s.module
           ,blocking_instance as bl_i,blocking_session as bl_s,event
           --,s.type--, s.server,
           ,s.PROGRAM, sql_id--$COLNM $COLNM_HEADER
           ,to_char(logon_time,'yyyy-mm-dd hh24:mi:ss') as logon_time
           ,P.PGA_ALLOC_MEM
           ,P.PGA_USED_MEM
    from gv\$session s, gv\$process p
    where s.PADDR = p.addr  $PRED
          and s.inst_id=p.inst_id and s.inst_id=$INST
    order by logon_time;
    $ECHO
!

echo "example:ora sessions [active]|all   (order by logon_timie)"
echo "instance_number=$INST"
exit 0
fi

#######################################################################################################

if [ "$1" = "degree" -o "$1" = "parallel" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set linesize 200
    col degree format A6
    col instances format A13
    col table_name format A30
    col owner format a30
    col index_name format A30
    col SID format 99999
    col QCSID format 99999
    col PID format 9999
    col SPID format 9999999
    col Inst format 999999
    col Group format 999999
    col Set format 999999
    col Degree format a12
    col "Req Degree" format 999999
    col "Wait Event" format A30
    spool ora_degree_$filedate.log

    pro Table with degree summary:
    select owner,trim(degree) as degree,count(*)
    from dba_tables
    where trim(degree)<>'1' group by owner,trim(degree)
    order by 1,2,3;
    $ECHO

    Pro Table with degree Detail:
    select owner,table_name,trim(degree) as degree from dba_tables
    where trim(degree)<>'1' order by 1,2;
    $ECHO

    Pro Index with degree Summary:
    select owner,trim(degree) as degree,count(*)
    from dba_indexes
    where trim(degree)not in('1','0') group by owner,trim(degree)
    order by 1,2,3;
    $ECHO

    Pro Index with degree Detail:
    select owner,table_name,index_name,trim(degree) as degree from dba_indexes
    where trim(degree)not in('1','0') order by 1,2;
    $ECHO

    Pro Parallel process running:
      select s.sql_id,px.qcsid, px.SID "SID", p.PID, p.SPID "SPID", px.INST_ID "Inst",
             px.SERVER_GROUP "Group", px.SERVER_SET "Set",
             px.DEGREE "Degree", px.REQ_DEGREE "Req Degree"
      from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p
      where s.sid (+) = px.sid
        and s.inst_id (+) = px.inst_id
        and s.paddr = p.addr (+)
        and s.inst_id = p.inst_id (+)
      ORDER BY decode(px.QCINST_ID, NULL, px.INST_ID, px.QCINST_ID), px.QCSID,
               decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
               px.SERVER_SET, px.INST_ID;
      $ECHO
      spool off
!
exit 0
fi

########################################################################################################

if [ "$1" = "histogram" ]; then

  if [ "$2" = "" ]; then
    echo "ora histogram owner tabel_name col_name"
    exit 1
  fi

  owner=$2
  tname=$3
  cname=$4

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 200

    COL endpoint_value FORMAT A40
    col owner format a10 trunc
    col table_name format a20 trunc
    col column_name format a20 trunc

    select owner,table_name,column_name,endpoint_value, pct_total
        from
        (
        select a.owner,a.table_name,a.column_name,nvl(endpoint_actual_VALUE,endpoint_value) as endpoint_value,endpoint_number curr_ep,
               lag(endpoint_number,1,0) over(order by endpoint_number) prev_ep,
               (endpoint_number - lag(endpoint_number,1,0) over (order by endpoint_number)) num_in_bkt,
               max(endpoint_number) over () last_ep,
               round((endpoint_number - lag(endpoint_number,1,0) over (order by endpoint_number)) / max(endpoint_number) over (), 4) * 100 pct_total,
               row_number() over (order by endpoint_number) rn
          from dba_tab_histograms a ,dba_tab_columns b
         where a.owner =upper( '$owner')
           and a.table_name = upper('$tname')
           and a.column_name = upper('$cname')
           and b.table_name=a.table_name
           and b.owner=a.owner
           and b.column_name=a.column_name
           and b.histogram<>'NONE'
        ) ORDER BY pct_total;
      $ECHO
!
exit 0
fi

###################################################################################################

if [ "$1" = "lock" -o "$1" = "blocker" -o "$1" = "wait_chain" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 300 pagesize 30
    col "sid and serial@inst_id" format a32
    col OBJECT_NAME format a25
    col SQL_TEXT format a80 trunc
    col event format a30
    col module format a10 trunc
    col machine format a15 trunc
    spool ora_lock_$filedate.log
    pro
    pro SHOW Blocking and Blocked Session Information...
     WITH sessions AS
        (SELECT /*+materialize*/
                sid,serial#,inst_id,module, machine,blocking_session, BLOCKING_INSTANCE,row_wait_obj#, sql_id,event
           FROM gv\$session
         )
    SELECT LPAD(' ', 4*(LEVEL-1) ) || sid||','||serial# ||'@'||s.inst_id as "sid and serial@inst_id",
    s.module, s.machine, object_name, s.sql_id, s.event, substr(sql_text,1,100) sql_text
       FROM sessions s
       LEFT OUTER JOIN dba_objects
            ON (object_id = row_wait_obj#)
       LEFT OUTER JOIN gv\$sqlarea gs--in case of duplicate sql_id
            on (s.sql_id=gs.sql_id and s.inst_id=gs.inst_id)
      WHERE (s.sid,s.inst_id) IN (SELECT blocking_session,BLOCKING_INSTANCE FROM sessions)
            OR blocking_session IS NOT NULL
      CONNECT BY PRIOR s.sid = blocking_session and prior s.inst_id=blocking_instance --bug found by Albert Liang
      START WITH blocking_session IS NULL;
      $ECHO

    col obj_name format a30
    col pin_cnt format 999
    col pin_mode format 999
    col pin_req format 999
    col state format a30
    col event format a30
    col wait_time format 999999999
    col seconds_in_wait format 999999999

    Pro Show create or replace procedure hang Information...

    select distinct ses.ksusenum sid, ses.ksuseser serial#,
               ob.kglnaobj obj_name,
               pn.kglpncnt pin_cnt, pn.kglpnmod pin_mode, pn.kglpnreq pin_req,
               w.state, w.event, w.wait_time, w.seconds_in_Wait
    from   x\$kglpn pn, x\$kglob ob, x\$ksuse ses, v\$session_wait w
    where  pn.kglpnhdl in (select kglpnhdl from x\$kglpn where kglpnreq > 0)
    and    ob.kglhdadr = pn.kglpnhdl
    and    pn.kglpnuse = ses.addr
    and    w.sid = ses.indx
    order by seconds_in_wait desc;
    $ECHO

    Pro Show v\$locked_object Information...
    col owner format a20
    col object_name format a30
    col oracle_username format a20
    col os_user_name format a20
    select do.OWNER, do.OBJECT_NAME, do.OBJECT_ID, lo.SESSION_ID, lo.ORACLE_USERNAME, lo.OS_USER_NAME, lo.PROCESS, lo.LOCKED_MODE
    from dba_objects do, v\$locked_object lo
    where do.OBJECT_ID = lo.OBJECT_ID
    order by owner,object_name;
    $ECHO
    spool off
!
echo "full nodes"
exit 0
fi

###################################################################################################

if [ "$1" = "awrsnap" -o "$1" = "listsnap" ]; then

    if [ "$2" = "" ]; then
     days=3
  else
     days=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 30
    set linesize 150
    col begin_interval_time format a20
    col end_interval_time format a20
    col startup_time  format a20

    break on startup_time
     select  instance_number,snap_id-1 as begin_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,snap_id as end_snapid
            ,to_char(end_interval_time,'yyyy-mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot
     where end_interval_time>sysdate-$days and instance_number=$INST
     order by instance_number,snap_id;
     $ECHO

     Pro AWR setting:
     select
       extract( day from snap_interval) *24*60+  extract( hour from snap_interval) *60+  extract( minute from snap_interval ) as  "Interval_min",
       extract( day from retention) + extract( hour from retention) /24 +   extract( minute from retention )/24/60 as  "Retention_days"
     from dba_hist_wr_control;

!
echo "display awr snapshots for recent $days days."
exit 0
fi

######################################################################################################

if [ "$1" = "mvsnap" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80
    col status format A15
    col name format A30

    select name, status
    from all_snapshots order by 1;
    $ECHO
!
exit 0
fi

#################################################################################################

if [ "$1" = "asm" ]; then
  sqlplus -s  /NOLOG  << ! | egrep -v "Session altered|Connected|rows selected"
  connect $DBUSER

set linesize 500
set serveroutput on
set feedback off
set verify off

declare
  v_cnt number;
  cursor c_group is SELECT
    GROUP_NUMBER,
    NAME as DISKGROUP_NAME,
    lpad(round(ALLOCATION_UNIT_SIZE/1024/1024) || 'M',7) as "AU_SIZE",
    STATE,
    TYPE,
    round(TOTAL_MB/1024) as TOTAL_GB,
    round(FREE_MB/1024) as FREE_GB,
    lpad(round((TOTAL_MB-FREE_MB)/TOTAL_MB*100) || '%',9) as Used_Pct,
    round(USABLE_FILE_MB/1024) as "USABLE_FILE_GB" ,
    REQUIRED_MIRROR_FREE_MB
from
    V\$ASM_DISKGROUP;
  v_group c_group%rowtype;
  cursor c_disk is select
  decode(b.GROUP_NUMBER,null,'None',b.GROUP_NUMBER) as GROUP_NUMBER,
  decode(b.name,null,'None',b.name) as DISKGROUP_NAME,
  decode(a.path,null,'None',a.path) as path,
  decode(a.FAILGROUP,null,'None',a.FAILGROUP) as FAILGROUP,
  decode(a.name,null,'None',a.name) as DISK_NAME,
  a.STATE,a.MODE_STATUS,
  a.HEADER_STATUS,
  a.MOUNT_STATUS,
  a.REPAIR_TIMER,
  CASE WHEN (PATH IS NULL AND MOUNT_STATUS <> 'CACHED' or HEADER_STATUS <> 'MEMBER' or a.NAME LIKE '_DROPPED%') and b.TYPE <> 'EXTERN' THEN
  'alter diskgroup ' || b.NAME || ' add failgroup ' || a.FAILGROUP || ' disk ' || q'[']' || a.path || q'[']' || q'[ force;]'
  ELSE 'None'
  END AS ADD_DISK_FORCE_SQL
from v\$asm_disk a left join v\$asm_diskgroup b
on a.GROUP_NUMBER = b.GROUP_NUMBER
order by b.GROUP_NUMBER,a.path;
  v_disk c_disk%rowtype;

  cursor c_client is select GROUP_NUMBER,INSTANCE_NAME,DB_NAME,STATUS,SOFTWARE_VERSION,COMPATIBLE_VERSION from v\$asm_client order by GROUP_NUMBER;
  v_client c_client%rowtype;

begin
  select count(*) into v_cnt from v\$ASM_DISKGROUP;
if v_cnt = 0 then
  dbms_output.put_line('
ASM Diskgroup is not in Useage');
  dbms_output.put_line('======================');
else
  dbms_output.put_line('
ASM Diskgroup Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| GROUP# |' || ' DISKGROUP_NAME ' || '| AU_SIZE |' || '     STATE ' || '|   TYPE |' || ' TOTAL_GB ' || '| FREE_GB |' || ' "Used_Pct%" ' || '| USABLE_FILE_GB |' || ' REQUIRED_MIRROR_FREE_MB ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------');
  open c_group;
    loop fetch c_group into v_group;
    exit when c_group%notfound;
    dbms_output.put_line('| ' || rpad(v_group.GROUP_NUMBER,6) ||' | '|| rpad(v_group.DISKGROUP_NAME,14) || ' | '|| lpad(v_group.AU_SIZE,7) || ' | '|| lpad(v_group.STATE,9) || ' | '|| lpad(v_group.TYPE,6) || ' | '|| lpad(v_group.TOTAL_GB,8) || ' | '|| lpad(v_group.FREE_GB,7) || ' | '|| lpad(v_group.Used_Pct,11) || ' | '|| lpad(v_group.USABLE_FILE_GB,14) || ' | '|| lpad(v_group.REQUIRED_MIRROR_FREE_MB,24) || '|');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------');
  close c_group;
  dbms_output.put_line('
G# Means GROUP#
MODE_S Means MODE_STATUS
HEAD_S Means HEADER_STATUS
MOUNT_S Means MOUNT_STATUS
REPAIR? Means REPAIR_TIMER
ASM Disk Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| G# |' || ' GROUP_NAME ' || '|                         PATH |' || '      FAILGROUP ' || '|      DISK_NAME |' || '  STATE ' || '| MODE_S |' || ' HEAD_S ' || '| MOUNT_S |' || ' REPAIR? ' || '| ADD_DISK_FORCE_SQL_COMMAND                       ' || '|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_disk;
    loop fetch c_disk into v_disk;
    exit when c_disk%notfound;
    dbms_output.put_line('| ' || rpad(v_disk.GROUP_NUMBER,2) ||' | '|| rpad(v_disk.DISKGROUP_NAME,10) || ' | '|| lpad(v_disk.path,28) || ' | '|| lpad(v_disk.FAILGROUP,14) || ' | '|| lpad(v_disk.DISK_NAME,14) || ' | '|| lpad(v_disk.STATE,6) || ' | '|| lpad(v_disk.MODE_STATUS,6) || ' | '|| lpad(v_disk.HEADER_STATUS,6) || ' | '|| lpad(v_disk.MOUNT_STATUS,7) || ' | '|| lpad(v_disk.REPAIR_TIMER,7) || ' | ' ||rpad(v_disk.ADD_DISK_FORCE_SQL,48) || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_disk;

dbms_output.put_line('
ASM Client Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------');
  dbms_output.put_line('|  G# |' || ' INSTANCE_NAME ' || '|  DB_NAME |' || '      STATUS |' || ' SOFTWARE_VERSION ' || '| COMPATIBLE_VERSION ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------');
  open c_client;
    loop fetch c_client into v_client;
    exit when c_client%notfound;
    dbms_output.put_line('| ' || rpad(v_client.GROUP_NUMBER,3) ||' | '|| lpad(v_client.INSTANCE_NAME,13) || ' | '|| lpad(v_client.DB_NAME,8) || ' | '|| lpad(v_client.STATUS,11) || ' | '|| lpad(v_client.SOFTWARE_VERSION,16) || ' | '|| lpad(v_client.COMPATIBLE_VERSION,19) || '|');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------');
  close c_client;
  end if;
end;
/

prompt asm_rebalance_file

SELECT
    file_num,
    MAX(extent_count) max_disk_extents,
    MIN(extent_count) min_disk_extents,
    MAX(extent_count) - MIN(extent_count) disk_extents_imbalance
FROM (
    SELECT
    number_kffxp file_num,
    disk_kffxp disk_num,
    COUNT(xnum_kffxp) extent_count
    FROM
        x\$kffxp
    WHERE
        group_kffxp = 1
        AND disk_kffxp != 65534
        GROUP BY number_kffxp, disk_kffxp
        ORDER BY number_kffxp, disk_kffxp)
GROUP BY file_num
HAVING MAX(extent_count) - MIN(extent_count) > 5
ORDER BY disk_extents_imbalance DESC;

  $ECHO
!
exit 0
fi

##################################################################################################

if [ "$1" = "parameter" ]; then

  if [ "$2" = "" ]; then
     kw=""
     kw2=""
  else
     kw=" and parameter_name like '%$2%' "
     kw2=" and name like '%$2%' "
  fi

   if [ "$3" = "" ]; then
     snaps=2
   else
     snaps=$3
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 100
    col parameter_name format a40
    col name format a40
    col value format a60 trunc
    Prompt Display Parameters in last snapshot(dba_hist_parameter):

    select instance_number,snap_id,parameter_name as name,value
    from dba_hist_parameter
    where snap_id>(select max(snap_id)-$snaps from dba_hist_snapshot)
     and isdefault ='FALSE'
     and instance_number=$INST
     and parameter_name not like '\_\_%' escape '\' $kw
    order by instance_number,snap_id,parameter_name;
    $ECHO


    Prompt Display Parameters in gv#parameter:

    select inst_id,name,display_value as value from gv\$parameter
     where  isdefault ='FALSE' and inst_id=$INST
     and name not like '\_\_%' escape '\' $kw2
     order by inst_id,name;
    $ECHO

!
echo "show Parameters in his and current"
echo inst_id=$INST
exit 0
fi

#'
##################################################################################################

if [ "$1" = "params" ]; then

  if [ "$2" != "" ]; then
    PAT="%${2}%"
  else
    PAT="%"
  fi
  echo''
  echo 'OS Parameter Information'
  echo '======================'
  echo 'redhat-release:' `cat /etc/redhat-release`
  echo 'hostname:' `hostname`
  echo 'UDP Buffer ipfrag_low_thresh:' `cat /proc/sys/net/ipv4/ipfrag_low_thresh` ' Bytes'
  echo 'UDP Buffer ipfrag_high_thresh:' `cat /proc/sys/net/ipv4/ipfrag_high_thresh` ' Bytes'
  echo 'open files:' `ulimit -a | grep files | awk '{print $4}'`
  echo 'max user processes:' `ulimit -a | grep processes | awk '{print $5}'`
  cat /proc/meminfo |grep -E 'Mem|Cache|Swap|Huge'
  echo 'watchdog process:' `ps -ef | grep watchdog | grep -v grep | awk '{print $8}'  | grep -v bash`
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    col name format A50
    col value format A20
    col description format A70 trunc
    set timing off
    set serveroutput on
    set feedback off
    set verify off
    set linesize 500
    undefine table_name
    undefine owner
    var table_name varchar2(100);
    var owner varchar2(100);
declare

 cursor c_para is select
    ksppinm as name,
    ksppstvl as value,
    case when ksppinm = '_optim_peek_user_binds' and ksppstvl <> 'TRUE'
      then 'Recommend set <TRUE>, Peep through statistical information histogram binding variables'
     when ksppinm = '_undo_autotune' and ksppstvl = 'TRUE'
      then 'Recommend set <FALSE>, default value is TRUE Doc 1574714.1'
     when ksppinm = '_optimizer_adaptive_cursor_sharing' and ksppstvl <> 'TRUE'
      then 'Recommend set <TRUE>, solves the execution plan remains unchanged after binding variable peeping issue'
     when ksppinm = '_optimzer_adaptive_extended_cursor_sharing' and ksppstvl <> 'UDO'
      then 'Set to <UDO>, solve the execution plan remains unchanged after binding variable peeping issue'
     when ksppinm = '_optimizer_extended_cursor_sharing_rel' and  ksppstvl <> 'SIMPLE'
      then 'Set default value <SIMPLE>, solve the execution plan remains unchanged after binding variable peeping issue'
     when ksppinm = '_optimizer_extended_cursor_sharing' and  ksppstvl <> 'UDO'
      then 'Set default value <UDO>, solve the execution plan remains unchanged after binding variable peeping issue'
     when ksppinm = 'optimizer_index_caching' and ksppstvl <> 0
      then 'optimizer_index_caching should set to <0>, default value is 0'
     when ksppinm = 'optimizer_index_cost_adj' and ksppstvl <> 100
      then 'optimizer_index_cost_adj should set to <100>, default value is 100'
     when ksppinm = '_serial_direct_read' and ksppstvl <> 'auto'
      then 'Recommend to set to <auto>, Only when the table is small can we consider setting it to never'
     when ksppinm = '_gc_policy_time' and ksppstvl <> 0
      then '_gc_policy_time recommend to set to <0> to global close DRM'
     when ksppinm = '_gc_undo_affinity' and ksppstvl = 'TRUE'
      then '_gc_undo_affinity recommend to set to <FALSE> to global close DRM'
     when ksppinm = '_memory_imm_mode_without_autosga' and ksppstvl = 'TRUE'
      then 'If Necessary Can be set to <FALSE> to avoid Memory Competition'
     when ksppinm = 'parallel_force_local' and ksppstvl <> 'TRUE'
      then 'Recommend to set to <TRUE> to Avoid GC issue except IB network'
     when ksppinm = '_PX_use_large_pool' and ksppstvl = 'FALSE'
      then 'Recommend to set to <TRUE> to use large pool'
     when ksppinm = 'optimizer_adaptive_plans' and ksppstvl = 'TRUE'
      then '12c new feature,default <TRUE>, recommend to set to <FALSE> see Doc ID 2187449.1'
     when ksppinm = 'adaptive_adaptive_statistics' and ksppstvl = 'TRUE'
      then '12.2 default <FALSE>, recommend to set to <FALSE>'
     when ksppinm = '_optimizer_cbqt_or_expansion' and ksppstvl = 'TRUE'
      then '12.2 default <FALSE>, recommend to set to <FALSE>'
     when ksppinm = '_cursor_obsolete_threshold' and ksppstvl > 1024
      then '12.2 default value 8192, this can cause high version count issue,set <1024>'
     when ksppinm = '_b_tree_bitmap_plans' and ksppstvl = 'TRUE'
      then 'In some cases, the session level can be set to <FALSE>'
     when ksppinm = 'optimizer_dynamic_sampling' and ksppstvl <> 2
      then 'Set default value <2>'
     when ksppinm = '_use_single_log_writer' and ksppstvl <> 'TRUE'
      then '12c new features recommend to set to <TRUE> to avoid parallel write Issue'
     when ksppinm = '_use_adaptive_log_file_sync' and ksppstvl ='TRUE'
      then 'Set <False>, Above 11203 <TRUE> May Cause log sync Issue,refer to DOC 1462942.1'
     when  ksppinm = '_optimizer_use_feedback' and ksppstvl ='TRUE'
      then 'Recommend to set <False> to close _optimizer_use_feedback '
     when ksppinm = '_datafile_write_errors_crash_instance' and ksppstvl = 'TRUE'
      then 'Recommend to set to False, Instance Crashes After IO Error Doc 2453717.1'
     when ksppinm = '_clusterwide_global_transactions' and ksppstvl <> 'TRUE'
      then 'In RAC Env,May Cause 2PC Transaction Issue, Set <True>'
     when ksppinm = '_kcfis_storageidx_diag_mode' and ksppstvl = '2'
      then 'Open the Debug mode for storage index on the cell'
     when ksppinm = '_rollback_segment_count' and ksppstvl < '100'
      then 'Recommend to set to <12000>'
     when ksppinm = '_ash_size' and ksppstvl <= '1048618'
      then 'Set <250M> If SGA is large enough, See Doc ID 1385872.1,Document 1952274.1,Document 243132.1'
     when ksppinm = '_adg_parselock_timeout' and ksppstvl < '500'
      then 'ADG Env set 500, Avoid Instance Crash ref Doc ID 2183882.1 19C also default 0' end as advice
      from x\$ksppi x, x\$ksppcv y
      where x.indx = y.indx
      and ksppinm in ('_kcfis_storageidx_diag_mode','__db_cache_size','_ksmg_granule_size',
      '_gby_hash_aggregation_enabled','_external_scn_rejection_threshold_hours',
      '_external_scn_logging_threshold_seconds',
      '_ash_size',
      '_lm_tickets',
      '_lm_sync_timeout',
      '_bloom_filter_enabled',
      '_memory_imm_mode_without_autosga',
      '_small_table_threshold',
      '_very_large_object_threshold',
      '_kcfis_storageidx_disabled',
      '_serial_direct_read',
      '_very_large_object_threshold',
      '_adg_parselock_timeout',
      '_max_outstanding_log_writes',
      '_use_single_log_writer',
      '_datafile_write_errors_crash_instance',
      '_use_adaptive_log_file_sync',
      '_undo_autotune',
      '_optim_peek_user_binds',
      '_optimizer_use_feedback',
      '_optimizer_adaptive_cursor_sharing',
      '_optimizer_extended_cursor_sharing',
      '_optimizer_extended_cursor_sharing_rel',
      'optimizer_index_caching',
      'optimizer_index_cost_adj',
      'db_file_multiblock_read_count',
      'optimizer_dynamic_sampling',
      '_cleanup_rollback_entries',
      '_cursor_obsolete_threshold',
      '_b_tree_bitmap_plans',
      'optimizer_mode',
      '_gc_policy_time',
      '_gc_undo_affinity',
      '_optimizer_group_by_placement',
      'optimizer_adaptive_plans',
      '_PX_use_large_pool',
      'parallel_force_local',
      '_clusterwide_global_transactions',
      'optimizer_adaptive_features',
      '_optimizer_inmemory_access_path',
      '_optimizer_cbqt_or_expansion',
      '_optimizer_unnest_scalar_sq',
      '_sql_plan_directive_mgmt_control',
      '_optimizer_dsdir_usage_control',
      '_rollback_segment_count',
      '_highthreshold_undoretention',
      '_smm_max_size',
      '_pga_max_size',
      '_px_adaptive_dist_method',
      '_optimizer_strans_adaptive_pruning',
      '_optimizer_nlj_hj_adaptive_join'
      )
      union all
      select
      name,
      decode(value,null,'None',value) as value,
      case when name = 'open_cursors' and (value < 300 or value > 1000) then 'open_cursors recommend to set to more than <300>, 3000 is enough'
           when name = 'control_file_record_keep_time' and value <= 15 then 'control_file_record_keep_time recommend to set to <31>,Doc 47322.1'
           when name = 'cursor_sharing' and value <> 'EXACT' then 'Recommend to set to <EXACT>, <FORCE> Forcing SQL that does not use binding variables into binding variables'
           when name = 'audit_trail' and value <> 'NONE' then 'If necessary set value to <NONE> to close Audit'
           when name = 'sesssion_cached_cursors' and value > 100 then 'No need to set too large, Set the maximum number of closed cursors that can be cached in each session.'
           when name = 'deferred_segment_creation' and value <> 'FALSE' then '<TRUE> will result in the failure to export an empty table ,Mos 1216282.1'
           when name = 'enable_ddl_logging' and value <> 'TRUE' then '<TRUE> enable alert log records DDL statements'
           when name = 'undo_retention' and value < 1800 then 'Recommend to set to 10800 and set a large enough undo tablespace'
           when name = 'statistics_level' and value <> 'TYPICAL' then 'Recommend to set it to the default value <TYPICAL>'
           when name = 'result_cache_mode' and value <> 'MANUAL' then 'Recommend to set to <MANUAL>'
           when name = 'result_cache_max_size' and value <> 0 then 'Recommend to set to <0>'
           when name = 'memory_target' and value <> 0 then 'Recommend to set to <0> to close AMM'
           when name = 'memory_max_target' and value <> 0 then 'Recommend to set to <0> to close AMM'
           when name = 'db_files' and value < 5000 then 'Recommend to set to more than <5000>'
           when name = 'open_links' and value <= 10 then 'In lots of dblink DB System, set <100> Doc ID 1469649.1'
           when name = 'processes' and value < 5000 then 'Recommend to set to more than <5000>'
           when name = 'job_queue_processes' and value < 1000 then 'Recommend to set to more than <1000>'
           when name = 'sga_target' and value = 0 then 'Recommend to set the same value with sga_max_size'
           when name = 'sga_max_size' and value < 100 then 'According to the business and system memory settings'
           when name = 'db_cache_size' and value = 0 then 'Recommend to set a minimum value'
           when name = 'event' and value is null then 'alter system set event ="28401 TRACE NAME CONTEXT FOREVER, LEVEL 1" scope=spfile;'
           when name = 'shared_pool_size' and value = 0 then 'Recommend to set a minimum value eg set 20G'
           when name = 'pga_aggregate_target' and value < 100 then 'According to the business and system memory settings'
           when name = 'fast_start_parallel_rollback' and value = 'FALSE' then '<FALSE> means Parallel rollback is disabled, <LOW> Limits the maximum degree of parallelism to 2 * CPU_COUNT'
           when name = 'optimizer_adaptive_statistics' and value <> 'FALSE' then 'set <FALSE> see Doc ID 2187449.1' end as adivce
           from v\$parameter
           where name in (
           'open_cursors',
           'control_file_record_keep_time',
           'cursor_sharing',
           'audit_trail',
           'session_cached_cursors',
           'deferred_segment_creation',
           'enable_ddl_logging',
           'undo_retention',
           'large_pool_size',
           'statistics_level',
           'result_cache_mode',
           'result_cache_max_size',
           'job_queue_processes',
           'processes',
           'db_files',
           'shared_pool_size',
           'db_cache_size',
           'pga_aggregate_target',
           'sga_target',
           'sga_max_size',
           'memory_target',
           'memory_max_target',
           'event',
           'archive_lag_target',
           'fast_start_parallel_rollback',
           'optimizer_adaptive_statistics',
           'open_links'
          )
           order by name;
    v_para c_para%rowtype;


begin


  dbms_output.put_line('
Parameter Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| Parameter Name                         |' || ' VALUE          ' || '| Advice                                                                                             |');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_para;
    loop fetch c_para into v_para;
    exit when c_para%notfound;
    dbms_output.put_line('| ' || rpad(v_para.name,38) ||' | '|| rpad(v_para.VALUE,14) || ' | '|| rpad(v_para.ADVICE || '.',98) || ' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_para;

dbms_output.put_line(' Close Audit');
dbms_output.put_line('======================');
dbms_output.put_line('NOAUDIT ALTER ANY PROCEDURE;');
dbms_output.put_line('NOAUDIT ALTER ANY TABLE;');
dbms_output.put_line('NOAUDIT ALTER DATABASE;');
dbms_output.put_line('NOAUDIT ALTER PROFILE;');
dbms_output.put_line('NOAUDIT ALTER SYSTEM;');
dbms_output.put_line('NOAUDIT ALTER USER;');
dbms_output.put_line('NOAUDIT AUDIT SYSTEM;');
dbms_output.put_line('NOAUDIT CREATE ANY JOB;');
dbms_output.put_line('NOAUDIT CREATE ANY LIBRARY;');
dbms_output.put_line('NOAUDIT CREATE ANY PROCEDURE;');
dbms_output.put_line('NOAUDIT CREATE ANY TABLE;');
dbms_output.put_line('NOAUDIT CREATE EXTERNAL JOB;');
dbms_output.put_line('NOAUDIT CREATE PUBLIC DATABASE LINK;');
dbms_output.put_line('NOAUDIT CREATE SESSION;');
dbms_output.put_line('NOAUDIT CREATE USER;');
dbms_output.put_line('NOAUDIT DATABASE LINK;');
dbms_output.put_line('NOAUDIT DROP ANY PROCEDURE;');
dbms_output.put_line('NOAUDIT DROP ANY TABLE;');
dbms_output.put_line('NOAUDIT DROP PROFILE;');
dbms_output.put_line('NOAUDIT DROP USER;');
dbms_output.put_line('NOAUDIT EXEMPT ACCESS POLICY;');
dbms_output.put_line('NOAUDIT GRANT ANY OBJECT PRIVILEGE;');
dbms_output.put_line('NOAUDIT GRANT ANY PRIVILEGE;');
dbms_output.put_line('NOAUDIT GRANT ANY ROLE;');
dbms_output.put_line('NOAUDIT PROFILE;');
dbms_output.put_line('NOAUDIT PUBLIC SYNONYM;');
dbms_output.put_line('NOAUDIT ROLE;');
dbms_output.put_line('NOAUDIT SYSTEM AUDIT;');
dbms_output.put_line('NOAUDIT SYSTEM GRANT;');

end;
/

    $ECHO
!
exit 0
fi

#######################################################################################################

if [ "$1" = "session_event" ]; then

  if [ "$2" = "px" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 6000
      set linesize 150

      col SID format 99999
      col QCSID format 99999
      col PID format 9999
      col SPID format 9999999
      col Inst format 999999
      col Group format 999999
      col Set format 999999
      col Degree format 999999
      col "Req Degree" format 999999
      col "Wait Event" format A30
      col sql_hash format A15

      select px.qcsid, px.SID "SID", p.PID, p.SPID "SPID", px.INST_ID "Inst",
             px.SERVER_GROUP "Group", px.SERVER_SET "Set",
             px.DEGREE "Degree", px.REQ_DEGREE "Req Degree",
             w.event "Wait Event", s.SQL_HASH_VALUE hash_value
      from GV\$SESSION s, GV\$PX_SESSION px, GV\$PROCESS p, GV\$session_wait w
      where s.sid (+) = px.sid
        and s.inst_id (+) = px.inst_id
        and s.sid = w.sid (+)
        and s.inst_id = w.inst_id (+)
        and s.paddr = p.addr (+)
        and s.inst_id = p.inst_id (+)
      ORDER BY decode(px.QCINST_ID, NULL, px.INST_ID, px.QCINST_ID), px.QCSID,
               decode(px.SERVER_GROUP, NULL, 0, px.SERVER_GROUP),
               px.SERVER_SET, px.INST_ID;
      $ECHO
!
  else

     SQLSTRING="select inst_id, event, count(*) from gv\$session_wait where wait_time = 0"

     if [ "$2" = "noidle" ]; then
       SQLSTRING=${SQLSTRING}" and wait_class <> 'Idle'"
     fi

     SQLSTRING=${SQLSTRING}" group by inst_id, event order by inst_id, event"
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 10000
      set linesize 150

      ${SQLSTRING};
!
  fi
echo "instance_number=$INST"
exit 0
fi

#####################################################################################################################
if [ "$1" = "temp" -o "$1" = "tmp" ] ; then

  if [ "$2" != "" ]; then
    EXTRA_PRED="AND   s.username=upper('$2')"
  else
    EXTRA_PRED=""
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 10000
    set linesize 80
    col file_name format A40
    col USED_SPACE format A20
    col MAX_USED_SPACE format A20
    spool ora_temp_$filedate.log

    prompt Used Temp tablespace:
    prompt ======================
    select round(used_blocks*(select max(BLOCK_SIZE) from dba_tablespaces where tablespace_name='SYSTEM') /1024/1024)+1 || ' MB (used)' as used_space,
           round(max_used_blocks*8/1024)+1 ||' MB (max used)' as max_used_space
    from gv\$sort_segment where inst_id=$INST;
    $ECHO

    prompt TEMP_TABLESPACE FILE TOTAL SIZE:
    prompt ======================
    select sum(round(BYTES/1024/1024)+1) total_size_mb from dba_temp_files ;
    $ECHO

   set linesize 500
   set serveroutput on
   set feedback off
   set verify off
declare
    v_cnt number;

     cursor c_tmp is SELECT C.SQL_ID,
       A.USERNAME,
       A.SID||','||A.SERIAL# as sid_and_serial,
       A.OSUSER,
       A.MACHINE,
       A.LAST_CALL_ET as elapse_time,
       B.TABLESPACE as TABLESPACE_NAME,
       (B.BLOCKS * (select value from v\$parameter where name='db_block_size')/1024/1024) as USED_MB,
       C.SQL_TEXT
  FROM V\$SESSION A, V\$TEMPSEG_USAGE B, V\$SQLAREA C
 WHERE A.SADDR = B.SESSION_ADDR
   AND C.ADDRESS = A.SQL_ADDRESS
   AND C.HASH_VALUE = A.SQL_HASH_VALUE
order by b.blocks;
    v_tmp c_tmp%rowtype;

    cursor c_pga is select /*+ ordered leading(d) */ c.sql_id, a.username, a.sid||','||a.serial# as sid_and_serial, a.machine, a.LAST_CALL_ET as elapse_time, to_char(a.logon_time,'yyyymmdd hh24:mi:ss') as LOGON_TIME,
    round(d.PGA_USED_MEM / 1024 / 1024,2) as PGA_USED_MB, c.sql_text
    from v\$process d,v\$session a,v\$sqlarea c
    where a.sql_id = c.sql_id
    and a.paddr = d.addr
    and d.PGA_USED_MEM >= 1024 * 1024 * 10
    order by d.PGA_USED_MEM;
    v_pga c_pga%rowtype;
    v_pga_cnt number;
    v_tmp_cnt number;

begin

  select count(*) into v_tmp_cnt FROM V\$SESSION A, V\$TEMPSEG_USAGE B, V\$SQLAREA C
 WHERE A.SADDR = B.SESSION_ADDR
   AND C.ADDRESS = A.SQL_ADDRESS
   AND C.HASH_VALUE = A.SQL_HASH_VALUE
order by b.blocks;
  if v_tmp_cnt > 0 then
  dbms_output.put_line('
Current Usage Information of Temp Tablespace Per Session');
  dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| SQL_ID        |'  || ' USERNAME     |' || ' sid_and_serial# ' || '|      MACHINE |' || ' ELAPSE_TIME(S) |'|| ' TABLESPACE_NAME ' || '| USED_MB |' || '                                          SQL_TEXT ' || '|');
  dbms_output.put_line('------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_tmp;
    loop fetch c_tmp into v_tmp;
    exit when c_tmp%notfound;
    dbms_output.put_line('| ' || lpad(v_tmp.SQL_ID,13) || ' | '||rpad(v_tmp.USERNAME,12) ||' | '|| lpad(v_tmp.sid_and_serial,15) || ' | '|| lpad(v_tmp.MACHINE,12) || ' | '|| lpad(v_tmp.elapse_time,14) || ' | ' ||lpad(v_tmp.TABLESPACE_NAME,15) || ' | '|| lpad(v_tmp.USED_MB,7) || ' | '|| rpad(v_tmp.SQL_TEXT,50)  || '|');
    end loop;
    dbms_output.put_line('------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_tmp;
  else
  dbms_output.put_line('
There is no Session that Use Temp Tablespace Disk Space');
  dbms_output.put_line('======================');
  end if;

 select count(*) into v_pga_cnt
 from v\$process d,v\$session a,v\$sqlarea c
    where a.sql_id = c.sql_id
    and a.paddr = d.addr
    and d.PGA_USED_MEM >= 1024 * 1024 * 10
    order by d.PGA_USED_MEM;
  if v_pga_cnt > 0 then

  dbms_output.put_line('
Current Usage Information of PGA Memory(>10M) Per Session');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| SQL_ID        |'  || ' USERNAME     |' || ' sid_and_serial# ' || '|      MACHINE |' || ' ELAPSE_TIME(S) |'|| '        LOGON_TIME ' || '| PGA_USED_MB |' || '                                      SQL_TEXT ' || '|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_pga;
    loop fetch c_pga into v_pga;
    exit when c_pga%notfound;
    dbms_output.put_line('| ' || lpad(v_pga.SQL_ID,13) || ' | '||rpad(v_pga.USERNAME,12) ||' | '|| lpad(v_pga.sid_and_serial,15) || ' | '|| lpad(v_pga.MACHINE,12) || ' | '|| lpad(v_pga.elapse_time,14) || ' | ' ||lpad(v_pga.LOGON_TIME,17) || ' | '|| lpad(v_pga.PGA_USED_MB,11) || ' | '|| rpad(v_pga.SQL_TEXT,46)  || '|');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_pga;
  else
  dbms_output.put_line('
There is no Session that PGA Memory Usage > 10M for Per Session');
  dbms_output.put_line('======================');
  end if;


end;
/


    $ECHO
    spool off

!
echo "instance_number=$INST"
  exit 0
fi

######################################################################################################

if [ "$1" = "event_set"  ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected|PL/SQL procedure"

    connect $DBUSER

    --set pagesize 10000
    --set linesize 200

    set linesize 200 pagesize 30
    col username format a11
    set serveroutput on size unlimited
    declare
     event_level number;
    begin
        dbms_output.put_line('list all trace event setted:');
        for i in 1..100000 loop
          sys.dbms_system.read_ev(i,event_level);
          if (event_level > 0) then
            dbms_output.put_line('   Event '||to_char(i)||' set at level '||to_char(event_level));
          end if;
     end loop;
    end;
    /

!
echo "display all events setted in the system,e.g. Alter system set events=..."
  exit 0
fi
###############################################################################################################

if [ "$1" = "longops" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 150 pagesize 40
    column opname format a30 wrap
    select * from
    (
     select inst_id,sid,sql_id, opname, sofar, totalwork,
           round(sofar*100/totalwork) percent,
           round(elapsed_seconds/60) "Elapsed (min)",
           decode(sofar,0,0,round(elapsed_seconds*(totalwork-sofar)/(sofar*60))) as "To go (min)",
           context dfo
    from gv\$session_longops
    where sofar != totalwork
    and inst_id=$INST
    order by elapsed_seconds desc
    )
    where rownum<=20;
  $ECHO
!
echo "instance_number=$INST"
echo "above info is top 20 long runing ops from gv_session_longops"
exit 0
fi

###################################################################################################

if [ "$1" = "sga" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"


    connect $DBUSER
    set serveroutput on
    set verify off
    set timing off
    set linesize 300
    set pages 1000
    set tab off
    set echo off
    repfooter off;
    set timing off veri off space 1 flush on pause off termout on numwidth 10;
    spool ora_sga_$filedate.log

    Pro v#sgastat:
    select nvl(pool, 'Total') pool,
           decode(name, NULL, decode(pool, NULL, NULL, '(total)'), name) name,
           round(sum(bytes)/1024) as size_kb
    from gv\$sgastat
    where pool is not null
          and name in ('free memory', 'PX msg pool', 'sql area','library cache')
          and inst_id=$INST
    group by rollup(pool, name)
    order by 3;
    $ECHO

    Pro v#sga_dynamic_components:
    col component format a40
    select substr(COMPONENT,1,25) COMPONENT,
          CURRENT_SIZE/1024/1024 CURRENT_SIZE_mb,
          MIN_SIZE/1024/1024 MIN_SIZE_MB, MAX_SIZE/1024/1024 MAX_SIZE_MB,
          LAST_OPER_TYPE, LAST_OPER_MODE
    from gv\$sga_dynamic_components
    where inst_id=$INST;
    $ECHO

    prompt
    prompt CURRENT SGA RESIZE OPERATIONS
    select COMPONENT, OPER_TYPE, OPER_MODE, PARAMETER
    from   gv\$sga_current_resize_ops
    where inst_id=$INST;
    $ECHO

    prompt SGA_RESIZE_OPS
    set pages 0 linesize 300
    col start_time for a30
    col end_time for a30
    SELECT substr(COMPONENT,1,25) COMPONENT,
    oper_type,initial_size/1024/1024 init_MB,target_size/1024/1024 target_MB,
    final_size/1024/1024 final_MB,status,
    to_char(start_time,'yyyymmdd hh24miss') as start_time,
    to_char(end_time,'yyyymmdd hh24miss') as end_time
    FROM gV\$SGA_RESIZE_OPS
    where PARAMETER in ('db_cache_size','shared_pool_size')
    and OPER_TYPE in ('GROW','SHRINK')
    and inst_id=$INST
    order by PARAMETER,START_TIME;

--alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
declare
    cursor c_sga is SELECT NAME, ROUND(TOTAL,2) TOTAL_MB, ROUND(TOTAL - FREE, 2) USED_MB, ROUND(FREE, 2) FREE_MB, ROUND((TOTAL - FREE) / TOTAL * 100, 2) pct_used
  FROM (SELECT 'SGA' NAME,
               (SELECT SUM(VALUE / 1024 / 1024) FROM v\$SGA) TOTAL,
               (SELECT SUM(BYTES / 1024 / 1024)
                  FROM v\$SGASTAT
                 WHERE NAME = 'free memory') FREE
          FROM DUAL)
UNION
SELECT NAME, ROUND(TOTAL,2) TOTAL_MB, ROUND(USED, 2) USED_MB, ROUND(TOTAL - USED, 2) FREE_MB, ROUND(USED / TOTAL * 100, 2) pct_used
  FROM (SELECT 'PGA' NAME,
               (SELECT VALUE / 1024 / 1024 TOTAL
                  FROM v\$PGASTAT
                 WHERE NAME = 'aggregate PGA target parameter') TOTAL,
               (SELECT VALUE / 1024 / 1024 USED
                  FROM v\$PGASTAT
                 WHERE NAME = 'total PGA allocated') USED
          FROM DUAL)
UNION
SELECT NAME, ROUND(TOTAL, 2) TOTAL_MB, ROUND((TOTAL - FREE), 2) USED_MB, ROUND(FREE, 2) FREE_MB, ROUND((TOTAL - FREE) / TOTAL * 100, 2) pct_used
  FROM (SELECT 'Shared pool' NAME,
               (SELECT SUM(BYTES / 1024 / 1024)
                  FROM v\$SGASTAT
                 WHERE POOL = 'shared pool') TOTAL,
               (SELECT BYTES / 1024 / 1024
                  FROM v\$SGASTAT
                 WHERE NAME = 'free memory'
                   AND POOL = 'shared pool') FREE
          FROM DUAL)
UNION
SELECT NAME, ROUND(TOTAL, 2) TOTAL_MB, ROUND(TOTAL - FREE, 2) USED_MB, ROUND(FREE, 2) FREE_MB, ROUND((TOTAL - FREE) / TOTAL * 100, 2) pct_used
  FROM (SELECT 'Default pool' NAME,
               (SELECT A.CNUM_REPL *
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size') / 1024 / 1024 TOTAL
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'DEFAULT'
                   AND P.BLOCK_SIZE =
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size')) TOTAL,
               (SELECT A.ANUM_REPL *
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size') / 1024 / 1024 FREE
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'DEFAULT'
                   AND P.BLOCK_SIZE =
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size')) FREE
          FROM DUAL)
UNION
SELECT NAME, NVL(ROUND(TOTAL, 2), 0) TOTAL_MB, NVL(ROUND(TOTAL - FREE, 2), 0) USED_MB, NVL(ROUND(FREE, 2), 0) FREE_MB, NVL(ROUND((TOTAL - FREE) / TOTAL, 2), 0) pct_used
  FROM (SELECT 'KEEP pool' NAME,
               (SELECT A.CNUM_REPL *
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size') / 1024 / 1024 TOTAL
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'KEEP'
                   AND P.BLOCK_SIZE =
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size')) TOTAL,
               (SELECT A.ANUM_REPL *
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size') / 1024 / 1024 FREE
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'KEEP'
                   AND P.BLOCK_SIZE =
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size')) FREE
          FROM DUAL)
UNION
SELECT NAME, NVL(ROUND(TOTAL, 2), 0) TOTAL_MB, NVL(ROUND(TOTAL - FREE, 2), 0) USED_MB, NVL(ROUND(FREE, 2), 0) FREE_MB, NVL(ROUND((TOTAL - FREE) / TOTAL, 2), 0) pct_used
  FROM (SELECT 'RECYCLE pool' NAME,
               (SELECT A.CNUM_REPL *
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size') / 1024 / 1024 TOTAL
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'RECYCLE'
                   AND P.BLOCK_SIZE =
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size')) TOTAL,
               (SELECT A.ANUM_REPL *
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size') / 1024 / 1024 FREE
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'RECYCLE'
                   AND P.BLOCK_SIZE =
                       (SELECT VALUE
                          FROM v\$PARAMETER
                         WHERE NAME = 'db_block_size')) FREE
          FROM DUAL)
UNION
SELECT NAME, NVL(ROUND(TOTAL, 2), 0) TOTAL_MB, NVL(ROUND(TOTAL - FREE, 2), 0) USED_MB, NVL(ROUND(FREE, 2), 0) FREE_MB, NVL(ROUND((TOTAL - FREE) / TOTAL, 2), 0) pct_used
  FROM (SELECT 'DEFAULT 16K buffer cache' NAME,
               (SELECT A.CNUM_REPL * 16 / 1024 TOTAL
                  FROM X\$KCBWDS A, v\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'DEFAULT'
                   AND P.BLOCK_SIZE = 16384) TOTAL,
               (SELECT A.ANUM_REPL * 16 / 1024 FREE
                  FROM X\$KCBWDS A, V\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'DEFAULT'
                   AND P.BLOCK_SIZE = 16384) FREE
          FROM DUAL)
UNION
SELECT NAME, NVL(ROUND(TOTAL, 2), 0) TOTAL_MB, NVL(ROUND(TOTAL - FREE, 2), 0) USED_MB, NVL(ROUND(FREE, 2), 0) FREE_MB, NVL(ROUND((TOTAL - FREE) / TOTAL, 2), 0) pct_used
  FROM (SELECT 'DEFAULT 32K buffer cache' NAME,
               (SELECT A.CNUM_REPL * 32 / 1024 TOTAL
                  FROM X\$KCBWDS A, V\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'DEFAULT'
                   AND P.BLOCK_SIZE = 32768) TOTAL,
               (SELECT A.ANUM_REPL * 32 / 1024 FREE
                  FROM X\$KCBWDS A, V\$BUFFER_POOL P
                 WHERE A.SET_ID = P.LO_SETID
                   AND P.NAME = 'DEFAULT'
                   AND P.BLOCK_SIZE = 32768) FREE
          FROM DUAL)
UNION
SELECT NAME, TOTAL as TOTAL_MB, TOTAL - FREE USED_MB, FREE as FREE_MB,
       (TOTAL - FREE) / TOTAL * 100 pct_used
  FROM (SELECT 'Java Pool' NAME,
               (SELECT SUM(BYTES / 1024 / 1024) TOTAL
                  FROM V\$SGASTAT
                 WHERE POOL = 'java pool'
                 GROUP BY POOL) TOTAL,
               (SELECT BYTES / 1024 / 1024 FREE
                  FROM V\$SGASTAT
                 WHERE POOL = 'java pool'
                   AND NAME = 'free memory') FREE
          FROM DUAL)
UNION
SELECT NAME, ROUND(TOTAL, 2) as TOTAL_MB, ROUND(TOTAL - FREE, 2) USED_MB, ROUND(FREE, 2) FREE_MB, ROUND((TOTAL - FREE) / TOTAL * 100, 2) pct_used
  FROM (SELECT 'Large Pool' NAME,
               (SELECT SUM(BYTES / 1024 / 1024) TOTAL
                  FROM V\$SGASTAT
                 WHERE POOL = 'large pool'
                 GROUP BY POOL) TOTAL,
               (SELECT BYTES / 1024 / 1024 FREE
                  FROM V\$SGASTAT
                 WHERE POOL = 'large pool'
                   AND NAME = 'free memory') FREE
          FROM DUAL)
 ORDER BY pct_used DESC;
    v_sga c_sga%rowtype;

    cursor c_com is select COMPONENT,
round(CURRENT_SIZE/1024/1024/1024,2) as CURRENT_G,
round(MIN_SIZE/1024/1024/1024,2) MIN_G,
round(MAX_SIZE/1024/1024/1024,2) as MAX_G,
round(USER_SPECIFIED_SIZE/1024/1024/1024,2) as USER_SPECIFIED_G,
OPER_COUNT,
LAST_OPER_TYPE,
decode(LAST_OPER_MODE,null,'None',LAST_OPER_MODE) as LAST_OPER_MODE,
decode(LAST_OPER_TIME,null,'None',LAST_OPER_TIME) as LAST_OPER_TIME,
round(GRANULE_SIZE/1024/1024) as GRANULE_SIZE_M
from v\$sga_dynamic_components;
   v_com c_com%rowtype;

    cursor c_sub is SELECT
     'shared pool ('||NVL(DECODE(TO_CHAR(ksmdsidx),'0','0 - Unused',ksmdsidx), 'Total')||'):'  subpool
    , SUM(ksmsslen) bytes
    , ROUND(SUM(ksmsslen)/1048576,2) MB FROM x\$ksmss WHERE ksmsslen > 0
   GROUP BY ROLLUP (ksmdsidx) ORDER BY
    subpool ASC;
    v_sub c_sub%rowtype;

    cursor c_subcom is select * from (
  SELECT 'shared pool ('||DECODE(TO_CHAR(ksmdsidx),'0','0 - Unused',ksmdsidx)||'):' subpool,
    ksmssnam as name,
    round(ksmsslen/1024/1024,2)  as MB,
    round(100 * ksmsslen/sum(ksmsslen) over(partition by ksmdsidx),2) as pct,
    rank() over(partition by ksmdsidx order by ksmsslen desc) as rank
  FROM  x\$ksmss WHERE ksmsslen > 0
  ) where rank < 21;
    v_subcom c_subcom%rowtype;

    cursor c_row is select la.addr,
  dc.kqrstcid cache,
  dc.kqrsttxt parameter,
  decode(dc.kqrsttyp,1,'PARENT','SUBORDINATE') type,
  decode(decode(dc.kqrsttyp,2,kqrstsno,null),null,'None',decode(dc.kqrsttyp,2,kqrstsno,null)) subordinate,
  dc.kqrstgrq gets,
  dc.kqrstgmi misses,
  dc.kqrstmrq modifications,
  dc.kqrstmfl flushes,
  dc.kqrstcln child_no,
  la.gets as lagets,
  la.misses as lamisses,
  la.immediate_gets laimge
from
  x\$kqrst dc,
  v\$latch_children la
where
  dc.inst_id = userenv('instance')
  and la.child# = dc.kqrstcln
  and la.name = 'row cache objects'
  order by 2,3,4,5;
  v_r c_row%rowtype;

  cursor c_b is select
        /*+ ordered */
        bp.name as pool_name,
        u.username as username,
        ob.name as object_name,
        decode(ob.subname,null,'None',ob.subname) as sub_name,
        decode(ob.type#,
         0,'NEXT OBJECT',1,'INDEX',2,'TABLE',3, 'CLUSTER',4,'VIEW',5, 'SYNONYM',
         6,'SEQUENCE',7, 'PROCEDURE',8, 'FUNCTION',9, 'PACKAGE',11, 'PACKAGE BODY',12, 'TRIGGER',13, 'TYPE',
         14,'TYPE BODY',19, 'TABLE PARTITION', 20, 'INDEX PARTITION', 21, 'LOB',
         22,'LIBRARY', 23, 'DIRECTORY', 24, 'QUEUE',28, 'JAVA SOURCE', 29, 'JAVA CLASS', 30,'JAVA RESOURCE',
         32,'INDEXTYPE',33, 'OPERATOR',34,'TABLE SUBPARTITION',35,'INDEX SUBPARTITION',40,'LOB PARTITION', 41, 'LOB SUBPARTITION',
         43, 'DIMENSION',
         44, 'CONTEXT', 46, 'RULE SET', 47, 'RESOURCE PLAN',
         48, 'CONSUMER GROUP',
         51, 'SUBSCRIPTION', 52, 'LOCATION',
         55, 'XML SCHEMA', 56, 'JAVA DATA',
         57, 'SECURITY PROFILE', 59, 'RULE',
         60, 'CAPTURE', 61, 'APPLY',
         62, 'EVALUATION CONTEXT',
         66, 'JOB', 67, 'PROGRAM', 68, 'JOB CLASS', 69, 'WINDOW',
         72, 'WINDOW GROUP', 74, 'SCHEDULE', 79, 'CHAIN',
         81, 'FILE GROUP',
        'UNDEFINED') object_type,
        sum(bh.ct) as blocks,
        round((sum(bh.ct)*(select value from v\$parameter where name = 'db_block_size' and rownum = 1))/1024/1024,2) as size_mb
from (
        select set_ds, obj, count(*) ct
        from x\$bh group by set_ds, obj
        )                      bh,
        obj\$                   ob,
        x\$kcbwds               ws,
        v\$buffer_pool          bp,
        dba_users              u
where
        ob.dataobj# = bh.obj
and     ob.owner#   = u.user_id
and     bh.set_ds   = ws.addr
and     ws.set_id in (bp.lo_setid,bp.hi_setid)  -- between bp.lo_setid and bp.hi_setid
and     bp.buffers != 0        --  Eliminate any pools not in use^M
and     u.username not in('SYS','SYSTEM','WMSYS','XDB',
                       'QMONITOR','OUTLN','ORDSYS','ORDDATA','OJVMSYS','MDSYS','LBACSYS','DVSYS',
                       'DBSNMP','APEX_040200','AUDSYS','CTXSYS','APEX_030200','EXFSYS','OLAPSYS','SYSMAN','WH_SYNC','GSMADMIN_INTERNAL')
group by u.username,bp.name, ob.name,ob.type#,ob.subname
order by bp.name, blocks desc, ob.name, ob.subname;
  v_b c_b%rowtype;
  v_dic_per varchar2(200);
  v_lib_per varchar2(200);


begin
  DBMS_OUTPUT.ENABLE(buffer_size => null);

  select trunc(sum(gets-getmisses-usage-fixed)/sum(gets)*100,2) into v_dic_per from v\$rowcache;
  select trunc(sum(pinhits)/sum(pins)*100,2) into v_lib_per from v\$librarycache;
   dbms_output.put_line('
Dictionary Cache hit % and Library Cache hit%)');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------');
  dbms_output.put_line('| Dictionary Cache hit% |' || ' Library Cache hit%' || ' |');
  dbms_output.put_line('----------------------------------------------');
  dbms_output.put_line('| ' || lpad(v_dic_per,21) ||' | '|| lpad(v_lib_per,18) || ' |');
  dbms_output.put_line('----------------------------------------------');


  dbms_output.put_line('
SGA and PGA Usage Size and Pct)');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| NAME                          |' || ' TOTAL_MB       ' || '| USED_MB        |' || ' FREE_MB         ' || '| PCT_USED%'|| ' |');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------');
  open c_sga;
    loop fetch c_sga into v_sga;
    exit when c_sga%notfound;
    dbms_output.put_line('| ' || rpad(v_sga.NAME,29) ||' | '|| lpad(v_sga.TOTAL_MB,14) || ' | '|| lpad(v_sga.USED_MB,14) || ' | '|| lpad(v_sga.FREE_MB,15) || ' | '|| lpad(v_sga.pct_used,9) || ' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------------------------------');
  close c_sga;


    dbms_output.put_line('
SGA components Information from v\$sga_dynamic_components');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| COMPONENT                 |' || ' CURRENT_GB ' || '| MIN_GB |' || ' MAX_GB ' || '| USER_SPECIFIED_GB |' || ' OPER_COUNT ' || '| LAST_OPER_TYPE |' || ' LAST_OPER_MODE '  || '| LAST_OPER_TIME      |'|| ' GRANULE_SIZE_MB '|| '|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_com;
    loop fetch c_com into v_com;
    exit when c_com%notfound;
    dbms_output.put_line('| ' || rpad(v_com.COMPONENT,25) ||' | '|| lpad(v_com.CURRENT_G,10) || ' | '|| lpad(v_com.MIN_G,6) || ' | '|| lpad(v_com.MAX_G,6) || ' | '|| lpad(v_com.USER_SPECIFIED_G,17) || ' | '|| lpad(v_com.OPER_COUNT,10) ||  ' | '|| rpad(v_com.LAST_OPER_TYPE,14) || ' | '|| rpad(v_com.LAST_OPER_MODE,14) || ' | '|| rpad(v_com.LAST_OPER_TIME,19) || ' | '|| lpad(v_com.GRANULE_SIZE_M,15)||' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_com;


  dbms_output.put_line('
Shared Pool Sub Pool Size Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('---------------------------------------------------------------');
  dbms_output.put_line('| SUBPOOL                |' || ' SUBPOOL_BYTES         ' || '| SUBPOOL_MB ' || '|');
  dbms_output.put_line('---------------------------------------------------------------');
  open c_sub;
    loop fetch c_sub into v_sub;
    exit when c_sub%notfound;
    dbms_output.put_line('| ' || rpad(v_sub.subpool,22) ||' | '|| lpad(v_sub.bytes,21) || ' | '|| lpad(v_sub.MB,10) || ' |');
    end loop;
    dbms_output.put_line('---------------------------------------------------------------');
  close c_sub;

  dbms_output.put_line('
Shared Pool Sub Pool components Detail Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| RANK |' || ' SUBPOOL                |' || ' COMPONENT_NAME                     ' || '| CURRENT_SIZE_MB |' || ' CURRENT_PCT% ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------');
  open c_subcom;
    loop fetch c_subcom into v_subcom;
    exit when c_subcom%notfound;
    dbms_output.put_line('| ' || lpad(v_subcom.RANK,4)|| ' | ' || rpad(v_subcom.SUBPOOL,22) ||' | '|| rpad(v_subcom.NAME,34) || ' | '|| lpad(v_subcom.MB || ' M',15) || ' | '|| lpad(v_subcom.pct || '%',12) || ' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------------------------------------');
  close c_subcom;



    dbms_output.put_line('
Latch: row cache objects On Dc_objects Information from x\$kqrst
Doc ID 2359175.1');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| ADDR             ' || '| c# |' || ' parameter                        ' || '| type        |' || ' s# ' || '| gets       |' || ' misses   ' || '| modi_s   |' || ' flushes '  || '| ch# |'|| ' lagets   '|| '| lamisses |' || ' laimge ' ||'|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_row;
    loop fetch c_row into v_r;
    exit when c_row%notfound;
    dbms_output.put_line('| ' || lpad(v_r.addr,16) || ' | '|| lpad(v_r.cache,2) ||' | '|| rpad(v_r.parameter,32) || ' | '|| rpad(v_r.type,11) || ' | '|| lpad(v_r.subordinate,2) || ' | '|| lpad(v_r.gets,10) || ' | '|| lpad(v_r.misses,8) ||  ' | '|| lpad(v_r.modifications,8) || ' | '|| lpad(v_r.flushes,7) || ' | '|| lpad(v_r.child_no,3) || ' | '|| lpad(v_r.lagets,8) || ' | ' || lpad(v_r.lamisses,8) || ' | '|| lpad(v_r.laimge,6)|| ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_row;

  dbms_output.put_line('
Which Table or Index Objects in DB Buffer Cache(Defaul Pool,Keep Pool) ');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| POOL_NAME  ' || '| USERNAME         |' || ' OBJECT_NAME           ' || '| SUB_NAME          |' || ' OBJECT_TYPE       ' || '| BLOCKS     |' || ' SIZE_MB      ' ||'|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------');
  open c_b;
    loop fetch c_b into v_b;
    exit when c_b%notfound;
    dbms_output.put_line('| ' || rpad(v_b.POOL_NAME,10) || ' | '|| rpad(v_b.USERNAME,16) ||' | '|| rpad(v_b.OBJECT_NAME,21) || ' | '|| rpad(v_b.SUB_NAME,17) || ' | '|| rpad(v_b.OBJECT_TYPE,17) || ' | '|| lpad(v_b.BLOCKS,10) || ' | '|| lpad(v_b.SIZE_MB,12) ||  ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------');
  close c_b;


end;
/


--Library pool usage
-- library pool
set pages 1000
set lines 400
break on report
compute sum of gets on report
compute sum of pins on report
compute avg of "gethitratio(%)" on report
compute avg of "pinhitratio(%)" on report
compute avg of "loadpinratio(%)" on report
compute avg of invalidations on report
col namespace for a40
prompt loadpinratio < 1%
prompt gethitratio > 95%
prompt invalidations = 0
select namespace,gets,round(gethitratio*100,2) "gethitratio(%)",
       pins,round(pinhitratio*100,2) "pinhitratio(%)",
       round((reloads)/decode(pins,0,1,pins)*100,2) "loadpinratio(%)", invalidations
  from v\$librarycache;

prompt Estimate library cache size = sum(sharable_mem from v\$db_object_cache)
prompt                               + 250 * total_opening_cursors
select sum(estimate_size) "estimate library cache size"
  from   (
    select sum(sharable_mem) estimate_size from v\$db_object_cache
      where type in ('PACKAGE','PACKAGE BODY','FUNCTION','PROCEDURE')
    union all
    select sum(sharable_mem) estimate_size from v\$db_object_cache
      where executions > 5
    union all
    select 250 * sum(users_opening ) estimate_size from v\$sql
  ) ;


-- dictionary pool
compute avg of "getmissratio(%)" on report
prompt getmisses/gets < 15%
select parameter, round(getmisses/decode(gets,0,1,gets)*100,2) "getmissratio(%)"
  from v\$rowcache
  order by 2 desc;

-- shared_pool_reserved
prompt free_space > 1/2 shared_pool_reserved and request_misses = 0 ---- too large
prompt request_failures > 0  --- too small
select free_space,avg_free_size,request_misses,request_failures,aborted_requests
  from v\$shared_pool_reserved;

col object_name format a30
col owner format a10
prompt object could be pin in the database
col type for a25
select
  owner,
  name as object_name,
  sharable_mem,
  executions,
  type,
  loads
from v\$db_object_cache
where sharable_mem > 10000
  and kept = 'NO'
  and type in ('PACKAGE','PACKAGE BODY','FUNCTION','PROCEDURE','SEQUENCE','TYPE','TRIGGER','SYNONYM');
  spool off
!
echo "Current instance_number is $INST"
  exit 0
fi

########################################################################################################
##duplicate with pga command
if [ "$1" = "processes" ]; then

  MAX=""

  if [ "$2" != "" ]; then
    MAX=" and round(PGA_MAX_MEM/1024/1024) >= $2"
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

      connect $DBUSER

      set pagesize 6000
      set tab      off
      set linesize 160
      set echo off
      col prg format A30
      col spid format A12
      repfooter off;
      set timing off veri off space 1 flush on pause off termout on numwidth 10;

      select p.pid, p.spid, substr(p.program, 10, 30) prg,
             round(PGA_USED_MEM/1024/1024) used_M,
             round(PGA_ALLOC_MEM/1024/1024) alloc_M,
             round(PGA_FREEABLE_MEM/1024/1024) freeable_M,  round(PGA_MAX_MEM/1024/1024) max_M
      from gv\$process p
      where inst_id=$INST and spid is not NULL $MAX
      order by 4;
      $ECHO
!
echo "instance_number=$INST"
exit 0;
fi



#######################################################################################################

if [ "$1" = "pga" ]; then

     if [ "$2" = "" ]; then
      rn=50
     else
      rn=$2
     fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 100
    --set tab      off
    set linesize 200
    --set echo off
    --repfooter off;
    --set timing off veri off space 1 flush on pause off termout on numwidth 10;
    col spid format a8
    col program format a20 trunc
    col username format a15
    select * from
    (
    select SPID, username,program,pname
           ,round(PGA_USED_MEM/1024/1024) as PGA_USED_MEM_M
           ,round(PGA_ALLOC_MEM/1024/1024) as PGA_ALLOC_MEM_M
           ,round(PGA_MAX_MEM/1024/1024) as PGA_MAX_MEM_M
    from gv\$process
    where spid is not NULL and inst_id=$INST
    order by PGA_USED_MEM desc
    ) where rownum<=$rn;
!
echo "instance_number=$INST"
exit 0
fi

############################################################################################
# Detail of pga
##########################################################################################
if [ "$1" = "pga_detail" ]; then

  if [ "$2" = "" ]; then
    echo "ora pga_detail pid\(ora pga_detail 2584\)/\(ora pga_detail -mem 10\) >10M"
    exit 1
  fi

  if [ "$2" = "-mem" ] ; then
    if [ "$3" = "" ]; then
      echo "memory threshold not specified"
    else
      PRED="PGA_ALLOC_MEM > $3 * 1024 * 1024"
      OSPID=""
    fi
  else
    PRED="SPID=$2"
    OSPID=$2
  fi

  sqlplus -s /NOLOG << ! | grep '###' | sed -e 's/.*###\(.*\)###\(.*\)###\(.*\)###/\1 \2 \3/g' > $ORA_TMP/pid$$

     connect $DBUSER

     select '###' || pid || '###' || spid || '###' || round(pga_alloc_mem/1024/1024) || '###' version
     from v\$process
     where $PRED;
!

  FOUND=0
  cat $ORA_TMP/pid$$ | while read a; do
    set $a
    ORA_PID=$1
    OSPID=$2
    MEM=$3
    FOUND=1

    echo
    echo "Detail for process $OSPID \(PGA allocated is $MEM MB\)"
    echo '****************************************************'

    sqlplus -s /NOLOG << ! | egrep -v "Statement processed|Function returned|rows selected"

      connect $DBUSER

      set pagesize 6000
      set linesize 200
      set tab      off
      set echo off
      set long     4000

      oradebug setmypid
      oradebug call ksmpgd_get_detail $ORA_PID

      ! sleep 10

      select PID, SERIAL#, CATEGORY, NAME, HEAP_NAME, BYTES, ALLOCATION_COUNT,
             HEAP_DESCRIPTOR, PARENT_HEAP_DESCRIPTOR
      from gv\$process_memory_detail
      where PID=$ORA_PID and inst_id=$INST
      order by bytes;
      $ECHO
!

  done

  if [ $FOUND -eq 0 -a "$OSPID" != "" ]; then
    echo "OS pid $OSPID does not exists in v\$process"
  fi

  rm -f $ORA_TMP/pid$$
echo "instance_number=$INST"
exit 0
fi

#######################################################################################################

if [ "$1" = "alert" ]; then
#find all log.xml in $ORACLE_BASE/diag , include listener log.xml

  #if [ "$2" = "" ]; then
  #   days=2
  #else
  #   days=$2
  #fi

   if [ "$2" = "" ]; then
    read -p "please input alert his days to review [2]:" days
    if [ -z "${days}" ];then
      days=2
    fi
  else
    days=$2
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 6000
    set tab      off
    set linesize 180
    col message_text format a140
    col inst_id format 9999
    col alert_time format a20

    select inst_id,to_char(originating_timestamp,'yyyy-mm-dd hh24:mi:ss')as alert_time, message_text
    from
    TABLE(gv\$(cursor(select inst_id, originating_timestamp, message_text
                    from v\$diag_alert_ext
                    where originating_timestamp > (sysdate - $days)
                          and inst_id=$INST
                    and (message_text like '%ORA-%'
                        or message_text ='Checkpoint not complete'
                        or upper(message_text) like 'ALTER%'
                        )
                  )
            )
    )
    order by inst_id, originating_timestamp;
    $ECHO
!
  echo "****display alert log in recent $days days****"
  exit 0
fi

#################################################################################################

if [ "$1" = "users" -o  "$1" = "user" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set tab off
    set linesize 200 pagesize 30
    set timing off
    set serveroutput on
    set feedback off
    col command for a80
    set verify off
    set linesize 500
    undefine username
    var username varchar2(100);
    alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
    spool ora_user_$filedate.log
begin
  :username :=upper('$2');
end;
/
declare
    cursor c_user is select distinct
        a.username,
        a.default_tablespace,
        a.temporary_tablespace as temp_tbs,
        a.user_id,
        to_char(a.created,'yyyymmdd') as created,
        a.profile,
        a.account_status,
        b.lcount,
        sum(round(s.bytes/1024/1024/1024)) over(partition by s.owner) as USER_SEGMENT_GB,
        case when p.GRANTED_ROLE = 'DBA' then 'Yes' else 'No' end as DBA_PRIVS
        from
        dba_users a, user$ b, dba_segments s ,dba_role_privs p,dba_profiles pr
        where a.user_id = b.USER#
          and a.username = s.owner
          and p.grantee = a.username
          and a.username not in
          ('SYSTEM','OWBSYS','XS$NULL','FLOWS_FILES','WMSYS','DIP','XDB','SYS','ANONYMOUS','QMONITOR','ORDPLUGINS','OUTLN','ORDSYS','SI_INFORMTN_SCHEMA','ORDDATA','OJVMSYS','SPATIAL_WFS_ADMIN_USR','MDSYS','LBACSYS','SPATIAL_CSW_ADMIN_USR','DVSYS','DBSNMP','APEX_PUBLIC_USER','APPQOSSYS','APEX_040200','ORACLE_OCM','AUDSYS','CTXSYS','MDDATA','APEX_030200','EXFSYS','MGMT_VIEW','OLAPSYS','SYSMAN','OWBSYS_AUDIT','WH_SYNC','GSMADMIN_INTERNAL')
        order by created;
   v_user c_user%rowtype;
   cursor c_a is select a.username,
        CASE B.LIMIT WHEN 'UNLIMITED' THEN NULL
        ELSE trunc(A.EXPIRY_DATE - SYSDATE)+b.limit END AS EXPIRED_DAYS
        from dba_users a,dba_profiles b
        where a.profile=b.profile
        and a.account_status='OPEN'
        and b.RESOURCE_NAME='PASSWORD_GRACE_TIME'
        and a.expiry_date is not null
        and b.limit <>'UNLIMITED';
   v_a c_a%rowtype;
begin
  dbms_output.put_line('
User Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| USERNAME           |' || ' DEFAULT_TABLESPACE |' || ' DEFAULT_TEMP_TBS ' || '| USER_ID |' || ' CREATED  ' || '| PROFILE   |' || ' ACCOUNT_STATUS ' || '| LCOUNT ' || '| USER_GB ' || '| DBA PRIV '|| '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  open c_user;
    loop fetch c_user into v_user;
    exit when c_user%notfound;
    dbms_output.put_line('| ' || rpad(v_user.USERNAME,18) || ' | ' || rpad(v_user.DEFAULT_TABLESPACE,18) ||' | '|| rpad(v_user.TEMP_TBS,16) || ' | ' || lpad(v_user.USER_ID,7) || ' | ' || lpad(v_user.CREATED,8) || ' | ' || rpad(v_user.PROFILE,9) || ' | ' || rpad(v_user.ACCOUNT_STATUS,14) || ' | ' || lpad(v_user.LCOUNT,6) || ' | ' || lpad(v_user.USER_SEGMENT_GB,7) || ' | ' || rpad(v_user.DBA_PRIVS,8) ||' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  close c_user;
end;
/

prompt ***************
prompt Current User DBA ROLE PRIVS from dba_role_privs
prompt ***************
select 'grant '||granted_role||' to '||grantee||decode(admin_option, 'YES', ' WITH ADMIN OPTION;',';') as command
from dba_role_privs where upper(grantee) = :username;
prompt ***************
prompt Current User DBA SYS PRIVS from dba_sys_privs
prompt ***************
select 'grant '||privilege||' to '||grantee||decode(admin_option, 'YES', ' WITH ADMIN OPTION;',';') as command
from dba_sys_privs where upper(grantee) = :username;
prompt ***************
prompt Current User DBA TAB PRIVS from dba_tab_privs
prompt ***************
select 'grant '||privilege||' on '||owner||'.'||table_name||' to '||grantee||decode(grantable, 'YES', ' WITH GRANT OPTION;',';') as command
from dba_tab_privs where upper(grantee) = :username;

set head on feedback on
spool off
    $ECHO
!
  exit 0
fi


#################################################################################################

if [ "$1" = "lob" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set tab      off

    set linesize 200 pagesize 100
    --set echo on
    col rn format 99
    col SEGMENT_NAME format a25
    col owner format a15 trunc
    col table_name format a20 trunc
    col column_name format a25
    col index_name format a24
    col size_M format 99999
    col chunk format 99999
    --get big
      select v1.*,b.table_name,b.column_name,index_name,chunk,securefile,in_row from
    (
        select rownum as rn,a.* from
        (select owner,segment_name--,segment_type
            ,round((bytes/1024/1024)) size_M
            from dba_segments
            where round(bytes/1024/1024)>=10 and
            segment_type='LOBSEGMENT'
            order by size_M desc
        )a where rownum<=50
    )v1,dba_Lobs b
    where v1.owner=b.owner and v1.segment_name=b.segment_name
    order by rn;
    $ECHO
!
echo "list biggest 50 lob segment >=10M"
  exit 0
fi

#################################################################################################

if [ "$1" = "lobfree" ]; then

  if [ "$2" = "" ]; then
    echo "ora lobfree owner lobname\$\$ ;not for basicfile"
    exit 0
  fi

  owner=$2
  lobname=$3

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

  connect $DBUSER


set serveroutput on size unlimited
declare
  l_seg_size_blocks int;
  l_seg_size_bytes int;
  l_used_blocks int;
  l_used_bytes int;
  l_expired_blocks int;
  l_expired_bytes int;
  l_unexpired_blocks int;
  l_unexpired_bytes int;
  l_unused_blocks  int;
  l_unused_bytes int;
  l_non_data_blocks int;
  l_non_data_bytes int;

begin
  dbms_space.space_usage(
   segment_owner           => upper('$owner'),
   segment_name            => upper('$lobname'),
   segment_type            => 'LOB',
   segment_size_blocks     => l_seg_size_blocks,
   segment_size_bytes      => l_seg_size_bytes,
   used_blocks             => l_used_blocks,
   used_bytes              => l_used_bytes,
   expired_blocks          => l_expired_blocks,
   expired_bytes           => l_expired_bytes,
   unexpired_blocks        => l_unexpired_blocks,
   unexpired_bytes         => l_unexpired_bytes
   );

          l_unused_blocks := l_seg_size_blocks - (l_used_blocks + l_expired_blocks + l_unexpired_blocks);
          l_unused_bytes  := l_seg_size_bytes - (l_used_bytes + l_expired_bytes + l_unexpired_bytes);

          l_non_data_blocks := l_unused_blocks + l_expired_blocks + l_unexpired_blocks;
          l_non_data_bytes :=  l_unused_bytes + l_expired_bytes + l_unexpired_bytes;

  dbms_output.put_line(lpad('-',42,'-'));
  dbms_output.put_line('lob segment blocks    = '|| l_seg_size_blocks);
  dbms_output.put_line('lob segment bytes_M   = '|| round(l_seg_size_bytes/1024/1024));
  dbms_output.put_line('lob used blocks       = '|| l_used_blocks);
  dbms_output.put_line('lob expired blocks    = '|| l_expired_blocks);
  dbms_output.put_line('lob unexpired blocks  = '|| l_unexpired_blocks);

  dbms_output.put_line('lob unused   blocks / bytes(M)  = '|| l_unused_blocks||' / '||round(l_unused_bytes/1024/1024));
  dbms_output.put_line('lob non_date blocks / bytes(M)  = '|| l_non_data_blocks||' / '||round(l_non_data_bytes/1024/1024));
  dbms_output.put_line(lpad('-',42,'-'));
end;
/

!
  exit 0
fi

#####################################################################################################

if [ "$1" = "cputime" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 30
    set tab      off
    set verify off

    define statname='DB CPU'
    spool ora_cputime_$filedate.log
    Pro cputime by day:
    with stat_time as
    (
      select instance_number,begin_snap_id, end_snap_id,
      snap_begin_time, snap_end_time,
      round(interval_min) as interval_min,
      round(lag_value/60/1000000,0) as stat_time_min ,
      round(lag_value/60/1000000/interval_min,0) as stat_time_per_sec
      from
      (
        select sp.instance_number,
        sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
        sp.snap_id   as end_snap_id,   to_char(end_interval_time-1/24/60,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time, --1 minute ahead for 00:00:xx,it belongs to prev day
        (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
        value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
        sy.stat_name
        from dba_hist_snapshot sp, dba_hist_sys_time_model sy
        where sp.snap_id=sy.snap_id
          and sp.instance_number=sy.instance_number
          and sy.stat_name='&statname'
        ) where   nvl(lag_value,0)>0
    )--end with
    select instance_number,min(begin_snap_id),max(end_snap_id),substr(snap_end_time,1,10) as stat_time_day,sum(stat_time_min) as total_time_day
    from stat_time group by instance_number,substr(snap_end_time,1,10)
    --order by total_time_day
    order by stat_time_day;
    $ECHO


    Pro top 20 cputime by snap:
    with stat_time as
    (
    select instance_number,begin_snap_id, end_snap_id,
    snap_begin_time, snap_end_time,
    round(interval_min) as interval_min,
    round(lag_value/60/1000000,2) as DB_CPU_min ,
    round(lag_value/60/1000000/interval_min,2) as DB_CPU_per_sec
    from
    (
    select sp.instance_number,
    sp.snap_id-1 as begin_snap_id, to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as snap_begin_time,
    sp.snap_id   as end_snap_id,   to_char(end_interval_time,  'yyyy-mm-dd hh24:mi:ss') as snap_end_time,
    (cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60 as interval_min,
    value - lag(value) over (partition by sp.instance_number,stat_name order by sp.snap_id) as lag_value ,
    sy.stat_name
    from dba_hist_snapshot sp, dba_hist_sys_time_model sy
    where sp.snap_id=sy.snap_id
      and sp.instance_number=sy.instance_number
      and sy.stat_name='&statname'
    ) where   nvl(lag_value,0)>0
    )--with
    select * from
    (
    select a.* ,row_number() over ( partition by instance_number order by DB_CPU_per_sec desc) as rank
     from stat_time a
    ) where rank<=20;
    $ECHO
    spool off
!
 echo "display CPU time by day and show top 10 cputime by snapshots"
  exit 0
fi

#####################################################################################################

if [ "$1" = "awr" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 30
    col begin_interval_time format a20
    col end_interval_time format a20
    col startup_time format a20

    break on startup_time
    select  instance_number,snap_id-1 as begin_snapid,snap_id as end_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,to_char(end_interval_time,'mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi

   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else
    bid=$2
    eid=$3
  fi


  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

SET AUTOP OFF VER OFF SERVEROUT ON SIZE unlimited;
SET TERMout off ECHO OFF feedback off
set trims on

SPOOL _awr.sql

declare

node_cnt number:=0;
v_dbid number;
BEGIN

    DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF PAGESIZE 0 HEADING OFF LINESIZE 8000 TRIMSPOOL ON TRIMOUT ON TAB OFF timing off feedback off');
    dbms_output.put_line('exec DBMS_WORKLOAD_REPOSITORY.AWR_SET_REPORT_THRESHOLDS(top_n_sql=>60);');



    for i in (select dbid,inst_id from gv\$database order by 1)
    loop
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
        DBMS_OUTPUT.PUT_LINE('PRO Generate AWR for node'||i.inst_id||' ,  please wait for a few minutes......');
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF');
        DBMS_OUTPUT.PUT_LINE('spool ora_awrrpt_'||i.inst_id||'_'||$bid||'_'||$eid||'.html');
        DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.awr_report_html('||i.dbid||','||i.inst_id||','||$bid||','||$eid||'));');
        DBMS_OUTPUT.PUT_LINE('spool off');
        node_cnt:=node_cnt+1;
        v_dbid  :=i.dbid;
    END LOOP;

    if node_cnt>1 then
    DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
    DBMS_OUTPUT.PUT_LINE('PRO Generate AWR for RAC ,  please wait for a few minutes');
    DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF');
    DBMS_OUTPUT.PUT_LINE('spool ora_awrrpt_RAC_'||$bid||'_'||$eid||'.html');
    DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.awr_global_report_html('||v_dbid||', CAST(null AS VARCHAR2(10)),'||$bid||' ,'||$eid||'));');
    DBMS_OUTPUT.PUT_LINE('spool off');
    end if;
END;
/

SPOOL OFF;

set SERVEROUT off

@_awr
!
rm _awr.sql
echo "generate awr report for snapid $bid - $eid "
  exit 0
fi

#####################################################################################################

if [ "$1" = "awrsqrpt" ]; then

   if [ "$2" = "" -o "$3" = "" ]; then
     sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
     connect $DBUSER
    set linesize 150 pagesize 30
    col begin_interval_time format a20
    col end_interval_time format a20
    col startup_time format a20

    break on startup_time
    select  instance_number,snap_id-1 as begin_snapid,snap_id as end_snapid
            ,to_char(begin_interval_time,'yyyy-mm-dd hh24:mi:ss') as begin_interval_time
            ,to_char(end_interval_time,'mm-dd hh24:mi:ss') as end_interval_time
            ,to_char(startup_time,'yyyy-mm-dd hh24:mi:ss') as startup_time
            ,round((cast(end_interval_time as date)-cast(begin_interval_time as date))*24*60) as interval_min
     from dba_hist_snapshot
     where end_interval_time>sysdate-7
     order by instance_number,snap_id;
     $ECHO
!
   defbid=`echo "select trim(12345||max(snap_id)-1) as bid from dba_hist_snapshot;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-15`
   let defeid=defbid+1
   read -p "Please input begin snap_id[$defbid]:" bid
    if [ -z "${bid}" ];then
         bid=$defbid
    fi
   read -p "Please input end   snap_id[$defeid]:" eid
    if [ -z "${eid}" ];then
         eid=$defeid
    fi
   read -p "Please input        sql_id$defsql_id: " sql_id
    if [ -z "${sql_id}" ];then
         sql_id=$defsql_id
    fi

   if [ ${bid} -ge ${eid} ];then
      echo begin_snap_id:$bid end_snap_id:$eid  input error!
      exit 1
   fi
   else
    bid=$2
    eid=$3
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

SET AUTOP OFF VER OFF SERVEROUT ON SIZE unlimited;
SET TERMout off ECHO OFF feedback off
set trims on

SPOOL _awr.sql

declare

node_cnt number:=0;
v_dbid number;
BEGIN

    DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF PAGESIZE 0 HEADING OFF LINESIZE 8000 TRIMSPOOL ON TRIMOUT ON TAB OFF timing off feedback off');
    dbms_output.put_line('exec DBMS_WORKLOAD_REPOSITORY.AWR_SET_REPORT_THRESHOLDS(top_n_sql=>60);');



    for i in (select dbid,inst_id from gv\$database order by 1)
    loop
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
        DBMS_OUTPUT.PUT_LINE('PRO Generate AWR for node'||i.inst_id||' ,  please wait for a few minutes......');
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT OFF');
        DBMS_OUTPUT.PUT_LINE('spool ora_awrsqrpt_'||i.inst_id||'_'||$bid||'_'||$eid||'_'||'$sql_id'||'.html');
        DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.AWR_SQL_REPORT_HTML('||i.dbid||','||i.inst_id||','||$bid||','||$eid||','||q'[']'||'$sql_id'||q'[']'||'));');
        DBMS_OUTPUT.PUT_LINE('spool off');
        DBMS_OUTPUT.PUT_LINE('SET TERMOUT ON');
        DBMS_OUTPUT.PUT_LINE('SELECT * FROM TABLE(DBMS_WORKLOAD_REPOSITORY.AWR_SQL_REPORT_TEXT('||i.dbid||','||i.inst_id||','||$bid||','||$eid||','||q'[']'||'$sql_id'||q'[']'||'));');
        node_cnt:=node_cnt+1;
        v_dbid  :=i.dbid;
    END LOOP;
END;
/

SPOOL OFF;

set SERVEROUT off

@_awr
!
rm _awr.sql
echo "generate awrsqrpt report for snapid $bid - $eid sql_id $sql_id"
  exit 0
fi

#####################################################################################################

if [ "$1" = "highparse" ]; then

   if [ "$2" = "" ]; then
    cnt=500
   else
    cnt=$2
   fi

   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 600

    col sql_text format a100
    col sql_id format a13
    column FORCE_MATCHING_SIGNATURE format 99999999999999999999999

    spool ora_highparse_$filedate.log

    WITH c AS
        (SELECT  FORCE_MATCHING_SIGNATURE,
                 COUNT(*) cnt
        FROM     gv\$sqlarea
        WHERE    FORCE_MATCHING_SIGNATURE!=0
        GROUP BY FORCE_MATCHING_SIGNATURE
        HAVING   COUNT(*) > =$cnt   -- (P.S. You can run this query with larger values say 1000)
        ),
        sq AS
        (SELECT  sql_id,substr(sql_text,1,100) as sql_text ,
                 FORCE_MATCHING_SIGNATURE,
                 row_number() over (partition BY FORCE_MATCHING_SIGNATURE ORDER BY sql_id DESC) rn
        FROM     gv\$sqlarea s
        WHERE    FORCE_MATCHING_SIGNATURE IN (SELECT FORCE_MATCHING_SIGNATURE FROM  c)
        )
    select * from
    (SELECT
            sq.FORCE_MATCHING_SIGNATURE,
            sql_id,
            c.cnt unshared_count,
            sq.sql_text
    FROM     c, sq
    WHERE    sq.FORCE_MATCHING_SIGNATURE=c.FORCE_MATCHING_SIGNATURE
    AND      sq.rn=1
    ORDER BY c.cnt DESC
    )where rownum<=100;
    $ECHO
    spool off

!
echo "full nodes"
echo "show same FORCE_MATCHING_SIGNATURE with diffrent sql_id,top 50 ,default threshold is 500. your selection is $cnt"
  exit 0
fi

#####################################################################################################

if [ "$1" = "highparse2" ]; then

   if [ "$2" = "" ]; then
    cnt=10
   else
    cnt=$2
   fi

   sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 600

    col sql_text format a150
    col sql_id format a13
    column FORCE_MATCHING_SIGNATURE format 99999999999999999999999
    col MIN_SQL_ID format a13

    spool ora_highparse2_$filedate.log

    WITH c AS
        (SELECT  FORCE_MATCHING_SIGNATURE,COUNT(*) cnt,max(sql_id) as min_sql_id
         ,min(optimizer_cost) as min_cost,max(optimizer_cost) as max_cost
         ,round(sum(cpu_time/1e6)) as sum_cpu_s,round(sum(elapsed_time/1e6)) as sum_elap_s
         ,round(sum(physical_read_bytes/1e3)) as read_k
        FROM     gv\$sqlarea
        WHERE    FORCE_MATCHING_SIGNATURE!=0
        GROUP BY FORCE_MATCHING_SIGNATURE
        HAVING   COUNT(*) > =$cnt   -- (P.S. You can run this query with larger values say 1000)
        )
    select rownum as rn,x.* from
    (SELECT *
     FROM   c
    ORDER BY sum_cpu_s DESC
    ) x where rownum<=50;
    $ECHO
    spool off

!
echo "full nodes"
echo "show same FORCE_MATCHING_SIGNATURE with diffrent sql_id,top 50 ,default threshold is 10. your selection is $cnt"
  exit 0
fi

#####################################################################################################

if [ "$1" = "pc" -o "$1" = "whats_changed" -o "$1" = "plan_changed" ]; then

    if [ "$2" = "" ]; then
      awr_his=8
    else
      awr_his=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 180 pagesize 30
set verify off
col exec_user format a10
col sql_id format a13
col phvs format 99

spool ora_PC_$filedate.log

with base_info as
(
select  parsing_schema_name as exec_user,
        sql_id, plan_hash_value as phv,
        executions as execs,
        elapsed_time as ela
        from gv\$sql where plan_hash_value>0 and elapsed_time>0
union all
select  parsing_schema_name,
        sql_id, plan_hash_value,
        executions_delta as execs,
        elapsed_time_delta
        from DBA_HIST_SQLSTAT
        where plan_hash_value>0 and elapsed_time_delta>0
              and snap_id >= (select min(snap_id) from dba_hist_snapshot where begin_interval_time>=sysdate-$awr_his)
),tmp_gby as
(
  select exec_user,sql_id,phv,sum(ela) as sum_ela,greatest(sum(execs),1) as sum_execs
      ,round(sum(ela)/greatest(sum(execs),1)) as avg_etime
  from base_info
  group by exec_user,sql_id,phv
),tmp_ana as
(select sql_id, exec_user,phv as best_phv, sum_execs as b_sum_execs, avg_etime as b_avg_etime
 ,round(stddev(avg_etime) over (partition by exec_user,sql_id)) as stddev_etime
 ,count(phv) over(partition by exec_user,sql_id) as phvs
 ,first_value(phv)       over (partition by exec_user,sql_id order by avg_etime desc)as worst_phv
 ,first_value(sum_execs) over (partxition by exec_user,sql_id order by avg_etime desc)as w_sum_execs
 ,first_value(avg_etime) over (partition by exec_user,sql_id order by avg_etime desc)as w_avg_etime
 ,row_number() over(partition by exec_user,sql_id order by avg_etime) as rn
from tmp_gby
)select * from
( select sql_id,exec_user,phvs--,stddev_etime
     ,best_phv,b_sum_execs ,round(b_avg_etime/1e6,4) as b_avg_etime_s
     ,worst_phv,w_sum_execs,round(w_avg_etime/1e6,4) as w_avg_etime_s
     ,round(stddev_etime/b_avg_etime) as norm_stddev
     ,round(w_avg_etime/b_avg_etime,1) as ratio
from tmp_ana a
where phvs>1 and rn=1 and stddev_etime/b_avg_etime>1
order by stddev_etime/b_avg_etime desc
) where rownum<=50 order by norm_stddev;


select  sql_id,
    plan_hash_value,
    executions,
    "elapsed(s)/per",
    "cpu(s)/per",
    "rows_processed/per",
    "buffer_gets/per",
    "disk_reads/per"
from
(   select
    base.*,
    count(*) over (partition by sql_id) cnt,
    max("elapsed(s)/per") over (partition by sql_id) max_elp_time_per_exec
from
(   select
        x.sql_id,
        x.plan_hash_value,
        sum(x.executions_delta) executions,
        round(sum(x.elapsed_time_delta)/decode(sum(x.executions_delta),0,1,sum(x.executions_delta))/1000000, 1) "elapsed(s)/per",
        round(sum(x.cpu_time_delta)/decode(sum(x.executions_delta),0,1,sum(x.executions_delta))/1000000, 1) "cpu(s)/per",
        round(sum(x.rows_processed_delta)/decode(sum(x.executions_delta),0,1,sum(x.executions_delta)), 1) "rows_processed/per",
        trunc(sum(x.buffer_gets_delta)/decode(sum(x.executions_delta),0,1,sum(x.executions_delta))) "buffer_gets/per",
        trunc(sum(x.disk_reads_delta)/decode(sum(x.executions_delta),0,1,sum(x.executions_delta))) "disk_reads/per",
        x.PARSING_SCHEMA_NAME
    from
        dba_hist_sqlstat x,
        dba_hist_snapshot s
    where
        s.instance_number=x.instance_number
    and s.snap_id = x.snap_id
    --and s.begin_interval_time >
    group by x.sql_id, x.plan_hash_value,x.PARSING_SCHEMA_NAME
    ) base )
where
-- PARSING_SCHEMA_NAME = '&username' and
max_elp_time_per_exec > 1
and cnt > 1
order by max_elp_time_per_exec, "elapsed(s)/per"
/

prompt Plan Changed

/* I-what_changed */
select sql_id,
       parsing_schema_name,
       round(max(elapsed_time/decode(executions,0,1,executions))/min(elapsed_time/decode(executions,0,1,executions))) DIFF,
      min(inst_id) INST_ID
from
  gv\$sql
where elapsed_time > 0
 -- and parsing_schema_name not in ('SYS')
group by sql_id,parsing_schema_name
having count(distinct plan_hash_value) > 1
   and round(max(elapsed_time/decode(executions,0,1,executions))/min(elapsed_time/decode(executions,0,1,executions))) > 100;








$ECHO

spool off

!
echo "full nodes. for recent $awr_his (given) days"
exit 0
fi


#####################################################################################################

if [ "$1" = "pc2" ]; then

    if [ "$2" = "" ]; then
      awr_his=8
    else
      awr_his=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 180 pagesize 30
set verify off
col exec_user format a10
col sql_id format a13
col phvs format 99
col B_LAST_TIME format a11
col curr_last_time format a11
col ratio format 9999999
col STDDEV format 999999

spool ora_PC2_$filedate.log

with base_info as
(
select  parsing_schema_name as exec_user,
        sql_id, plan_hash_value as phv,
        executions as execs,
        elapsed_time as ela,
        LAST_ACTIVE_TIME as last_exec_time
        from gv\$sql
        where plan_hash_value>0 and elapsed_time>0
union all
select  parsing_schema_name,
        sql_id, plan_hash_value,
        executions_delta as execs,
        elapsed_time_delta,
        cast(begin_interval_time as date)
        from DBA_HIST_SQLSTAT S, DBA_HIST_SNAPSHOT SS
        where ss.snap_id = S.snap_id
        and ss.instance_number = S.instance_number
        and SS.end_INTERVAL_TIME > sysdate-31
        and plan_hash_value>0 and elapsed_time_delta>0
),tmp_gby as
(
select sql_id,exec_user,phv,sum(ela) as sum_ela,greatest(sum(execs),1) as sum_execs
      ,round(sum(ela)/greatest(sum(execs),1)) as avg_etime
      ,max(last_exec_time) as max_exec_time
from base_info
group by sql_id,exec_user,phv
),tmp_ana as
(select sql_id,exec_user, phv as best_phv, sum_execs as b_sum_execs, avg_etime as b_avg_etime,max_exec_time as b_last_time
 ,round(stddev(avg_etime) over (partition by exec_user,sql_id)) as stddev_etime
 ,count(phv) over(partition by exec_user,sql_id) as phvs
 ,first_value(phv) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_phv
 ,first_value(sum_execs) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_sum_execs
 ,first_value(avg_etime) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_avg_etime
 ,first_value(max_exec_time) over (partition by exec_user,sql_id order by max_exec_time desc)as curr_last_time
 ,row_number() over(partition by exec_user,sql_id order by avg_etime) as rn
from tmp_gby
)select * from --tmp_ana where sql_id='0wqx6mfuhashb'
( select sql_id,exec_user,phvs--,stddev_etime
     ,best_phv,b_sum_execs as b_execs ,round(b_avg_etime/1e6,4) as b_avg_s,to_char(b_last_time,'mmdd hh24miss') as b_last_time
     ,curr_phv,curr_sum_execs as curr_execs,round(curr_avg_etime/1e6,4) as curr_avg_s,to_char(curr_last_time,'mmdd hh24miss') as curr_last_time
     ,round(stddev_etime/b_avg_etime) as stddev
     ,round(curr_avg_etime/b_avg_etime,1) as ratio
     ,case when curr_last_time>b_last_time then 'not' else '--' end as res
from tmp_ana a
where phvs>1 and rn=1 and stddev_etime/b_avg_etime>1
order by stddev_etime/b_avg_etime desc
) where rownum<=50 order by stddev;
$ECHO

spool off

!
echo "full nodes. for recent $awr_his(given) days"
exit 0
fi


#####################################################################################################

if [ "$1" = "pc_old" ]; then

    if [ "$2" = "" ]; then
      awr_his=31
    else
      awr_his=$2
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

set linesize 180 pagesize 30
set verify off
col exec_user format a10

spool ora_PC_OLD$filedate.log

--find plan change sql_id in (gv\$sql and dba_hist_sqlstat recent n days )
--awr history in days
--define awr_his=7
--ACCEPT awr_his DEFAULT &awr_his PROMPT 'Please input recent awr days ,default is [&awr_his]:'
define exclude_users='and PARSING_SCHEMA_NAME not in (''SYS'',''SYSMAN'',''DBSNMP'')'
--define order_by='order by w_sum_exec'
--define order_by='order by b_sum_execs'
define order_by='order by ratio'

set term off

with plan_sum as (
  select sql_id,PARSING_SCHEMA_NAME, plan_hash_value
    ,sum(elapsed_time_delta) sum_ela
    ,ROUND((SUM(elapsed_time_delta)/SUM(GREATEST(executions_delta, 1))) ) avg_ela
    ,SUM(executions_delta) sum_exec
    from (
          select sql_id,plan_hash_value,elapsed_time_delta,executions_delta,PARSING_SCHEMA_NAME from dba_hist_sqlstat
          where  snap_id >= (select min(snap_id) from dba_hist_snapshot where begin_interval_time>=sysdate-$awr_his)
            and  plan_hash_value > 0 and elapsed_time_delta>0
            $DEFDISP &exclude_users
          union all
          select sql_id,plan_hash_value,elapsed_time,executions,PARSING_SCHEMA_NAME from gv\$sql
          where plan_hash_value > 0 and elapsed_time>0
            $DEFDISP &exclude_users
          )a
    group by sql_id,PARSING_SCHEMA_NAME, plan_hash_value --having SUM(executions_delta)>0
 ),
 ana_plan as
(
 select * from
 (
  select
        sql_id,PARSING_SCHEMA_NAME,plan_hash_value
       ,sum_ela
       ,sum_exec
       ,avg_ela
       ,count(*) over (partition by sql_id,PARSING_SCHEMA_NAME)  total_plans
       ,max(avg_ela) over (partition by sql_id,PARSING_SCHEMA_NAME) as max_avg_ela
       ,min(avg_ela) over (partition by sql_id,PARSING_SCHEMA_NAME) as min_avg_ela
      -- ,row_number() over (partition by sql_id,PARSING_SCHEMA_NAME order by avg_ela) as rn
   from plan_sum
 ) where total_plans>1
)
 select
  b_plan.sql_id,b_plan.PARSING_SCHEMA_NAME as exec_user
 ,b_plan.total_plans as plans
 ,b_plan.plan_hash_value as b_PHV
 ,w_plan.plan_hash_value as w_PHV
 ,round(b_plan.sum_ela/1e6,4) as b_sum_ela
 ,round(w_plan.sum_ela/1e6,4) as w_sum_ela
 ,b_plan.sum_exec as b_sum_execs
 ,w_plan.sum_exec as w_sum_exec
 ,round(b_plan.avg_ela/1e6,4) as b_avg_ela
 ,round(w_plan.avg_ela/1e6,4) as w_avg_ela
 ,round( w_plan.avg_ela/ b_plan.avg_ela,1) as ratio
 from (select * from ana_plan where avg_ela=min_avg_ela) b_plan,
      (select * from ana_plan where avg_ela=max_avg_ela) w_plan
 where
     b_plan.sql_id=w_plan.sql_id
 and b_plan.PARSING_SCHEMA_NAME=w_plan.PARSING_SCHEMA_NAME
 and round( w_plan.avg_ela/ b_plan.avg_ela,1) >=1.5
 and ((w_plan.avg_ela/1e6 >=1) or ( w_plan.avg_ela/1e6 <1 and  w_plan.sum_exec >=1))
&order_by;
$ECHO

spool off

!
echo "full nodes"
 echo "plan change info for recent $awr_his days. default is 7 "
  exit 0
fi


#####################################################################################################
if [ "$1" = "toparea" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER


    set linesize 300 pagesize 30

    col db_user format a10 trunc
    col "wait/elap" format a10
    col sql_text format a25
    col rank format 9999
    col avg_buffer format 99999999
    col rc format 999
    col rr format 999
    col rt format 999
    col inst# format 99
    col sql_id format a13
    spool ora_toparea_$filedate.log
    select a.*
    from
      (select inst_id as inst#,
            row_number() over (partition by inst_id order by cpu_time desc) as rc,
            row_number() over (partition by inst_id order by disk_reads desc) as rr,
            row_number() over (partition by inst_id order by elapsed_Time desc) as rt,
            PARSING_SCHEMA_NAME db_USER,
            sql_id,
            round(cpu_time/1e6) as cpu_s ,
            round(elapsed_Time/1e6) as elap_s ,
            round((elapsed_Time - cpu_time)/1e6) wait_s,
            trunc((elapsed_Time - cpu_time)*100/greatest(elapsed_Time,1),1)||'%' as "wait/elap",
            executions as execs,
            round(elapsed_Time/(executions+1)/1e6,2) ela_Pe,
            buffer_gets as tot_bufs,
            round(buffer_gets/greatest(executions,1),1) as avg_buf,
            disk_reads as reads,
            round(USER_IO_WAIT_TIME/1e6) as IOwait_s,
            substr(sql_text,1,20) sql_text
            from gv\$sqlarea t where inst_id=$INST
            --where elapsed_time > 20000　and PARSING_SCHEMA_NAME<>'SYS'
        ) a
    where rc <=5 or rr<=5 or rt<=5
    order by inst#,rc;
$ECHO
spool off

!
echo "instance_number=$INST"
  exit 0
fi


#####################################################################################################

if [ "$1" = "rman" ]; then

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 600
    --set head off

    Pro rman backup status:

    select * from
    (
    SELECT recid,operation,status,to_char(start_time,'yyyy-mm-dd hh24:mi:ss') as start_time
     ,to_char(end_time,'yyyy-mm-dd hh24:mi:ss') as end_time,object_type
    FROM V\$RMAN_STATUS
    WHERE START_TIME >= sysdate-100    AND OPERATION ='BACKUP'
     -- AND STATUS ='COMPLETED'
    order by start_time desc
    )
    where rownum<=50;
    $ECHO


    col TIME_TAKEN for a10
    col status for a10
    col INCR_0 for 9999
    col INCR_1 for 9999
    col BK_INST for 99
    col BACKUP_MB for 999999.99
    col DEVICE_TYPE for a11

    select * from ( select
    j.session_recid, --j.session_stamp,
    to_char(j.start_time, 'mm-dd hh24:mi:ss') start_time,
    to_char(j.end_time, 'mm-dd hh24:mi:ss') end_time,
    round((j.output_bytes/1024/1024),2) BACKUP_MB,
    j.status,
    j.input_type,
    decode(to_char(j.start_time, 'd'), 1, 'Sunday', 2, 'Monday',3, 'Tuesday', 4, 'Wednesday',5, 'Thursday', 6, 'Friday',7, 'Saturday') WEEK,
    round(j.elapsed_seconds,-1) ELAPSED_SECONDS,
    j.TIME_TAKEN_DISPLAY as TIME_TAKEN,
    x.controlfile,
    x.DB_FULL,
    x.incr_0,
    x.incr_1,
    x.l,
    ro.inst_id BK_INST,
    x.device_type
    from V\$RMAN_BACKUP_JOB_DETAILS j
    left outer join (select
                     d.session_recid, d.session_stamp,
                     sum(case when d.controlfile_included = 'YES' then d.pieces else 0 end) controlfile,
                     sum(case when d.controlfile_included = 'NO'
                               and d.backup_type||d.incremental_level = 'D' then d.pieces else 0 end) DB_FULL,
                     sum(case when d.backup_type||d.incremental_level = 'D0' then d.pieces else 0 end) incr_0,
                     sum(case when d.backup_type||d.incremental_level = 'I1' then d.pieces else 0 end) incr_1,
                     sum(case when d.backup_type = 'L' then d.pieces else 0 end) L,d.device_type
                   from
                     V\$BACKUP_SET_DETAILS d
                     join V\$BACKUP_SET s on s.set_stamp = d.set_stamp and s.set_count = d.set_count
                   where s.input_file_scan_only = 'NO'
                   group by d.session_recid, d.session_stamp,d.device_type) x
    on x.session_recid = j.session_recid and x.session_stamp = j.session_stamp
    left outer join (select o.session_recid, o.session_stamp, min(inst_id) inst_id
                   from GV\$RMAN_OUTPUT o
                   group by o.session_recid, o.session_stamp)
    ro on ro.session_recid = j.session_recid and ro.session_stamp = j.session_stamp
    where j.start_time > trunc(sysdate)-30
    order by j.start_time desc
    ) where rownum <= 100;

    $ECHO

!
  exit 0
fi


#####################################################################################################

if [ "$1" = "batch_osstat" -o "$1" = "osstat" ]; then

    if [ "$2" = ""  -o  "$3" = "" ]; then
      #echo "ora iostat <bid> <eid> "
      #exit 1
      bid="(select max(snap_id)-48 from dba_hist_snapshot)"
      eid="(select max(snap_id)    from dba_hist_snapshot)"
    else
       bid=$2
       eid=$3
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 100
    col END_SNAP_TIME format a20
    col inst_id format 9999
    spool ora_batch_osstat_${INST}_$filedate.log
    select os.instance_number as inst_id
         ,s.snap_id-1 as bid
         ,s.snap_id as eid
         ,to_char(s.end_interval_time,'yyyy-mm-dd hh24:mi:ss')  end_snap_time
         , round(load,2) as load
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(busy_time/(busy_time+idle_time)*100,2))   busy_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(user_time/(busy_time+idle_time)*100,2))   user_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(sys_time/(busy_time+idle_time)*100,2))     sys_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(idle_time/(busy_time+idle_time)*100,2))    idl_pct
         , decode(busy_time+idle_time,0,to_number(null)
                  , round(wio_time/(busy_time+idle_time)*100,2))     wio_pct
       from (select snap_id
            , instance_number
            , dbid
            , count(*)                                                        cnt
            , sum(decode(stat_name,'LOAD',value,0))                        load
            , sum(decode(stat_name,'BUSY_TIME',value-prev_value,0))   busy_time
            , sum(decode(stat_name,'IDLE_TIME',value-prev_value,0))   idle_time
            , sum(decode(stat_name,'USER_TIME',value-prev_value,0))   user_time
            , sum(decode(stat_name,'SYS_TIME',value-prev_value,0))     sys_time
            , sum(decode(stat_name,'IOWAIT_TIME',value-prev_value,0))  wio_time
            from (select snap_id
                 , instance_number
                 , dbid
                 , stat_name
                 , value
                 , lag(value,1) over (partition by stat_name,instance_number, dbid
                                      order by snap_id)   prev_value
                  from dba_hist_osstat
                  where snap_id >=$bid and snap_id <=$eid
                  and dbid = (select dbid from v\$database)
                  and instance_number = $INST
                 )
            group by snap_id,dbid,instance_number
            ) os
      , dba_hist_snapshot s
      where os.snap_id         = s.snap_id
      and os.instance_number = s.instance_number
      and os.instance_number = $INST
      and os.dbid            = s.dbid
    order by os.instance_number,os.snap_id;
    $ECHO
    spool off

!
echo "instance_number=$INST"
 echo "ora osstat for recent 48 snapshots"
  exit 0
fi

#####################################################################################################

if [ "$1" = "obj" ]; then

   if [ "$2" = "" ]; then
       echo "ora obj %optstat%  <owner>"
       exit 1
   fi

   if [ "$3" = "" ]; then
      pred=""
   else
      pred="and a.owner=upper('$3')"
   fi

   #echo $2
   #pref=$2|cut -c1-1
   #str1=$2
   #echo ${str1:1:1}
   #echo ${str1:2:10}
   #${str1:2:(20-5)} begin 2 len 15

   #if [ "$pref" = "=" ]; then
   # cond=" = upper($2"
   #else if [ "$pref" = "^" ]; then
   #
   #else if [ "$pref" = "*" ]; then
   # fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 40
    set tab      off
    col object_name format a30
    col owner format a15 trunc
    col SYNONYM_DB_LINK format a15 trunc
    col SYNONYM_OWNER format a15 trunc
    col object_type format a11 trunc
    col synonym_table format a10 trunc
    col table_name format a30
    col created format a17
    col LAST_DDL format a17
    col status format a6 trunc

    select a.owner,object_name,object_id,--data_object_id,
            object_type,status
           ,to_char(created,'yyyymmdd hh24:mi:ss') as created
           ,to_char(last_ddl_time,'yyyymmdd hh24:mi:ss') as last_ddl
           --,b.table_owner as synonym_owner,
           ,b.table_name as synonym_table,b.db_link as synonym_db_link
    from dba_objects a,dba_synonyms b
    where object_name like upper('$2')
         and a.object_name=b.synonym_name(+)
         and a.owner=b.owner(+) $pred
    order by a.owner,a.object_name;
    $ECHO
    --select * from dba_synonyms
    --where synonym_name like upper('%$2%');

!
#echo "ora obj %abc%  [owner] "
  exit 0
fi



#####################################################################################################
if [ "$1" = "table" -o "$1" = "tab" ]; then

  if [ "$2" = ""  ]; then
   read -p "Please input table_name:" tablename
    if [ -z "${tablename}" ];then
         echo "no input , exit"
         exit 1
    fi
  else
    tablename=$2
  fi

   if [ "$3" = ""  ]; then

    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_tables where table_name=upper('$tablename') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    if [ -z "${defowner}" ];then
       echo "table $tablename not found,please check again!"
       exit 1
    fi
   read -p "Please input table_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
         owner=$defowner
    fi
   else
    owner=$3
  fi

    ver2=`get_ver 2`
    if [ $ver2 -lt 11 ]; then
      ver2='--'
    else
      ver2=''
    fi
#    owner=$2
#    tablename=$3
    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 30
    col TRU for a30
    col filename new_value filename
    col filename format a30
    set trimspool on
    spool ora_table_${tablename}_${filedate}.log
    col high_value format a40 trunc
    col partition_name format a30 trunc
    col pos format 999
    col LAST_ANALYZED for a20
    col tablespace_name format a15 trunc
    set long 500000

    pro
    Pro Table Basic Information
    prompt ======================
    col owner format a10 trunc
    col table_name format a20 trunc
    col degree format a7
    col temporary format a9
    col segment_created format a5
    col logging format a7
    col compression format a9
    col created format a20
    col last_analyzed format a20
    col TABLESPACE_NAME format a15
    select a.owner,table_name, num_rows, blocks, trim(degree) as degree, a.temporary, a.logging,--a.segment_created,
           a.partitioned,a.compression,TABLESPACE_NAME, to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
           to_char(b.created,'yyyy-mm-dd hh24:mi:ss') as created
    from dba_tables a,dba_objects b
    where table_name=upper('$tablename') and a.owner=upper('$owner') and a.owner=b.owner and b.object_name=a.table_name and b.object_type='TABLE';
    $ECHO

    set timing off
    set serveroutput on
    set feedback off
    set verify off
    set linesize 500
    undefine table_name
    undefine owner
    var table_name varchar2(100);
    var owner varchar2(100);
    alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
begin
    :owner :=upper('$owner');
    :table_name := upper('$tablename');
end;
/
declare
    v_cnt number;
    v_open_mode varchar2(100) :=null;
    v_protection_mode  varchar2(100) :=null;
    v_switchover  varchar2(100) :=null;
    v_force_logging varchar2(100) :=null;

    cursor c_seg is
    select segment_name, round(sum(bytes)/1024/1024) m ,count(*) as segment_cnt
           ,max(tablespace_name) as max_tbs_name
    from dba_segments
    where  segment_name=upper(:table_name) and owner=upper(:owner)
    group by owner,segment_name;
    v_seg c_seg%rowtype;

    cursor c_stats is SELECT
     A.COLUMN_NAME,
     decode(t.DATA_TYPE, 'NUMBER',t.DATA_TYPE||'('|| decode(t.DATA_PRECISION, null,t.DATA_LENGTH||')', t.DATA_PRECISION||','||t.DATA_SCALE||')'), 'DATE',t.DATA_TYPE, 'LONG',t.DATA_TYPE, 'LONG RAW',t.DATA_TYPE,'ROWID',t.DATA_TYPE, 'MLSLABEL',t.DATA_TYPE, t.DATA_TYPE||'('||t.DATA_LENGTH||')') ||' '||
     decode(t.nullable, 'N','NOT NULL', 'n','NOT NULL', NULL) col1,
              B.NUM_ROWS,
              T.NUM_NULLS,
              round(100 * T.DENSITY,2) as DENSITY,
              A.NUM_DISTINCT CARDINALITY,
              ROUND(A.NUM_DISTINCT / decode(B.NUM_ROWS,0,1,B.NUM_ROWS) * 100, 2) SELECTIVITY,
              A.HISTOGRAM,
              A.NUM_BUCKETS,
              decode(T.SAMPLE_SIZE,null,0,T.SAMPLE_SIZE) as SAMPLE_SIZE,
              T.GLOBAL_STATS,
              T.USER_STATS,
              decode(to_char(T.last_analyzed,'YYYYMMDD HH24:MI'),null,'None',to_char(T.last_analyzed,'YYYYMMDD HH24:MI')) as last1
        FROM DBA_TAB_COL_STATISTICS A, DBA_TABLES B,dba_tab_columns T
    WHERE A.OWNER = B.OWNER AND A.OWNER = T.OWNER
     AND A.TABLE_NAME = T.TABLE_NAME
     AND A.TABLE_NAME = B.TABLE_NAME
     AND T.COLUMN_NAME = A.COLUMN_NAME
     AND A.TABLE_NAME = upper(:table_name) AND a.owner = upper(:owner) order by A.OWNER,A.COLUMN_NAME;
     v_stats c_stats%rowtype;

   cursor c_p_s is SELECT A.PARTITION_NAME, A.COLUMN_NAME,
 decode(t.DATA_TYPE,'NUMBER',t.DATA_TYPE||'('|| decode(t.DATA_PRECISION, null,t.DATA_LENGTH||')', t.DATA_PRECISION||','||t.DATA_SCALE||')'),'DATE',t.DATA_TYPE, 'LONG',t.DATA_TYPE, 'LONG RAW',t.DATA_TYPE,'ROWID',t.DATA_TYPE, 'MLSLABEL',t.DATA_TYPE, t.DATA_TYPE||'('||t.DATA_LENGTH||')') ||' '||
 decode(t.nullable,'N','NOT NULL','n','NOT NULL', NULL) col1,
 case when to_char(B.NUM_ROWS) is null then 'None' else to_char(B.NUM_ROWS) end as NUM_ROWS,
 case when to_char(A.NUM_NULLS) is null then 'None' else to_char(A.NUM_NULLS) end as NUM_NULLS,
 case when to_char(round(100 * A.DENSITY,2)) is null then 'None' else to_char(round(100 * A.DENSITY,2)) end as DENSITY,
 case when to_char(round(A.NUM_DISTINCT)) is null then 'None' else to_char(round(A.NUM_DISTINCT)) end as CARDINALITY,
 ROUND(A.NUM_DISTINCT / decode(B.NUM_ROWS,0,1,B.NUM_ROWS) * 100, 2) SELECTIVITY, A.HISTOGRAM,
 case when to_char(A.NUM_BUCKETS) is null then 'None' else to_char(A.NUM_BUCKETS) end as NUM_BUCKETS,
 decode(A.SAMPLE_SIZE,null,0,A.SAMPLE_SIZE) as SAMPLE_SIZE, A.GLOBAL_STATS, A.USER_STATS,
 decode(to_char(A.last_analyzed,'YYYYMMDD HH24:MI'),null,'None',to_char(A.last_analyzed,'YYYYMMDD HH24:MI')) as last1
  FROM dba_PART_COL_STATISTICS A, dba_tab_partitions B,dba_tab_columns T
 WHERE A.OWNER = B.TABLE_OWNER and A.OWNER = T.OWNER
   and A.TABLE_NAME = T.TABLE_NAME
   and A.TABLE_NAME = B.TABLE_NAME
   AND A.PARTITION_NAME = B.PARTITION_NAME
   AND T.COLUMN_NAME = A.COLUMN_NAME
   AND A.TABLE_NAME = upper(:table_name)
   AND a.owner = upper(:owner) order by B.PARTITION_POSITION,A.PARTITION_NAME,A.OWNER,A.COLUMN_NAME;
   ips c_p_s%rowtype;

   cursor c_hwm is SELECT table_name,
                          ROUND((blocks * (select value from v\$parameter where name='db_block_size'))/1024/1024, 2) "HWM",
                          ROUND((num_rows * avg_row_len / 1024/ 1024 ), 2) as REAL_USED,
                          ROUND((blocks * (select pct_free  from dba_tables where table_name = :table_name and rownum = 1) / 100) * 8 /1024, 2) "PCT_FREE",
   round((blocks * 8 - (num_rows * avg_row_len / 1024) - blocks * 8 * 10 / 100) /1024, 2) "WASTE_SPACE"
   FROM dba_tables
   WHERE temporary = 'N' and table_name = :table_name
   and owner = :owner
   ORDER BY 5 DESC;
   v_hwm c_hwm%rowtype;

   cursor c_sta is select
   case when PARTITION_POSITION is null then '0' else to_char(PARTITION_POSITION) end as POSITION,
    table_name, blocks, empty_blocks, avg_space, chain_cnt, avg_row_len,
    case when PARTITION_NAME is null then upper(:table_name) else PARTITION_NAME end as PARTITION_NAME ,
    case when stale_stats is null then 'None' else stale_stats end as stale_stats,
    case when stattype_locked is null then 'None' else stattype_locked end as stattype_locked,
    decode(to_char(last_analyzed,'YYYYMMDD HH24:MI:SS'),null,'None',to_char(last_analyzed,'YYYYMMDD HH24:MI:SS')) as LAST_ANALYZED
    from dba_tab_statistics where owner = upper(:owner) and table_name = upper(:table_name) order by PARTITION_POSITION;
   v_sta c_sta%rowtype;

   cursor c_modi is select b.TABLE_OWNER, b.TABLE_NAME,
                    case when b.PARTITION_NAME is null then b.TABLE_NAME else b.PARTITION_NAME end as PARTITION_NAME, b.INSERTS, b.UPDATES, b.DELETES,
                    to_char(b.TIMESTAMP,'yyyy-mm-dd hh24:mi:ss') as flush_time, b.truncated
   from dba_tab_modifications b where b.table_name = upper(:table_name) and b.table_owner = upper(:owner) order by b.timestamp;
   v_modi c_modi%rowtype;

   cursor c_tab_partitions is select T.PARTITION_POSITION, T.PARTITION_NAME, T.HIGH_VALUE as HIGH_VALUE ,
                               case when t.NUM_ROWS is null then 'None' else to_char(t.NUM_ROWS) end as NUM_ROWS,
                               case when T.SAMPLE_SIZE is null then 0 else t.SAMPLE_SIZE end as SAMPLE_SIZE,
                               case when to_char(t.last_analyzed,'YYYYMMDD hh24:mi:ss') is null then 'None' else to_char(t.last_analyzed,'YYYYMMDD hh24:mi:ss') end as last_analyzed,
                               case when round(S.G,2) is null then 0 else round(S.G,2) end as G,
                               t.subpartition_count as subpartition_cnt,
                               t.COMPRESSION,
                               t.logging
   from dba_tab_partitions t
   left join (select sum(bytes/1024/1024/1024) G ,partition_name from dba_segments where segment_name = upper(:table_name) and owner = upper(:owner) group by partition_name) s
   on s.partition_name = t.PARTITION_NAME
   where t.table_owner = upper(:owner)
      and t.table_name = upper(:table_name)
   order by t.PARTITION_POSITION;

   v_tab_pars c_tab_partitions%rowtype;
   cursor c_j is SELECT c.name as column_name,
       decode(to_char(cu.timestamp,'yyyymmdd hh24:mi:ss'),null,'None',to_char(cu.timestamp,'yyyymmdd hh24:mi:ss'))            as timestamp,
       decode(cu.equality_preds,null,0,cu.equality_preds)       as where_equal_search,
       decode(cu.equijoin_preds,null,0,cu.equijoin_preds)       as equal_join,
       decode(cu.nonequijoin_preds,null,0,cu.nonequijoin_preds) as none_equal_join,
       decode(cu.range_preds,null,0,cu.range_preds)             as where_range_search,
       decode(cu.like_preds,null,0,cu.like_preds)               as where_like_search,
       decode(cu.null_preds,null,0,cu.null_preds)               as where_null_search
   FROM sys.col$ c, sys.col_usage$ cu, sys.obj$ o, sys.user$ u WHERE c.obj# = cu.obj# (+)
   AND c.intcol# = cu.intcol# (+)
   AND c.obj# = o.obj#
   AND o.owner# = u.user#
   AND o.name = :table_name
   AND u.name = :owner ORDER BY c.col#;
    v_j c_j%rowtype;

    cursor c_his_t is select h.savtime, h.rowcnt, h.blkcnt, h.avgrln, h.analyzetime from sys.wri\$_optstat_tab_history h,dba_objects t
where t.OBJECT_ID = h.obj# and t.object_name = :table_name;
    v_his_t c_his_t%rowtype;

    cursor c_partition_by is
    select column_name,column_position
    from dba_part_key_columns
    where owner=:owner and name=:table_name and object_type='TABLE'
    order by column_position;
    v_partition_by c_partition_by%rowtype;

    cursor c_sub_partition_by is
    select column_name,column_position
    from dba_subpart_key_columns
    where owner=:owner and name=:table_name and object_type='TABLE'
    order by column_position;
    v_sub_partition_by c_sub_partition_by%rowtype;
    v_stale_stats varchar2(100);
begin
  dbms_output.enable(buffer_size=>NULL);
  select count(*) into v_cnt from dba_segments where segment_name = upper(:table_name) and owner = upper(:owner);

if v_cnt = 1 then
  dbms_output.put_line('
Non partition Table Segment Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------');
  dbms_output.put_line('| SEGMENT_NAME    |' || ' SEGMENT_SIZE(MB) ' || '| SEGMENT_CNT |' || ' MAX_TABLESPACE_NAME    ' || '|');
  dbms_output.put_line('-----------------------------------------------------------------------------');
  open c_seg;
    loop fetch c_seg into v_seg;
    exit when c_seg%notfound;
    dbms_output.put_line('| ' || lpad(v_seg.SEGMENT_NAME,15) ||' | '|| lpad(v_seg.M,16) || ' | '|| lpad(v_seg.segment_cnt,11) || ' | '|| lpad(v_seg.max_tbs_name,22) || ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------');
  close c_seg;

  dbms_output.put_line('
Non partition Table HWM Information basic Statistics');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------');
  dbms_output.put_line('| HWM(MB)            |' || ' REAL_USED(MB)      ' || '| PCT_FREE_NEED_SPACE(MB)  |' || ' WASTE_SPACE(MB)        ' || '|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------');
  open c_hwm;
    loop fetch c_hwm into v_hwm;
    exit when c_hwm%notfound;
    dbms_output.put_line('| ' || lpad(v_hwm.HWM,18) ||' | '|| lpad(v_hwm.REAL_USED,18) || ' | '|| lpad(v_hwm.PCT_FREE,24) || ' | '|| lpad(v_hwm.WASTE_SPACE,22) || ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------');
  close c_hwm;

  dbms_output.put_line('
SELECT% Means SELECTIVITY
GST Means GLOBAL_STATS
UST Means USER_STATS
Non partition Table Statistics Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| COLUMN_NAME          |' || ' COLUMN_DETAIL        | ' ||' NUM_ROWS   |' || ' NUM_NULLS   |'|| ' DENSITY ' || '| CARDINALITY |' || ' SELECT% ' || '| HISTOGRAM |' || ' NUM_BUCKETS' || ' | SAMPLE_SIZE |'|| ' GST ' || '| UST ' ||'|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_stats;
    loop fetch c_stats into v_stats;
    exit when c_stats%notfound;
    dbms_output.put_line('| ' || rpad(v_stats.COLUMN_NAME,20) ||' | '|| rpad(v_stats.COL1,20)  ||' | '|| lpad(v_stats.NUM_ROWS,11) || ' | '|| lpad(v_stats.NUM_NULLS,11) || ' | ' || lpad(v_stats.DENSITY,7) ||' | '|| lpad(v_stats.CARDINALITY,11) || ' | '|| lpad(v_stats.SELECTIVITY || '%',7) || ' | '|| lpad(v_stats.HISTOGRAM,9) || ' | '|| lpad(v_stats.NUM_BUCKETS,11) ||' | ' || lpad(v_stats.SAMPLE_SIZE,11) ||' | ' || lpad(v_stats.GLOBAL_STATS,3)|| ' | ' || lpad(v_stats.USER_STATS,3) || ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_stats;

  dbms_output.put_line('
Non partition Table Statistics STALE_STATS, Yes Means Expired');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| TABLE_NAME           |' || ' STALE_STATS |' || ' LAST_ANALYZED       ' || '| BLOCKS     |' || ' EMPTY_BLOCKS ' || '| AVG_SPACE  |' || ' CHAIN_CNT    ' || '| AVG_ROW_LEN  ' || '|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------');
  open c_sta;
    loop fetch c_sta into v_sta;
    exit when c_sta%notfound;
    dbms_output.put_line('| ' || lpad(v_sta.TABLE_NAME,20) || ' | ' || lpad(v_sta.STALE_STATS,11) ||' | '|| lpad(v_sta.LAST_ANALYZED,19) || ' | ' || lpad(v_sta.BLOCKS,10) || ' | ' || lpad(v_sta.EMPTY_BLOCKS,12) || ' | ' || lpad(v_sta.AVG_SPACE,10) || ' | ' || lpad(v_sta.CHAIN_CNT,12) || ' | ' || lpad(v_sta.AVG_ROW_LEN,12) ||  ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------------');
  close c_sta;

select case when stale_stats is null then 'None' else stale_stats end as stale_stats into v_stale_stats
 from dba_tab_statistics
 where owner = upper(:owner)
 and table_name = upper(:table_name)
 order by PARTITION_POSITION;

 if v_stale_stats <> 'NO' then

  dbms_output.put_line('
Non partition Table Modification,Stats Expired Reason Information(dba_tab_modifications)');
  dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------------------------------------------------');
  dbms_output.put_line('|'  || ' INSERTS          |' || ' UPDATES      ' || '| DELETES      |' || ' FLUSH_TIME          ' || '| TRUNCATED ' || '|');
  dbms_output.put_line('------------------------------------------------------------------------------------');
  open c_modi;
    dbms_stats.flush_database_monitoring_info;
    loop fetch c_modi into v_modi;
    exit when c_modi%notfound;
    dbms_output.put_line('| ' || lpad(v_modi.INSERTS,16) ||' | '|| lpad(v_modi.UPDATES,12) || ' | '|| lpad(v_modi.DELETES,12) || ' | '|| lpad(v_modi.flush_time,19) || ' | ' || lpad(v_modi.truncated,9) || ' |');
    end loop;
    dbms_output.put_line('------------------------------------------------------------------------------------');
  close c_modi;
 end if;

  dbms_output.put_line('
Count the number of occurrences for Join or Where');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| COLUMN_NAME           |' || ' TIMESTAMP         |' || ' where = search ' || '| = join |' || ' <> join ' || '| where_range_search |' || ' where_like_search ' || '| where_null_search ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_stats.flush_database_monitoring_info;
  open c_j;
    loop fetch c_j into v_j;
    exit when c_j%notfound;
    dbms_output.put_line('| ' || rpad(v_j.column_name,21) || ' | ' || rpad(v_j.timestamp,17) ||' | '|| lpad(v_j.where_equal_search,14) || ' | ' || lpad(v_j.equal_join,6) || ' | ' || lpad(v_j.none_equal_join,7) || ' | ' || lpad(v_j.where_range_search,18) || ' | ' || lpad(v_j.where_like_search,17) || ' | ' || lpad(v_j.where_null_search,17) ||  ' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  close c_j;

  else
  dbms_output.put_line('
partition Table partition by Info');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------');
  dbms_output.put_line('| COLUMN_NAME      |' || ' COLUMN_POSITION ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------');
  open c_partition_by;
    loop fetch c_partition_by into v_partition_by;
    exit when c_partition_by%notfound;
    dbms_output.put_line('| ' || lpad(v_partition_by.COLUMN_NAME,15) ||' | '|| lpad(v_partition_by.COLUMN_POSITION,14) || ' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------');
  close c_partition_by;

  dbms_output.put_line('
partition Table Sub partition by Info');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------');
  dbms_output.put_line('| COLUMN_NAME      |' || ' COLUMN_POSITION ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------');
  open c_sub_partition_by;
    loop fetch c_sub_partition_by into v_sub_partition_by;
    exit when c_sub_partition_by%notfound;
    dbms_output.put_line('| ' || lpad(v_sub_partition_by.COLUMN_NAME,15) ||' | '|| lpad(v_sub_partition_by.COLUMN_POSITION,14) || ' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------');
  close c_sub_partition_by;

  dbms_output.put_line('
partition Table Segment Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------');
  dbms_output.put_line('| SEGMENT_NAME    |' || ' SEGMENT_SIZE(MB) ' || '| SEGMENT_CNT |' || ' MAX_TABLESPACE_NAME    ' || '|');
  dbms_output.put_line('-----------------------------------------------------------------------------');
  open c_seg;
    loop fetch c_seg into v_seg;
    exit when c_seg%notfound;
    dbms_output.put_line('| ' || lpad(v_seg.SEGMENT_NAME,15) ||' | '|| lpad(v_seg.M,16) || ' | '|| lpad(v_seg.segment_cnt,11) || ' | '|| lpad(v_seg.max_tbs_name,22) || ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------');
  close c_seg;

  dbms_output.put_line('
Partition Table Segment Information
None Means Havent Gather Partition Statistics
POS# Means Partition POSITION
SIZE_GB Means Partition Size GB
LOG? Means Is LOGGING?');
  dbms_output.put_line('======================');

    open c_tab_partitions;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
    dbms_output.put_line('| POS# |' || ' PARTITION_NAME    ' || '| HIGH_VALUE                                                   |' || ' NUM_ROWS    ' || '| SAMPLE_SIZE |' || ' SIZE_GB '|| '| SUB_CNT |' || ' COMPRESS ' || '| LOG? ' || '| LAST_ANALYZED     ' ||'|');
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
    loop fetch c_tab_partitions into v_tab_pars;
    exit when c_tab_partitions%notfound;
    dbms_output.put_line('| '|| lpad(v_tab_pars.PARTITION_POSITION,4) || ' | ' || rpad(v_tab_pars.partition_name,17) || ' | ' || rpad(v_tab_pars.HIGH_VALUE ||'.',60) || ' | ' || lpad(v_tab_pars.NUM_ROWS,11) || ' | ' || lpad(v_tab_pars.SAMPLE_SIZE,11) || ' | ' || lpad(v_tab_pars.g,7) || ' | ' || lpad(v_tab_pars.subpartition_cnt,7) ||  ' | ' || lpad(v_tab_pars.compression,8) || ' | ' ||lpad(v_tab_pars.logging,4)|| ' | '|| lpad(v_tab_pars.LAST_ANALYZED,17) || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_tab_partitions;

  dbms_output.put_line('
Partition Table Statistics Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| PARTITION_NAME       ' || '| COLUMN_NAME          |' ||  ' COLUMN_TYPE             |'  || ' NUM_ROWS      ' || '| NUM_NULLS     ' || '| DENSITY ' || '| CARDINALITY |' || ' SELECT% ' || '| HISTOGRAM      |' || ' NUM_BUCKETS ' || '| SAMPLE_SIZE |' || ' GLOBAL_STATS ' || '| USER_STATS |' || ' LAST_ANALYZED  ' || '|');
  dbms_output.put_line('---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_p_s;
    loop fetch c_p_s into ips;
    exit when c_p_s%notfound;
    dbms_output.put_line('| ' || rpad(ips.PARTITION_NAME,20)||' | '|| rpad(ips.COLUMN_NAME,20) ||' | '|| rpad(ips.col1,23) ||' | '||lpad(ips.NUM_ROWS,13)|| ' | '||lpad(ips.NUM_NULLS,13)|| ' | '|| lpad(ips.DENSITY,7)|| ' | '|| lpad(ips.CARDINALITY,11) || ' | '|| lpad(ips.SELECTIVITY || '%',7) || ' | '|| rpad(ips.HISTOGRAM,14) || ' | '|| lpad(ips.NUM_BUCKETS,11) || ' | '||lpad(ips.SAMPLE_SIZE,11) || ' | '|| lpad(ips.GLOBAL_STATS,12) || ' | '|| lpad(ips.USER_STATS,10) || ' | '|| rpad(ips.last1,15) || '|');
    end loop;
    dbms_output.put_line('---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_p_s;

  dbms_output.put_line('
Partitioned Table Statistics STALE_STATS, Yes Means Expired from dba_tab_statistics');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------');
  dbms_output.put_line('| POS# |' || ' PARTITION_NAME   ' || '| STALE_STATS |' || ' LOCKED |' || ' LAST_ANALYZED     ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------');
  open c_sta;
    loop fetch c_sta into v_sta;
    exit when c_sta%notfound;
    dbms_output.put_line('| ' || lpad(v_sta.position,4)|| ' | ' || rpad(v_sta.partition_name,16) || ' | ' ||lpad(v_sta.STALE_STATS,11) ||' | ' || lpad(v_sta.stattype_locked,6) || ' | '|| lpad(v_sta.LAST_ANALYZED,17) || ' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------');
  close c_sta;


  dbms_output.put_line('
Partition Table Modification Information(dba_tab_modifications)');
  dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('|' || ' PARTITION_NAME ' || ' | ' || ' INSERTS         |' || ' UPDATES      ' || '| DELETES      |' || ' FLUSH_TIME          ' || '| TRUNCATED ' || '|');
  dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  open c_modi;
    dbms_stats.flush_database_monitoring_info;
    loop fetch c_modi into v_modi;
    exit when c_modi%notfound;
    dbms_output.put_line('| ' || rpad(v_modi.partition_name,15) || ' | ' || lpad(v_modi.INSERTS,16) ||' | '|| lpad(v_modi.UPDATES,12) || ' | '|| lpad(v_modi.DELETES,12) || ' | '|| lpad(v_modi.flush_time,19) || ' | ' || lpad(v_modi.truncated,9) || ' |');
    end loop;
    dbms_output.put_line('------------------------------------------------------------------------------------------------------');
  close c_modi;

  dbms_output.put_line('
Count the number of occurrences for Join or Where');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| COLUMN_NAME           |' || ' TIMESTAMP         |' || ' where = search ' || '| = join |' || ' <> join ' || '| where_range_search |' || ' where_like_search ' || '| where_null_search ' || '|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_stats.flush_database_monitoring_info;
  open c_j;
    loop fetch c_j into v_j;
    exit when c_j%notfound;
    dbms_output.put_line('| ' || rpad(v_j.column_name,21) || ' | ' || rpad(v_j.timestamp,17) ||' | '|| lpad(v_j.where_equal_search,14) || ' | ' || lpad(v_j.equal_join,6) || ' | ' || lpad(v_j.none_equal_join,7) || ' | ' || lpad(v_j.where_range_search,18) || ' | ' || lpad(v_j.where_like_search,17) || ' | ' || lpad(v_j.where_null_search,17) ||  ' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------------------------------------------------');
  close c_j;

  dbms_output.put_line('
HWM Information Rely on Table Statistics');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER                 |' || ' TABLE_NAME                       |' || ' SEGMENT_TYPE   ' || '| SEGMENT_MB     |' || ' WASTER% ' || '|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------');

end if;
end;
/
    $ECHO
    spool off
!

  exit 0
fi
###################################################stats#######################################################

if [ "$1" = "stats" -o "$1" = "statistics" ]; then

  if [ "$2" = ""  ]; then
   read -p "Please input table_name:" tablename
    if [ -z "${tablename}" ];then
         echo "no input , exit"
         exit 1
    fi
  else
    tablename=$2
  fi

   if [ "$3" = ""  ]; then

    defowner=`echo "select trim(12345||LISTAGG (owner,',') WITHIN GROUP (ORDER BY owner)) AS owner from dba_tables where table_name=upper('$tablename') and rownum<=4;" | sqlplus -s $DBUSER|grep 12345|cut -c 6-100`
    if [ -z "${defowner}" ];then
       echo "table $tablename not found,please check again!"
       exit 1
    fi
   read -p "Please input table_owner,default is [$defowner]:" owner
    if [ -z "${owner}" ];then
         owner=$defowner
    fi
   else
    owner=$3
  fi

    ver2=`get_ver 2`
    if [ $ver2 -lt 11 ]; then
      ver2='--'
    else
      ver2=''
    fi

#    owner=$2
#    tablename=$3

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 30
    col TRU for a30
    col filename new_value filename
    col filename format a30
    spool ora_stats_${tablename}_${filedate}.log
    set timing off
    set serveroutput on
    set feedback off
    set verify off
    set linesize 500
    undefine table_name
    undefine owner
    var table_name varchar2(100);
    var owner varchar2(100);
    alter session set nls_date_format='yyyy-mm-dd hh24:mi:ss';
    begin
      :owner :=upper(':owner');
      :table_name := upper(':tablename');
      end;
      /
  declare
    v_cnt number;
    v_open_mode varchar2(100) :=null;
    v_protection_mode  varchar2(100) :=null;
    v_switchover  varchar2(100) :=null;
    v_force_logging varchar2(100) :=null;

    cursor c_sys is select client_name,status from DBA_AUTOTASK_CLIENT;
    v_sys c_sys%rowtype;

    cursor c_lock0 is select owner,table_name,stattype_locked
    from dba_tab_statistics
    where owner = :owner
    and stattype_locked is not null;
    v_lock0 c_lock0%rowtype;

    cursor c_lock is select q'[exec DBMS_STATS.UNLOCK_TABLE_STATS(OWNNAME=> ']' || OWNER || q'[',TABNAME=> ']' || SEGMENT_NAME  || q'[');]' as sql_command
  from (SELECT OWNER,
                     SEGMENT_NAME,
                     SUM(BYTES / 1024 / 1024 / 1024) SIZE_GB
                FROM DBA_SEGMENTS a
               WHERE (owner,SEGMENT_NAME) IN
                     (SELECT /*+ UNNEST */
                      DISTINCT owner,TABLE_NAME
                        FROM DBA_TAB_STATISTICS
                       WHERE  OWNER = :owner
    and stattype_locked is not null)
               GROUP BY OWNER, SEGMENT_NAME);
    v_lock c_lock%rowtype;

    cursor c_expire is SELECT OWNER,
    SEGMENT_NAME,
    CASE
    WHEN SIZE_GB < 0.5 THEN 100 WHEN SIZE_GB >= 0.5 AND SIZE_GB < 1 THEN 80
    WHEN SIZE_GB >= 1 AND SIZE_GB < 5 THEN 50
    WHEN SIZE_GB >= 5 AND SIZE_GB < 10 THEN 30
    WHEN SIZE_GB >= 10 THEN 10 END AS PERCENT,
    1 AS DEGREE
FROM (SELECT OWNER,SEGMENT_NAME,SUM(BYTES / 1024 / 1024 / 1024) SIZE_GB
      FROM DBA_SEGMENTS a
      WHERE (owner,SEGMENT_NAME)
      IN (SELECT /*+ UNNEST */ DISTINCT owner,TABLE_NAME  FROM DBA_TAB_STATISTICS
           WHERE (LAST_ANALYZED IS NULL OR STALE_STATS = 'YES'
--       OR last_analyzed < sysdate -7
)
           AND OWNER = :owner
           AND TABLE_NAME not in ('PCASE','VTE_PADUA_INFO','VTE_CAPRINI_INFO','DOC_TYPE_DICT')
           AND stattype_locked is null
) and not exists (select null from dba_tables b where b.iot_type = 'IOT_OVERFLOW' and a.segment_name = b.table_name)
GROUP BY OWNER, SEGMENT_NAME);
    v_expire c_expire%rowtype;

    cursor c_expire0 is select q'[exec DBMS_STATS.GATHER_TABLE_STATS(OWNNAME=> ']' || OWNER || q'[',TABNAME=> ']' || SEGMENT_NAME || q'[',ESTIMATE_PERCENT =>]' || PERCENT || q'[,METHOD_OPT=> 'for all columns size auto',DEGREE=> 50,CASCADE => TRUE);]' as sql_command
  from (
  SELECT OWNER,
        SEGMENT_NAME,
             CASE
               WHEN SIZE_GB < 0.5 THEN
                30
               WHEN SIZE_GB >= 0.5 AND SIZE_GB < 1 THEN
                20
               WHEN SIZE_GB >= 1 AND SIZE_GB < 5 THEN
                10
               WHEN SIZE_GB >= 5 AND SIZE_GB < 10 THEN
                5
               WHEN SIZE_GB >= 10 THEN
                1
             END AS PERCENT,
             8 AS DEGREE
        FROM (SELECT OWNER,
                     SEGMENT_NAME,
                     SUM(BYTES / 1024 / 1024 / 1024) SIZE_GB
                FROM DBA_SEGMENTS a
               WHERE (owner,SEGMENT_NAME) IN
                     (SELECT /*+ UNNEST */
                      DISTINCT owner,TABLE_NAME
                        FROM DBA_TAB_STATISTICS
                       WHERE  OWNER =:owner
    and stattype_locked is null and last_analyzed < sysdate -1)
               GROUP BY OWNER, SEGMENT_NAME)
  order BY PERCENT);
    v_expire0 c_expire0%rowtype;

    cursor c_temp is SELECT /*+ NO_MERGE */
       s.owner, s.table_name
  FROM dba_tab_statistics s,
       dba_tables t
 WHERE s.object_type = 'TABLE'
   AND s.owner = :owner
   AND s.last_analyzed IS NOT NULL
   /*AND s.stale_stats = 'YES'*/
   AND t.temporary = 'Y'
   AND t.owner = s.owner
   AND t.table_name = s.table_name
   AND NOT EXISTS (
SELECT NULL
  FROM dba_external_tables e
 WHERE e.owner = s.owner
   AND e.table_name = s.table_name
)
 ORDER BY
       s.owner, s.table_name;
   v_temp c_temp%rowtype;

   cursor c_expire_index_stats is
   SELECT /*+ NO_MERGE */
       s.table_name,
       s.index_name,
       s.stale_stats,
       to_char(s.last_analyzed,'YYYY/MM/DD HH24:MI:SS') as last_analyzed
  FROM dba_ind_statistics s,
       dba_indexes t
 WHERE s.OBJECT_TYPE = 'INDEX'
   AND s.owner = :owner
   AND (s.last_analyzed IS NULL or s.stale_stats = 'YES' or s.last_analyzed < sysdate -7)
   AND s.table_name NOT LIKE 'BIN%'
   AND NOT (s.table_name LIKE '%TEMP' OR s.table_name LIKE '%_TEMP_%' )
   AND t.owner = s.owner
   AND t.index_name = s.INDEX_NAME
   AND t.table_name = s.table_name
   AND t.temporary = 'N'
   and t.index_type != 'LOB'
   AND NOT EXISTS (
SELECT NULL
  FROM dba_external_tables e
 WHERE e.owner = s.owner
   AND e.owner = :owner
   AND e.table_name = s.table_name
)
 ORDER BY
       s.owner, s.table_name;
   v_expire_index_stats c_expire_index_stats%rowtype;

   v_expired_table_cnt number;
   v_lock_table_stats_cnt number;
   v_temp_stat_cnt number;
   v_cnt_expired_index_stats number;
begin
  dbms_output.enable(buffer_size => NULL);

  dbms_output.put_line('
Auto Statistics Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------');
  dbms_output.put_line('| CLIENT_NAME                         |' || ' STATUS     ' || '|');
  dbms_output.put_line('----------------------------------------------------');
  open c_sys;
    loop fetch c_sys into v_sys;
    exit when c_sys%notfound;
    dbms_output.put_line('| ' || rpad(v_sys.CLIENT_NAME,35) ||' | '|| rpad(v_sys.STATUS,10) || ' |');
    end loop;
    dbms_output.put_line('----------------------------------------------------');
  close c_sys;

SELECT count(*) into v_expired_table_cnt
FROM (SELECT OWNER,SEGMENT_NAME,SUM(BYTES / 1024 / 1024 / 1024) SIZE_GB
      FROM DBA_SEGMENTS a
      WHERE (owner,SEGMENT_NAME)
      IN (SELECT /*+ UNNEST */ DISTINCT owner,TABLE_NAME  FROM DBA_TAB_STATISTICS
           WHERE (LAST_ANALYZED IS NULL OR STALE_STATS = 'YES'
--       OR last_analyzed < sysdate -7
)
           AND OWNER = :owner
           AND TABLE_NAME not in ('PCASE','VTE_PADUA_INFO','VTE_CAPRINI_INFO','DOC_TYPE_DICT')
           AND stattype_locked is null
) and not exists (select null from dba_tables b where b.iot_type = 'IOT_OVERFLOW' and a.segment_name = b.table_name)
GROUP BY OWNER, SEGMENT_NAME);
if  v_expired_table_cnt > 0 then
  dbms_output.put_line('
The Table Statistics are Expired ');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------');
  dbms_output.put_line('| TABLE_OWNER      |' || ' TABLE_NAME                       |' || ' DEGREE          ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------------');
  open c_expire;
    loop fetch c_expire into v_expire;
    exit when c_expire%notfound;
    dbms_output.put_line('| ' || rpad(v_expire.owner,16) || ' | ' || rpad(v_expire.SEGMENT_NAME,32) ||' | '|| rpad(v_expire.DEGREE,15) ||  ' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------');
  close c_expire;

   dbms_output.put_line('
Gather table statistics using dbms_stats.gather_table_stats Based on the username entered');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| Gather Table Statistics Command                                                                                                                                                                |');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_expire0;
    loop fetch c_expire0 into v_expire0;
    exit when c_expire0%notfound;
    dbms_output.put_line('| ' || rpad(v_expire0.sql_command,190) || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_expire0;

else
  dbms_output.put_line('
There is No Expired Table Statistics for Current Owner');
  dbms_output.put_line('======================');
end if;

select count(*) into v_lock_table_stats_cnt
    from dba_tab_statistics
    where owner = :owner
    and stattype_locked is not null;

if v_lock_table_stats_cnt > 0 then
  dbms_output.put_line('
The Table Statistics are Locked for Current Owner');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------');
  dbms_output.put_line('| TABLE_OWNER      |' || ' TABLE_NAME                       |' || ' stattype_locked ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------------');
  open c_lock0;
    loop fetch c_lock0 into v_lock0;
    exit when c_lock0%notfound;
    dbms_output.put_line('| ' || rpad(v_lock0.owner,16) || ' | ' || rpad(v_lock0.table_name,32) ||' | '|| rpad(v_lock0.stattype_locked,15) ||  ' |');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------');
  close c_lock0;
  dbms_output.put_line('
unlock table statistics using dbms_stats.unlock_table_stats Based on the username entered');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| UNLOCK TABLE Statistics Command                                                                      ' ||'|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  open c_lock;
    loop fetch c_lock into v_lock;
    exit when c_lock%notfound;
    dbms_output.put_line('| ' || rpad(v_lock.sql_command,100)    || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  close c_lock;
else
  dbms_output.put_line('
There is No Table Statistics are Locked for Current Owner');
  dbms_output.put_line('======================');
end if;

SELECT count(*) into v_temp_stat_cnt FROM dba_tab_statistics s, dba_tables t
 WHERE s.object_type = 'TABLE'
   AND s.owner = :owner
   AND s.last_analyzed IS NOT NULL
   /*AND s.stale_stats = 'YES'*/
   AND t.temporary = 'Y'
   AND t.owner = s.owner
   AND t.table_name = s.table_name
   AND NOT EXISTS ( SELECT NULL FROM dba_external_tables e
 WHERE e.owner = s.owner
   AND e.table_name = s.table_name
)
 ORDER BY s.owner, s.table_name;

if v_temp_stat_cnt > 0 then
  dbms_output.put_line('
Temporary Table That has been Gathered Statistics');
  dbms_output.put_line('======================');
  dbms_output.put_line('---------------------------------------------------------------------');
  dbms_output.put_line('| TABLE_OWNER      |' || ' TABLE_NAME                       ' || '|');
  dbms_output.put_line('---------------------------------------------------------------------');
  open c_temp;
    loop fetch c_temp into v_temp;
    exit when c_temp%notfound;
    dbms_output.put_line('| ' || rpad(v_temp.owner,16) || ' | ' || rpad(v_temp.table_name,32) || ' |');
    end loop;
    dbms_output.put_line('------------------------------------------------------------------');
  close c_temp;
else
  dbms_output.put_line('
There is No Temporary Table That has been Gathered Statistics for Current Owner');
  dbms_output.put_line('======================');
end if;

SELECT count(*) into v_cnt_expired_index_stats
  FROM dba_ind_statistics s,
       dba_indexes t
 WHERE s.OBJECT_TYPE = 'INDEX'
   AND s.owner = :owner
   AND (s.last_analyzed IS NULL or  s.stale_stats = 'YES' or s.last_analyzed < sysdate -7)
   AND s.table_name NOT LIKE 'BIN%'
   AND NOT (s.table_name LIKE '%TEMP' OR s.table_name LIKE '%_TEMP_%' )
   AND t.owner = s.owner
   AND t.index_name = s.INDEX_NAME
   AND t.table_name = s.table_name
   AND t.temporary = 'N'
   and t.index_type != 'LOB'
   AND NOT EXISTS (
SELECT NULL
  FROM dba_external_tables e
 WHERE e.owner = s.owner
   AND e.owner = :owner
   AND e.table_name = s.table_name
)
 ORDER BY
       s.owner, s.table_name;

if v_temp_stat_cnt > 0 then
  dbms_output.put_line('
Temporary Table That has been Gathered Statistics');
  dbms_output.put_line('======================');
  dbms_output.put_line('---------------------------------------------------------------------');
  dbms_output.put_line('| INDEX_NAME       |' || ' stale_stats    ' || '| LAST_ANALYZED  ' ||'|');
  dbms_output.put_line('---------------------------------------------------------------------');
  open c_expire_index_stats;
    loop fetch c_expire_index_stats into v_expire_index_stats;
    exit when c_expire_index_stats%notfound;
    dbms_output.put_line('| ' || rpad(v_expire_index_stats.index_name,16) || ' | ' || rpad(v_expire_index_stats.stale_stats,14) || ' | ' || rpad(v_expire_index_stats.last_analyzed,19)||' |');
    end loop;
    dbms_output.put_line('------------------------------------------------------------------');
  close c_expire_index_stats;
else
  dbms_output.put_line('
There is No Expired Index Stats for Current Owner');
  dbms_output.put_line('======================');
end if;
end;
/
    $ECHO
    spool off
!

  exit 0
fi

#####################################################################################################
if [ "$1" = "source" ]; then

    if [ "$2" = "" ]; then
       echo "ora source <keyword to find in dba_source>"
    fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 1000
    col owner for a20 trunc
    col name for a30
    col line head LINE# for 999999
    col text for a100 trunc
    col type format a15

    select owner, name,type, line, text from dba_source where lower(text) like lower('%$2%') order by owner,name,type, line;
    $ECHO

!
  exit 0
fi
#####################################################################################################
if [ "$1" = "x" ]; then

   if [ "$2" = "" ]; then
    echo "ora x <sql_id>"
    exit 1
   fi

  sqlid=$2
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 200 pagesize 600
    set tab      off
    col PARSING_SCHEMA_NAME for a16
    col plan_table format a180
    col snap_time for a12
    col inst# for 99999
    Pro Display sql execution plan in AWR:
    select * from table(dbms_xplan.display_awr('$sqlid',format=>'advanced -PROJECTION'));

    prompt Display current sql dba_his_sqlstat Information
    prompt =======================
    col parsing_schema for a16
    select  instance_number as inst#,
    (select max(to_char(begin_interval_time,'yymmdd hh24:mi')) time from dba_hist_snapshot where snap_id = x.snap_id) snap_time,
    plan_hash_value as plan_hash,
    OPTIMIZER_COST as opti_cost,
    PARSING_SCHEMA_NAME as parsing_schema,
    executions_delta "total_exec",
    trunc(ELAPSED_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "elapsed_ms/per",
    trunc(CPU_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "cpu_ms/per",
    trunc(IOWAIT_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "user_io_ms/per",
    trunc(rows_processed_delta/decode(executions_delta,0,1,executions_delta)) "rows/per",
    trunc(buffer_gets_delta/decode(executions_delta,0,1,executions_delta)) "gets/per",
    trunc(disk_reads_delta/decode(executions_delta,0,1,executions_delta)) "reads/per"
    from
    dba_hist_sqlstat x where x.SQL_ID = '$2' order by x.SNAP_ID;
    prompt =======================
    prompt !!! Also see ./ora awrsqrpt or (v\$sqlstats and v\$sql) for more Information...
    $ECHO
!
  exit 0
fi

########################################################################################
if [ "$1" = "xp" ]; then

  if [ "$2" = "" ]; then
    echo  "ora xp <sql_id in mem>"
    exit 1
  fi

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 200
    set tab      off
    set linesize 350
    col PARSING_SCHEMA for a16
    col inst# for 99999
    set echo off
    repfooter off;
    col snap_time for a12
    Pro Display sql execution plan in Cursor (memory) :
    select * from table(dbms_xplan.display_cursor('$2', null, 'advanced -bytes -PROJECTION allstats last'));

    prompt Display current sql dba_his_sqlstat Information
    prompt =======================
    col parsing_schema for a16
    select  instance_number as inst#,
    (select max(to_char(begin_interval_time,'yymmdd hh24:mi')) time from dba_hist_snapshot where snap_id = x.snap_id) snap_time,
    plan_hash_value as hash_value,
    OPTIMIZER_COST as opti_cost,
    PARSING_SCHEMA_NAME as PARSING_SCHEMA,
    executions_delta "total_exec",
    trunc(ELAPSED_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "elapsed_ms/per",
    trunc(CPU_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "cpu_ms/per",
    trunc(IOWAIT_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "user_io_ms/per",
    trunc(rows_processed_delta/decode(executions_delta,0,1,executions_delta)) "rows/per",
    trunc(buffer_gets_delta/decode(executions_delta,0,1,executions_delta)) "gets/per",
    trunc(disk_reads_delta/decode(executions_delta,0,1,executions_delta)) "reads/per"
    from
    dba_hist_sqlstat x where x.SQL_ID = '$2' order by x.SNAP_ID;
    prompt =======================
    prompt !!! Also see ./ora awrsqrpt or (v\$sqlstats and v\$sql) for more Information...
    $ECHO
!
exit 0

fi
########################################################################################
if [ "$1" = "xpo" ]; then

  if [ "$2" = "" ]; then
    echo  "ora xpo <sql_id> <child_number>"
    exit 1
  fi

    if [ "$3" = "" ]; then
      childno=0
    else
      childno=$3
    fi

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    col PARSING_SCHEMA_NAME for a16
    col inst# for 99999
    set verify off
    set define on
    --set linesize 150 pagesize 200
    define v_xc_version = 1.2

    -- Main Xplan SQL...
    -- -----------------
    set termout on lines 250 pages 200
    col plan_table_output format a200

    with sql_plan_data as (
            select  id, parent_id
            from    gv\$sql_plan
            where   inst_id = sys_context('userenv','instance')
            and     sql_id = '$2'
            and     child_number = $childno
            )
    ,    hierarchy_data as (
            select  id, parent_id
            from    sql_plan_data
            start   with id = 0
            connect by prior id = parent_id
            order   siblings by id desc
            )
    ,    ordered_hierarchy_data as (
            select id
            ,      parent_id as pid
            ,      row_number() over (order by rownum desc) as oid
            ,      max(id) over () as maxid
            from   hierarchy_data
            )
    ,    xplan_data as (
            select /*+ ordered use_nl(o) */
                   rownum as r
            ,      x.plan_table_output as plan_table_output
            ,      o.id
            ,      o.pid
            ,      o.oid
            ,      o.maxid
            ,      count(*) over () as rc
            from   table(dbms_xplan.display_cursor('$2',$childno,'advanced -PROJECTION allstats,last')) x
                   left outer join
                   ordered_hierarchy_data o
                   on (o.id = case
                                 when regexp_like(x.plan_table_output, '^\|[\* 0-9]+\|')
                                 then to_number(regexp_substr(x.plan_table_output, '[0-9]+'))
                              end)
            )
    select plan_table_output
    from   xplan_data
    model
       dimension by (rownum as r)
       measures (plan_table_output,
                 id,
                 maxid,
                 pid,
                 oid,
                 greatest(max(length(maxid)) over () + 3, 6) as csize,
                 cast(null as varchar2(128)) as inject,
                 rc)
       rules sequential order (
              inject[r] = case
                             when id[cv()+1] = 0
                             or   id[cv()+3] = 0
                             or   id[cv()-1] = maxid[cv()-1]
                             then rpad('-', csize[cv()]*2, '-')
                             when id[cv()+2] = 0
                             then '|' || lpad('Pid |', csize[cv()]) || lpad('Ord |', csize[cv()])
                             when id[cv()] is not null
                             then '|' || lpad(pid[cv()] || ' |', csize[cv()]) || lpad(oid[cv()] || ' |', csize[cv()])
                          end,
              plan_table_output[r] = case
                                        when inject[cv()] like '---%'
                                        then inject[cv()] || plan_table_output[cv()]
                                        when inject[cv()] is not null
                                        then regexp_replace(plan_table_output[cv()], '\|', inject[cv()], 1, 2)
                                        else plan_table_output[cv()]
                                     end ||
                                     case
                                        when cv(r) = rc[cv()]
                                        then  chr(10) ||
                                             'About'  || chr(10) ||
                                             '------' || chr(10) ||
                                             '  - XPlan v&v_xc_version by Adrian Billington (http://www.oracle-developer.net)'
                                     end
             )
    order by r;

    prompt Display current sql dba_his_sqlstat Information
    prompt =======================
    col snap_time for a12
    col PARSING_SCHEMA for a16
    select  instance_number as inst#,
    (select max(to_char(begin_interval_time,'yymmdd hh24:mi')) time from dba_hist_snapshot where snap_id = x.snap_id) snap_time,
    plan_hash_value as plan_hash,
    OPTIMIZER_COST as opti_cost,
    PARSING_SCHEMA_NAME as PARSING_SCHEMA,
    executions_delta "total_exec",
    trunc(ELAPSED_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "elapsed_ms/per",
    trunc(CPU_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "cpu_ms/per",
    trunc(IOWAIT_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "user_io_ms/per",
    trunc(rows_processed_delta/decode(executions_delta,0,1,executions_delta)) "rows/per",
    trunc(buffer_gets_delta/decode(executions_delta,0,1,executions_delta)) "gets/per",
    trunc(disk_reads_delta/decode(executions_delta,0,1,executions_delta)) "reads/per"
    from
    dba_hist_sqlstat x where x.SQL_ID = '$2' order by x.SNAP_ID;
    prompt =======================
    prompt !!! Also see ./ora awrsqrpt or (v\$sqlstats and v\$sql) for more Information...
    $ECHO
    pro sql child numbers:

    select distinct child_number,PLAN_HASH_VALUE from gv\$sql_plan where sql_id='$2';
!

exit 0
fi
#####################################################################################################

if [ "$1" = "xo" ]; then

   if [ "$2" = "" ]; then
    echo "ora xo <sql_id> [phv]"
    exit 1
   fi

   if [ "$3" = "" ]; then
     phv=null
   else
     phv=$3
   fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    set define on
    col PARSING_SCHEMA_NAME for a16
    col inst# for 99999
    set verify off

    define v_xa_version = 1.2

    -- Main Xplan SQL...
    -- -----------------
    set termout on lines 200 pages 1000
    col plan_table_output format a150

    with sql_plan_data as (
            select id, parent_id, plan_hash_value
            from   dba_hist_sql_plan
            where  sql_id = '$2'
            and    plan_hash_value = nvl($phv, plan_hash_value)
            and    dbid = (select dbid from v\$database)
            )
    ,    hierarchy_data as (
            select  id, parent_id, plan_hash_value
            from    sql_plan_data
            start   with id = 0
            connect by prior id = parent_id
                   and prior plan_hash_value = plan_hash_value
            order   siblings by id desc
            )
    ,    ordered_hierarchy_data as (
            select id
            ,      parent_id as pid
            ,      plan_hash_value as phv
            ,      row_number() over (partition by plan_hash_value order by rownum desc) as oid
            ,      max(id) over (partition by plan_hash_value) as maxid
            from   hierarchy_data
            )
    ,    xplan_data as (
            select /*+ ordered use_nl(o) */
                   rownum as r
            ,      x.plan_table_output as plan_table_output
            ,      o.id
            ,      o.pid
            ,      o.oid
            ,      o.maxid
            ,      p.phv
            ,      count(*) over () as rc
            from  (
                   select distinct phv
                   from   ordered_hierarchy_data
                  ) p
                   cross join
                   table(dbms_xplan.display_awr('$2',p.phv,format=>'advanced -PROJECTION')) x
                   left outer join
                   ordered_hierarchy_data o
                   on (    o.phv = p.phv
                       and o.id = case
                                     when regexp_like(x.plan_table_output, '^\|[\* 0-9]+\|')
                                     then to_number(regexp_substr(x.plan_table_output, '[0-9]+'))
                                  end)
            )
    select plan_table_output
    from   xplan_data
    model
       dimension by (phv, rownum as r)
       measures (plan_table_output,
                 id,
                 maxid,
                 pid,
                 oid,
                 greatest(max(length(maxid)) over () + 3, 6) as csize,
                 cast(null as varchar2(128)) as inject,
                 rc)
       rules sequential order (
              inject[phv,r] = case
                                 when id[cv(),cv()+1] = 0
                                 or   id[cv(),cv()+3] = 0
                                 or   id[cv(),cv()-1] = maxid[cv(),cv()-1]
                                 then rpad('-', csize[cv(),cv()]*2, '-')
                                 when id[cv(),cv()+2] = 0
                                 then '|' || lpad('Pid |', csize[cv(),cv()]) || lpad('Ord |', csize[cv(),cv()])
                                 when id[cv(),cv()] is not null
                                 then '|' || lpad(pid[cv(),cv()] || ' |', csize[cv(),cv()]) || lpad(oid[cv(),cv()] || ' |', csize[cv(),cv()])
                              end,
              plan_table_output[phv,r] = case
                                            when inject[cv(),cv()] like '---%'
                                            then inject[cv(),cv()] || plan_table_output[cv(),cv()]
                                            when inject[cv(),cv()] is not null
                                            then regexp_replace(plan_table_output[cv(),cv()], '\|', inject[cv(),cv()], 1, 2)
                                            else plan_table_output[cv(),cv()]
                                         end ||
                                         case
                                            when cv(r) = rc[cv(),cv()]
                                            then chr(10)  ||
                                                 'About'  || chr(10) ||
                                                 '------' || chr(10) ||
                                                 '  - XPlan v&v_xa_version by Adrian Billington (http://www.oracle-developer.net)'
                                         end
             )
    order by r;

    prompt Display current sql dba_his_sqlstat Information
    prompt =======================
    col snap_time for a12
    col PARSING_SCHEMA for a16
    select  instance_number as inst#,
    (select max(to_char(begin_interval_time,'yymmdd hh24:mi')) time from dba_hist_snapshot where snap_id = x.snap_id) snap_time,
    plan_hash_value as plan_hash,
    OPTIMIZER_COST as opti_cost,
    PARSING_SCHEMA_NAME as PARSING_SCHEMA,
    executions_delta "total_exec",
    trunc(ELAPSED_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "elapsed_ms/per",
    trunc(CPU_TIME_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "cpu_ms/per",
    trunc(IOWAIT_DELTA/decode(executions_delta,0,1,executions_delta)/1000) "user_io_ms/per",
    trunc(rows_processed_delta/decode(executions_delta,0,1,executions_delta)) "rows/per",
    trunc(buffer_gets_delta/decode(executions_delta,0,1,executions_delta)) "gets/per",
    trunc(disk_reads_delta/decode(executions_delta,0,1,executions_delta)) "reads/per"
    from
    dba_hist_sqlstat x where x.SQL_ID = '$2' order by x.SNAP_ID;
    prompt =======================
    prompt !!! Also see ./ora awrsqrpt or (v\$sqlstats and v\$sql) for more Information...
    $ECHO
!
  exit 0
fi

####################################################################################################

if [ "$1" = "tbsinc" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set linesize 250 pagesize 100
    set tab      off
    with max_ts_by_day as
    (
     select to_char(to_date(substr(rtime,1,10),'mm/dd/yyyy'),'yyyy-mm-dd hh24:mi') as rday,tablespace_id
            ,max(tablespace_usedsize) as used_blocks
     from dba_hist_tbspc_space_usage
    group by to_char(to_date(substr(rtime,1,10),'mm/dd/yyyy'),'yyyy-mm-dd hh24:mi'),tablespace_id
    )
    select rday,round(sum(used_blocks)*8/1024/1024) as total_size_g from max_ts_by_day
    group by rday
    order by 1;
    $ECHO

!
  exit 0
fi

########################################################################################
if [ "$1" = "offload" ]; then

  if [ "$2" = "" ]; then
    echo  "ora offload <sql_id>"
    exit 1
  fi

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    spool ora_offload_$2_${filedate}.log
    prompt ####################################################################
    prompt Display Exadata SQL Offloading Information
    prompt ####################################################################
    set linesize 300
    col ksppinm for a35
    col ksppstvl for a12
    col ksppdesc for a70
    select ksppinm,
           ksppstvl,
           ksppdesc
      from x\$ksppi x, x\$ksppcv y
      where x.indx = y.indx
      and ksppinm in ('_kcfis_storageidx_diag_mode',
                      '__db_cache_size',
                      '_small_table_threshold',
                      '_kcfis_storageidx_disabled',
                      '_serial_direct_read',
                      '_very_large_object_threshold');

    prompt display the io save throught out smart scan
    prompt IO_CELL_OFFLOAD_ELIGIBLE_GB means saved data GB
    prompt IO_INTERCONNECT_GB means returned data GB

    set linesize 500
    col offload for a10
    SELECT
    SQL_ID,
    CHILD_NUMBER CHILD,
    round(IO_CELL_OFFLOAD_ELIGIBLE_BYTES/1024/1024/1024,2) as  IO_CELL_OFFLOAD_ELIGIBLE_GB,
    round(IO_INTERCONNECT_BYTES/1024/1024/1024,2) IO_INTERCONNECT_GB,
    round(PHYSICAL_READ_BYTES/1024/1024/1024,2) PHYSICAL_READ_GB,
    round(PHYSICAL_WRITE_BYTES/1024/1024/1024,2) PHYSICAL_WRITE_GB,
    DECODE(IO_CELL_OFFLOAD_ELIGIBLE_BYTES, 0, 'No', 'Yes') OFFLOAD,
    round(decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,0,100 * (IO_CELL_OFFLOAD_ELIGIBLE_BYTES - IO_INTERCONNECT_BYTES) / decode(IO_CELL_OFFLOAD_ELIGIBLE_BYTES,0,1,IO_CELL_OFFLOAD_ELIGIBLE_BYTES))) "IO_SAVED_%",
    (ELAPSED_TIME / 1000000) / DECODE(NVL(EXECUTIONS, 0), 0, 1, EXECUTIONS) AVG_ETIME
    FROM v\$sql S WHERE SQL_ID ='$2'
    ORDER BY 1, 2, 3;

    col event for a36
    col NAME for a66
    col username for a15
    select c.username,
    b.name,
    round(a.value/1024/1024/1024,2) GB,
    c.event
    FROM v\$sesstat a,v\$statname b,v\$session c
    WHERE a.STATISTIC# = b.STATISTIC#
    AND c.sql_id = '$2'
    AND a.sid = c.sid
    AND b.NAME IN ('cell physical IO bytes saved by storage index',
    'cell physical IO bytes eligible for predicate offload',
    'cell physical IO interconnect bytes',
    'cell physical IO interconnect bytes returned by smart scan');
    spool off
    $ECHO
!
exit 0
fi

########################################################################################
if [ "$1" = "app" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
    col SEQUENCE_OWNER for a20
    col SEQUENCE_NAME for a32
    set linesize 220
    set pages 100
    spool ora_app_${filedate}.log
    prompt Show The Sequence That No Cache...
    SELECT s.SEQUENCE_OWNER,SEQUENCE_NAME,CACHE_SIZE from dba_sequences s
    where s.sequence_owner not in ('ANONYMOUS','APEX_030200','APEX_040000','APEX_040200','DVSYS','LBACSYS','OJVMSYS','APEX_SSO','APPQOSSYS','CTXSYS','DBSNMP','DIP','EXFSYS','FLOWS_FILES','MDSYS','OLAPSYS','ORACLE_OCM','ORDDATA','ORDPLUGINS','ORDSYS','OUTLN','OWBSYS','SI_INFORMTN_SCHEMA','SQLTXADMIN','SQLTXPLAIN','SYS','SYSMAN','SYSTEM','TRCANLZR','WMSYS','XDB','XS$NULL','PERFSTAT','STDBYPERF')
    and s.max_value > 0
    and s.CACHE_SIZE < 100;

    prompt Show the procedures that are cached in the library cache...
    col owner for a15
    col name for a30
    col type for a20
    select owner,name,type,executions,pins,locks from gv\$db_object_cache where locks > 0 and pins > 0 and type='PROCEDURE';

    with t1 as( select time_dp ,
                       24*60*60*(time_dp - lag(time_dp) over (order by time_dp)) timediff,
                      scn - lag(scn) over(order by time_dp) scndiff
                      from smon_scn_time)
    select to_char(time_dp,'yyyymmdd hh24:mi:ss') as time_dp,
           timediff,
           scndiff,
           trunc(scndiff/timediff) rate_per_sec from t1 order by 1;

    prompt scn rate
    set pages 200
    col first_change# format 99999999999999999999
    col next_change# format 99999999999999999999
    select thread#, first_time, next_time, first_change# ,next_change#, sequence#,
   next_change#-first_change# diff, round ((next_change#-first_change#)/(next_time-first_time)/24/60/60) rt
  from ( select thread#, first_time, first_change#,next_time,  next_change#, sequence#,dest_id from v\$archived_log
  where next_time > sysdate-30 and dest_id=1
  order by next_time
  )where first_time != next_time order by first_time, thread#;

    spool off
    $ECHO
!
exit 0
fi
###################################################################################################

if [ "$1" = "tbs" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER
  set linesize 200 pages 0 serveroutput on
  set feedback off verify off
  set trimspool on
  spool ora_tbs_${filedate}.log

declare
    cursor c_tbs is SELECT
    /*+
      BEGIN_OUTLINE_DATA
      IGNORE_OPTIM_EMBEDDED_HINTS
      ALL_ROWS
      OUTLINE_LEAF(@"SEL$3")
      OUTLINE_LEAF(@"SEL$4")
      OUTLINE_LEAF(@"SEL$5")
      OUTLINE_LEAF(@"SEL$6")
      OUTLINE_LEAF(@"SEL$7")
      OUTLINE_LEAF(@"SET$2")
      OUTLINE_LEAF(@"SEL$2")
      OUTLINE_LEAF(@"SEL$0DA12B55")
      MERGE(@"SEL$12" >"SEL$9")
      MERGE(@"SEL$285A8194" >"SEL$9")
      OUTLINE_LEAF(@"SEL$EFBFF88B")
      MERGE(@"SEL$16" >"SEL$13")
      MERGE(@"SEL$1FB6C052" >"SEL$13")
      OUTLINE_LEAF(@"SET$3")
      OUTLINE_LEAF(@"SEL$8")
      OUTLINE_LEAF(@"SEL$51244597")
      MERGE(@"SEL$17" >"SEL$1")
      OUTLINE_LEAF(@"SEL$45944B3D")
      MERGE(@"SEL$305E8794" >"SEL$20")
      OUTLINE_LEAF(@"SEL$E2343CD8")
      MERGE(@"SEL$27" >"SEL$24")
      MERGE(@"SEL$95423B40" >"SEL$24")
      OUTLINE_LEAF(@"SET$4")
      OUTLINE_LEAF(@"SEL$19")
      OUTLINE_LEAF(@"SEL$7B0606EA")
      MERGE(@"SEL$DB5DDC31" >"SEL$30")
      OUTLINE_LEAF(@"SEL$6BD15B31")
      MERGE(@"SEL$29" >"SEL$28")
      OUTLINE_LEAF(@"SEL$045839F6")
      MERGE(@"SEL$33" >"SEL$18")
      OUTLINE_LEAF(@"SET$1")
      OUTLINE(@"SEL$9")
      OUTLINE(@"SEL$12")
      OUTLINE(@"SEL$285A8194")
      MERGE(@"SEL$11" >"SEL$10")
      OUTLINE(@"SEL$13")
      OUTLINE(@"SEL$16")
      OUTLINE(@"SEL$1FB6C052")
      MERGE(@"SEL$15" >"SEL$14")
      OUTLINE(@"SEL$1")
      OUTLINE(@"SEL$17")
      OUTLINE(@"SEL$20")
      OUTLINE(@"SEL$305E8794")
      MERGE(@"SEL$00A1922E" >"SEL$21")
      OUTLINE(@"SEL$24")
      OUTLINE(@"SEL$27")
      OUTLINE(@"SEL$95423B40")
      MERGE(@"SEL$26" >"SEL$25")
      OUTLINE(@"SEL$30")
      OUTLINE(@"SEL$DB5DDC31")
      MERGE(@"SEL$32" >"SEL$31")
      OUTLINE(@"SEL$28")
      OUTLINE(@"SEL$29")
      OUTLINE(@"SEL$18")
      OUTLINE(@"SEL$33")
      OUTLINE(@"SEL$10")
      OUTLINE(@"SEL$11")
      OUTLINE(@"SEL$14")
      OUTLINE(@"SEL$15")
      OUTLINE(@"SEL$21")
      OUTLINE(@"SEL$00A1922E")
      MERGE(@"SEL$23" >"SEL$22")
      OUTLINE(@"SEL$25")
      OUTLINE(@"SEL$26")
      OUTLINE(@"SEL$31")
      OUTLINE(@"SEL$32")
      OUTLINE(@"SEL$22")
      OUTLINE(@"SEL$23")
      NO_ACCESS(@"SEL$045839F6" "B"@"SEL$18")
      NO_ACCESS(@"SEL$045839F6" "A"@"SEL$18")
      INDEX_RS_ASC(@"SEL$045839F6" "TS"@"SEL$33" ("TS$"."NAME"))
      INDEX(@"SEL$045839F6" "SVC"@"SEL$33" ("IMSVCTS$"."TS#"))
      FULL(@"SEL$045839F6" "TSATTR"@"SEL$33")
      LEADING(@"SEL$045839F6" "B"@"SEL$18" "A"@"SEL$18" "TS"@"SEL$33" "SVC"@"SEL$33" "TSATTR"@"SEL$33")
      USE_HASH(@"SEL$045839F6" "A"@"SEL$18")
      USE_NL(@"SEL$045839F6" "TS"@"SEL$33")
      USE_NL(@"SEL$045839F6" "SVC"@"SEL$33")
      USE_NL(@"SEL$045839F6" "TSATTR"@"SEL$33")
      NO_ACCESS(@"SEL$51244597" "A"@"SEL$1")
      NO_ACCESS(@"SEL$51244597" "B"@"SEL$1")
      FULL(@"SEL$51244597" "TS"@"SEL$17")
      INDEX(@"SEL$51244597" "SVC"@"SEL$17" ("IMSVCTS$"."TS#"))
      FULL(@"SEL$51244597" "TSATTR"@"SEL$17")
      LEADING(@"SEL$51244597" "A"@"SEL$1" "B"@"SEL$1" "TS"@"SEL$17" "SVC"@"SEL$17" "TSATTR"@"SEL$17")
      USE_HASH(@"SEL$51244597" "B"@"SEL$1")
      USE_HASH(@"SEL$51244597" "TS"@"SEL$17")
      USE_NL(@"SEL$51244597" "SVC"@"SEL$17")
      USE_NL(@"SEL$51244597" "TSATTR"@"SEL$17")
      NO_ACCESS(@"SEL$2" "DBA_FREE_SPACE"@"SEL$2")
      USE_HASH_AGGREGATION(@"SEL$2")
      NO_ACCESS(@"SEL$8" "DBA_DATA_FILES"@"SEL$8")
      USE_HASH_AGGREGATION(@"SEL$8")
      FULL(@"SEL$EFBFF88B" "X$KCCFN"@"SEL$15")
      FULL(@"SEL$EFBFF88B" "HC"@"SEL$13")
      FULL(@"SEL$EFBFF88B" "F"@"SEL$13")
      INDEX(@"SEL$EFBFF88B" "TS"@"SEL$13" "I_TS#")
      FULL(@"SEL$EFBFF88B" "X$KCCFE"@"SEL$16")
      LEADING(@"SEL$EFBFF88B" "X$KCCFN"@"SEL$15" "HC"@"SEL$13" "F"@"SEL$13" "TS"@"SEL$13" "X$KCCFE"@"SEL$16")
      USE_NL(@"SEL$EFBFF88B" "HC"@"SEL$13")
      USE_HASH(@"SEL$EFBFF88B" "F"@"SEL$13")
      USE_NL(@"SEL$EFBFF88B" "TS"@"SEL$13")
      USE_NL(@"SEL$EFBFF88B" "X$KCCFE"@"SEL$16")
      FULL(@"SEL$0DA12B55" "F"@"SEL$9")
      FULL(@"SEL$0DA12B55" "X$KCCFN"@"SEL$11")
      INDEX(@"SEL$0DA12B55" "TS"@"SEL$9" "I_TS#")
      FULL(@"SEL$0DA12B55" "X$KCCFE"@"SEL$12")
      LEADING(@"SEL$0DA12B55" "F"@"SEL$9" "X$KCCFN"@"SEL$11" "TS"@"SEL$9" "X$KCCFE"@"SEL$12")
      USE_HASH(@"SEL$0DA12B55" "X$KCCFN"@"SEL$11")
      USE_NL(@"SEL$0DA12B55" "TS"@"SEL$9")
      USE_NL(@"SEL$0DA12B55" "X$KCCFE"@"SEL$12")
      FULL(@"SEL$7" "F"@"SEL$7")
      INDEX(@"SEL$7" "TS"@"SEL$7" "I_TS#")
      INDEX(@"SEL$7" "FI"@"SEL$7" ("FILE$"."TS#" "FILE$"."RELFILE#"))
      LEADING(@"SEL$7" "F"@"SEL$7" "TS"@"SEL$7" "FI"@"SEL$7")
      USE_NL(@"SEL$7" "TS"@"SEL$7")
      USE_NL(@"SEL$7" "FI"@"SEL$7")
      FULL(@"SEL$6" "RB"@"SEL$6")
      INDEX(@"SEL$6" "FI"@"SEL$6" ("FILE$"."TS#" "FILE$"."RELFILE#"))
      INDEX(@"SEL$6" "U"@"SEL$6" "I_FILE#_BLOCK#")
      INDEX(@"SEL$6" "TS"@"SEL$6" "I_TS#")
      LEADING(@"SEL$6" "RB"@"SEL$6" "FI"@"SEL$6" "U"@"SEL$6" "TS"@"SEL$6")
      USE_MERGE_CARTESIAN(@"SEL$6" "FI"@"SEL$6")
      USE_NL(@"SEL$6" "U"@"SEL$6")
      USE_NL(@"SEL$6" "TS"@"SEL$6")
      INDEX(@"SEL$5" "FI"@"SEL$5" ("FILE$"."TS#" "FILE$"."RELFILE#"))
      INDEX_RS_ASC(@"SEL$5" "RB"@"SEL$5" ("RECYCLEBIN$"."TS#"))
      BATCH_TABLE_ACCESS_BY_ROWID(@"SEL$5" "RB"@"SEL$5")
      INDEX(@"SEL$5" "TS"@"SEL$5" "I_TS#")
      FULL(@"SEL$5" "U"@"SEL$5")
      LEADING(@"SEL$5" "FI"@"SEL$5" "RB"@"SEL$5" "TS"@"SEL$5" "U"@"SEL$5")
      USE_NL(@"SEL$5" "RB"@"SEL$5")
      USE_NL(@"SEL$5" "TS"@"SEL$5")
      USE_NL(@"SEL$5" "U"@"SEL$5")
      FULL(@"SEL$4" "TS"@"SEL$4")
      FULL(@"SEL$4" "F"@"SEL$4")
      INDEX(@"SEL$4" "FI"@"SEL$4" ("FILE$"."TS#" "FILE$"."RELFILE#"))
      LEADING(@"SEL$4" "TS"@"SEL$4" "F"@"SEL$4" "FI"@"SEL$4")
      USE_NL(@"SEL$4" "F"@"SEL$4")
      USE_NL(@"SEL$4" "FI"@"SEL$4")
      INDEX(@"SEL$3" "FI"@"SEL$3" ("FILE$"."TS#" "FILE$"."RELFILE#"))
      INDEX(@"SEL$3" "F"@"SEL$3" "I_TS#")
      INDEX(@"SEL$3" "TS"@"SEL$3" "I_TS#")
      LEADING(@"SEL$3" "FI"@"SEL$3" "F"@"SEL$3" "TS"@"SEL$3")
      USE_NL(@"SEL$3" "F"@"SEL$3")
      USE_NL(@"SEL$3" "TS"@"SEL$3")
      NO_ACCESS(@"SEL$19" "DBA_TEMP_FILES"@"SEL$19")
      USE_HASH_AGGREGATION(@"SEL$19")
      FULL(@"SEL$6BD15B31" "TS"@"SEL$29")
      FULL(@"SEL$6BD15B31" "FC"@"SEL$29")
      LEADING(@"SEL$6BD15B31" "TS"@"SEL$29" "FC"@"SEL$29")
      USE_NL(@"SEL$6BD15B31" "FC"@"SEL$29")
      USE_HASH_AGGREGATION(@"SEL$6BD15B31")
      FULL(@"SEL$7B0606EA" "X"@"SEL$32")
      FULL(@"SEL$7B0606EA" "Y"@"SEL$32")
      LEADING(@"SEL$7B0606EA" "X"@"SEL$32" "Y"@"SEL$32")
      USE_HASH(@"SEL$7B0606EA" "Y"@"SEL$32")
      FULL(@"SEL$E2343CD8" "X$KCCTF"@"SEL$26")
      FULL(@"SEL$E2343CD8" "FN"@"SEL$25")
      FULL(@"SEL$E2343CD8" "FH"@"SEL$25")
      FULL(@"SEL$E2343CD8" "HC"@"SEL$25")
      FULL(@"SEL$E2343CD8" "KS"@"SEL$27")
      FULL(@"SEL$E2343CD8" "KV"@"SEL$27")
      FULL(@"SEL$E2343CD8" "QU"@"SEL$27")
      FULL(@"SEL$E2343CD8" "X$KJIDT"@"SEL$27")
      INDEX(@"SEL$E2343CD8" "TS"@"SEL$24" "I_TS#")
      LEADING(@"SEL$E2343CD8" "X$KCCTF"@"SEL$26" "FN"@"SEL$25" "FH"@"SEL$25" "HC"@"SEL$25" "KS"@"SEL$27" "KV"@"SEL$27" "QU"@"SEL$27" "X$KJIDT"@"SEL$27" "TS"@"SEL$24")
      USE_NL(@"SEL$E2343CD8" "FN"@"SEL$25")
      USE_NL(@"SEL$E2343CD8" "FH"@"SEL$25")
      USE_NL(@"SEL$E2343CD8" "HC"@"SEL$25")
      USE_HASH(@"SEL$E2343CD8" "KS"@"SEL$27")
      USE_MERGE_CARTESIAN(@"SEL$E2343CD8" "KV"@"SEL$27")
      USE_MERGE_CARTESIAN(@"SEL$E2343CD8" "QU"@"SEL$27")
      USE_MERGE_CARTESIAN(@"SEL$E2343CD8" "X$KJIDT"@"SEL$27")
      USE_NL(@"SEL$E2343CD8" "TS"@"SEL$24")
      FULL(@"SEL$45944B3D" "X$KCCTF"@"SEL$23")
      FULL(@"SEL$45944B3D" "FN"@"SEL$22")
      FULL(@"SEL$45944B3D" "FH"@"SEL$22")
      FULL(@"SEL$45944B3D" "HC"@"SEL$22")
      INDEX(@"SEL$45944B3D" "TS"@"SEL$20" "I_TS#")
      LEADING(@"SEL$45944B3D" "X$KCCTF"@"SEL$23" "FN"@"SEL$22" "FH"@"SEL$22" "HC"@"SEL$22" "TS"@"SEL$20")
      USE_NL(@"SEL$45944B3D" "FN"@"SEL$22")
      USE_NL(@"SEL$45944B3D" "FH"@"SEL$22")
      USE_NL(@"SEL$45944B3D" "HC"@"SEL$22")
      USE_NL(@"SEL$45944B3D" "TS"@"SEL$20")
      END_OUTLINE_DATA
  */
       a.tablespace_name,
       round((total-free) / maxsize * 100, 1) || '%' as used_pct,
       rpad(lpad('#',ceil((nvl(total-free,0)/b.maxsize)*20),'#'),20,' ') as used,
       b.autoextensible,
       round(total/1024,1) as TOTAL_GB,
       round((total - free)/1024,1) as USED_GB,
       round(free/1024,1) as FREE_GB,
       b.cnt DATAFILE_COUNT,
       c.status,
       c.CONTENTS,
       c.extent_management,
       c.allocation_type,
       b.maxsize
FROM   (SELECT tablespace_name,
               round(SUM(bytes) / ( 1024 * 1024 ), 1) free
        FROM   dba_free_space
        GROUP BY tablespace_name) a,
       (SELECT tablespace_name,
               round(SUM(bytes) / ( 1024 * 1024 ), 1) total,
               count(*)                               cnt,
               max(autoextensible)                  autoextensible,
               sum(decode(autoextensible, 'YES', floor(maxbytes/1048576), floor(bytes / 1048576 ))) maxsize
        FROM   dba_data_files
        GROUP  BY tablespace_name) b,
       dba_tablespaces c
WHERE  a.tablespace_name = b.tablespace_name
       AND a.tablespace_name = c.tablespace_name
UNION ALL
SELECT /*+ NO_MERGE */
  a.tablespace_name,
        round(100 * (b.tot_used_mb / a.maxsize ),1) || '%' as used_pct,
        rpad(lpad('#',ceil((nvl(b.tot_used_mb+0.001,0)/a.maxsize)*20),'#'),20,' ') as used,
        a.aet as autoextensible,
        round(a.avail_size_mb/1024,1) as TOTAL_GB,
        round(b.tot_used_mb/1024,1) as USED_GB,
        round((a.avail_size_mb - b.tot_used_mb)/1024,1) as FREE_GB,
        a.cnt DATAFILE_COUNT,
        c.status,
        c.CONTENTS,
        c.extent_management,
        c.allocation_type,
        a.maxsize
FROM   (SELECT tablespace_name,
               sum(bytes)/1024/1024 as avail_size_mb,
               max(autoextensible)       aet,
               count(*)                  cnt,
               sum(decode(autoextensible, 'YES', floor(maxbytes/1048576), floor(bytes/1048576))) maxsize
        FROM   dba_temp_files
        GROUP  BY tablespace_name) A,
       (SELECT tablespace_name,
               SUM(bytes_used) /1024/1024 as tot_used_mb
        FROM   gv\$temp_extent_pool
        GROUP  BY tablespace_name) B,
       dba_tablespaces c
WHERE  a.tablespace_name = b.tablespace_name
       AND a.tablespace_name = c.tablespace_name
order by 3 desc,2 desc;
     v_tbs c_tbs%rowtype;

begin
  dbms_output.enable(buffer_size => NULL);
  dbms_output.put_line('
FCNT Means DATAFILE_CNT
Used% Means PCT_USED%
AUTO? Means AUTOEXTEND
MANAGE? Means EXTENT_MANAGEMENT
Tablespace Used Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| TABLESPACE_NAME     |' || ' Used% ' || '|                 Used |' || ' AUTO? ' || '| TOTAL_GB |' || ' USED_GB ' || '| FREE_GB |' || ' FCNT ' || '| STATUS |' || '  CONTENTS ' || '| MANAGE? |' || ' MAXSIZE(MB) ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------------------------------------');
  open c_tbs;
    loop fetch c_tbs into v_tbs;
    exit when c_tbs%notfound;
    dbms_output.put_line('| ' || rpad(v_tbs.TABLESPACE_NAME,19) ||' | '|| lpad(v_tbs.used_pct,5) || ' | '|| rpad(v_tbs.used,20) || ' | '|| lpad(v_tbs.autoextensible,5) || ' | '|| lpad(v_tbs.TOTAL_GB,8) || ' | '|| lpad(v_tbs.USED_GB,7) || ' | '|| lpad(v_tbs.FREE_GB,7) || ' | '|| lpad(v_tbs.DATAFILE_COUNT,4) || ' | '|| lpad(v_tbs.STATUS,6) || ' | '|| lpad(v_tbs.CONTENTS,9) || ' | '||lpad(v_tbs.extent_management,7) ||' | ' || lpad(v_tbs.maxsize,12) || '|');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------------------------------------');
  close c_tbs;
end;
/

declare
    v_hwm_cnt number;
    v_sys_obj_cnt number;

    cursor c_recovery is SELECT decode(name,null,'None',name) as recovery_dest,
    round(space_limit/1024/1024) as space_limit_mb,
    decode(space_limit,0,0, round(100 * ((space_used - SPACE_RECLAIMABLE) / space_limit),2)) as used_pct
FROM v\$recovery_file_dest;
     v_recovery c_recovery%rowtype;

    cursor c_sys_obj is select owner,count(*) as cnt ,
                  round(sum(bytes/1024/1024)) as size_m
                  from dba_segments
                  where tablespace_name in ('SYSTEM','SYSAUX')
                     and owner not in ('SYS','SYSTEM','MDSYS','CTXSYS','OUTLN','OLAPSYS','DBSNMP','EXFSYS','ORDSYS','SYSMAN','XDB','ORDDATA','WMSYS','OJVMSYS','DVSYS','AUDSYS','GSMADMIN_INTERNAL','LBACSYS')
                  group by owner;
    v_sys_obj c_sys_obj%rowtype;

    cursor c_big_tab is select
    OWNER,SEGMENT_NAME,SIZE_MB,PARTITION_NAME from (select owner,nvl2(PARTITION_NAME,SEGMENT_NAME||'.'||PARTITION_NAME,SEGMENT_NAME) SEGMENT_NAME ,trunc(bytes/1024/1024) as SIZE_MB,decode(PARTITION_NAME,null,'None',PARTITION_NAME) as PARTITION_NAME
    from dba_segments where segment_type like 'TABLE%' and owner  not in ('OWBSYS','FLOWS_FILES','WMSYS','XDB','QMONITOR','OUTLN',
                            'ORDSYS','ORDDATA','OJVMSYS','MDSYS','LBACSYS','DVSYS','DBSNMP','APPQOSSYS','APEX_040200','AUDSYS',
                            'CTXSYS','APEX_030200','EXFSYS','OLAPSYS','SYSMAN','WH_SYNC','GSMADMIN_INTERNAL') order by bytes desc)
    where  rownum < 21;
    v_big_tab c_big_tab%rowtype;

    cursor c_big_lob is select OWNER,TABLE_NAME,COLUMN_NAME,SEGMENT_NAME,SIZE_MB from
    (select a.owner,b.table_name,b.column_name,a.SEGMENT_NAME ,trunc(a.bytes/1024/1024) as SIZE_MB from dba_segments a,dba_lobs b
    where a.segment_type like 'LOB%' and a.owner not in ('OWBSYS','FLOWS_FILES','WMSYS','XDB','QMONITOR','OUTLN',
                               'ORDSYS','ORDDATA','OJVMSYS','MDSYS','LBACSYS','DVSYS','DBSNMP','APPQOSSYS','APEX_040200','AUDSYS',
                               'CTXSYS','APEX_030200','EXFSYS','OLAPSYS','SYSMAN','WH_SYNC','GSMADMIN_INTERNAL') and a.SEGMENT_NAME=b.SEGMENT_NAME order by a.bytes desc) where  rownum < 11;
    v_big_lob c_big_lob%rowtype;

    cursor c_hwmall is select OWNER,TABLE_NAME,SEGMENT_TYPE,SEGMENT_MB,WASTE_PER from (
       SELECT OWNER,
       SEGMENT_NAME TABLE_NAME,
       SEGMENT_TYPE,
       round(BYTES/1024/1024,2) as SEGMENT_MB,
       GREATEST(ROUND(100 * (NVL(HWM - AVG_USED_BLOCKS, 0) /
                      GREATEST(NVL(HWM, 1), 1)),
                      2),
                0) WASTE_PER
  FROM (SELECT A.OWNER OWNER,
               A.SEGMENT_NAME,
               A.SEGMENT_TYPE,
               B.LAST_ANALYZED,
               A.BYTES,
               B.NUM_ROWS,
               A.BLOCKS BLOCKS,
               B.EMPTY_BLOCKS EMPTY_BLOCKS,
               A.BLOCKS - B.EMPTY_BLOCKS - 1 HWM,
               DECODE(ROUND((B.AVG_ROW_LEN * NUM_ROWS * (1 + (PCT_FREE / 100))) / C.BLOCKSIZE,0),0,1,
                      ROUND((B.AVG_ROW_LEN * NUM_ROWS * (1 + (PCT_FREE / 100))) / C.BLOCKSIZE,0)) + 2 AVG_USED_BLOCKS,
               ROUND(100 * (NVL(B.CHAIN_CNT, 0) / GREATEST(NVL(B.NUM_ROWS, 1), 1)), 2) CHAIN_PER,
               B.TABLESPACE_NAME O_TABLESPACE_NAME
          FROM SYS.DBA_SEGMENTS A, SYS.DBA_TABLES B, SYS.TS\$ C
         WHERE A.OWNER = B.OWNER
           AND SEGMENT_NAME = TABLE_NAME
           AND SEGMENT_TYPE = 'TABLE'
           AND B.TABLESPACE_NAME = C.NAME)
 WHERE GREATEST(ROUND(100 * (NVL(HWM - AVG_USED_BLOCKS, 0) / GREATEST(NVL(HWM, 1), 1)), 2), 0) > 50
   AND OWNER  not in ('OWBSYS','SYS','FLOWS_FILES','WMSYS','XDB','QMONITOR','OUTLN',
                               'ORDSYS','ORDDATA','OJVMSYS','MDSYS','LBACSYS','DVSYS','DBSNMP','APPQOSSYS','APEX_040200','AUDSYS',
                               'CTXSYS','APEX_030200','EXFSYS','OLAPSYS','SYSMAN','WH_SYNC','GSMADMIN_INTERNAL')
   AND BLOCKS > 100
 ORDER BY WASTE_PER DESC) where rownum < 21;
    v_hwmall c_hwmall%rowtype;

begin
  dbms_output.enable(buffer_size => NULL);
    select count(*) into v_sys_obj_cnt from dba_segments
                  where tablespace_name in ('SYSTEM','SYSAUX')
                  and owner not in ('SYS','SYSTEM','MDSYS','CTXSYS','OUTLN','OLAPSYS','DBSNMP','EXFSYS','ORDSYS','SYSMAN','XDB','ORDDATA','WMSYS','OJVMSYS','DVSYS','AUDSYS','GSMADMIN_INTERNAL','LBACSYS');

  select count(*) into v_hwm_cnt FROM (SELECT A.OWNER OWNER,
               A.SEGMENT_NAME,
               A.SEGMENT_TYPE,
               B.LAST_ANALYZED,
               A.BYTES,
               B.NUM_ROWS,
               A.BLOCKS BLOCKS,
               B.EMPTY_BLOCKS EMPTY_BLOCKS,
               A.BLOCKS - B.EMPTY_BLOCKS - 1 HWM,
               DECODE(ROUND((B.AVG_ROW_LEN * NUM_ROWS * (1 + (PCT_FREE / 100))) / C.BLOCKSIZE,0),0,1,
                      ROUND((B.AVG_ROW_LEN * NUM_ROWS * (1 + (PCT_FREE / 100))) / C.BLOCKSIZE,0)) + 2 AVG_USED_BLOCKS,
               ROUND(100 * (NVL(B.CHAIN_CNT, 0) / GREATEST(NVL(B.NUM_ROWS, 1), 1)), 2) CHAIN_PER,
               B.TABLESPACE_NAME O_TABLESPACE_NAME
          FROM SYS.DBA_SEGMENTS A, SYS.DBA_TABLES B, SYS.TS\$ C
         WHERE A.OWNER = B.OWNER
           AND SEGMENT_NAME = TABLE_NAME
           AND SEGMENT_TYPE = 'TABLE'
           AND B.TABLESPACE_NAME = C.NAME)
 WHERE GREATEST(ROUND(100 * (NVL(HWM - AVG_USED_BLOCKS, 0) / GREATEST(NVL(HWM, 1), 1)), 2), 0) > 50
   AND OWNER  not in ('OWBSYS','SYS','FLOWS_FILES','WMSYS','XDB','QMONITOR','OUTLN',
                               'ORDSYS','ORDDATA','OJVMSYS','MDSYS','LBACSYS','DVSYS','DBSNMP','APPQOSSYS','APEX_040200','AUDSYS',
                               'CTXSYS','APEX_030200','EXFSYS','OLAPSYS','SYSMAN','WH_SYNC','GSMADMIN_INTERNAL')
   AND BLOCKS > 100;

  dbms_output.put_line('
Fast Recovery Dest Information');
  dbms_output.put_line('======================');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| RECOVERY_DEST                                                                                |' || ' Used_Pct% ' || '| TOTAL_SPACE_MB ' || '|');
  dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------');
  open c_recovery;
    loop fetch c_recovery into v_recovery;
    exit when c_recovery%notfound;
    dbms_output.put_line('| ' || rpad(v_recovery.recovery_dest,92) ||' | '|| lpad(v_recovery.used_pct,9) || ' | ' || lpad(v_recovery.space_limit_mb,14) || ' |');
    end loop;
    dbms_output.put_line('-----------------------------------------------------------------------------------------------------------------------------');
  close c_recovery;

if v_sys_obj_cnt > 0 then
    dbms_output.put_line('
Non sys user objects stored in SYS tablespace');
    dbms_output.put_line('======================');
  dbms_output.put_line('------------------------------------------------');
  dbms_output.put_line('| OWNER                |'|| ' CNT      |' || ' SIZE_MB    ' || '|');
  dbms_output.put_line('------------------------------------------------');
  open c_sys_obj;
    loop fetch c_sys_obj into v_sys_obj;
    exit when c_sys_obj%notfound;
    dbms_output.put_line('| ' || rpad(v_sys_obj.owner,20) ||' | '|| lpad(v_sys_obj.cnt,8) || ' | ' || lpad(v_sys_obj.size_m,10) || ' |');
    end loop;
    dbms_output.put_line('------------------------------------------------');
  close c_sys_obj;
end if;

  dbms_output.put_line('
Top 20 Big Table Information in The Database');
  dbms_output.put_line('======================');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER            |' || ' SEGMENT_NAME                     ' || '|   SIZE(MB) ' || '| PARTITION_NAME                ' ||'|');
  dbms_output.put_line('----------------------------------------------------------------------------------------------------');
  open c_big_tab;
    loop fetch c_big_tab into v_big_tab;
    exit when c_big_tab%notfound;
    dbms_output.put_line('| ' || rpad(v_big_tab.OWNER,16) ||' | '|| rpad(v_big_tab.SEGMENT_NAME,32) || ' | '|| lpad(v_big_tab.SIZE_MB,10) || ' | ' || rpad(v_big_tab.PARTITION_NAME,30)|| '|');
    end loop;
    dbms_output.put_line('----------------------------------------------------------------------------------------------------');
  close c_big_tab;

  dbms_output.put_line('
Top 20 Big LOB Information in The Database (When Migrating Database,<purge dba_recyclebin;> can purge unnecessary LOB)');
  dbms_output.put_line('======================');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER            |' || ' TABLE_NAME                ' || '| COLUMN_NAME          |' || ' SEGMENT_NAME                   ' || '| SIZE(MB) ' || '|');
  dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  open c_big_lob;
    loop fetch c_big_lob into v_big_lob;
    exit when c_big_lob%notfound;
    dbms_output.put_line('| ' || rpad(v_big_lob.OWNER,16) ||' | '|| rpad(v_big_lob.TABLE_NAME,25) || ' | '|| rpad(v_big_lob.COLUMN_NAME,20) ||  ' | '|| rpad(v_big_lob.SEGMENT_NAME,30) ||  ' | '|| lpad(v_big_lob.SIZE_MB,9) ||'|');
    end loop;
    dbms_output.put_line('-------------------------------------------------------------------------------------------------------------------');
  close c_big_lob;

if v_hwm_cnt > 0 then
  dbms_output.put_line('
HWM Information Rely on Table Statistics');
  dbms_output.put_line('======================');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  dbms_output.put_line('| OWNER                 |' || ' TABLE_NAME                       |' || ' SEGMENT_TYPE   ' || '| SEGMENT_MB     |' || ' WASTER% ' || '|');
  dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  open c_hwmall;
    loop fetch c_hwmall into v_hwmall;
    exit when c_hwmall%notfound;
    dbms_output.put_line('| ' || rpad(v_hwmall.owner,21) || ' | ' || rpad(v_hwmall.TABLE_NAME,32) ||' | '|| rpad(v_hwmall.SEGMENT_TYPE,14) || ' | ' || lpad(v_hwmall.SEGMENT_MB,14) || ' | ' || lpad(v_hwmall.WASTE_PER || '%',7) || ' |');
    end loop;
    dbms_output.put_line('--------------------------------------------------------------------------------------------------------');
  close c_hwmall;
end if;
end;
/
    spool off
!
  exit 0
fi

######################################active####################################
if [ "$1" = "active" ]; then
  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

  set linesize 200 pagesize 20
  col username for a10
  col spid for a6
  col sid_and_serial# for a15
  col terminal for a15
  col event for a26
  col machine for a25
  col program for a20
  col sql_text for a30
  col sql_id for a13
  col logon_time for a10
  col kill_sql for a60
  set trimspool on
  spool ora_active_$filedate.log
--当前数据库中的session信息与session中正在执行的SQL语句

prompt Display Avg and Max Connections of All Nodes since Instance Startup
prompt =======================
  col RESOURCE_NAME for a13
  col INITIAL_ALLOCATION for a18
  col LIMIT_VALUE for a11

select RESOURCE_NAME,
       CURRENT_UTILIZATION,
       MAX_UTILIZATION,
       INITIAL_ALLOCATION,
       LIMIT_VALUE
from v\$resource_limit
where RESOURCE_NAME in ('processes', 'sessions');

col program for a30
col SECONDS for a7
col KILL_SQL for a56
col "P1 P2 P3" for a28
col logon_time for a10
col kill_sql for a60
prompt =======================
select /*+use_nl(a,b,c)*/         distinct a.sid || ',' || a.serial# as sid_and_serial#,
                                  a.username,
                                  a.terminal,
                                  a.machine,
                                  a.program,
                                  b.spid,
                                  c.sql_id,
                                  substr(c.sql_text, 0, 30) as sql_text
from v\$session a,
     v\$process b,
     v\$sql c
where a.paddr = b.addr(+)
  and a.sql_hash_value = c.hash_value
  and a.sql_address = c.address
  and a.status = 'ACTIVE'
  and a.type = 'USER'
  and a.sid not in (select sid from v\$mystat where rownum = 1);

--正在执行的SQL语句的等待事件信息
prompt display the active sessions and events in current node
col SECONDS for a7
col KILL_SQL for a56
col "P1 P2 P3" for a18
col logon_time for a10
col kill_sql for a60
prompt =======================
select /*+ ordered use_nl(a,b) */
    trim(to_char(a.sql_id))                                                              as sql_id,
    b.spid                                                                               as spid,
    substr(c.event, 1, 25)                                                               as event,
    c.p1 || ',' || c.p2 || ',' || c.p3                                                   as "P1 P2 P3",
    to_char(LAST_CALL_ET)                                                                as seconds,
    to_char(a.logon_time, 'mmdd hh24:mi')                                                as logon_time,
    'alter system disconnect session ''' || a.sid || ',' || a.SERIAL# || ''' immediate;' as kill_sql
from v\$session a,
     v\$process b,
     v\$session_wait c
where a.type = 'USER'
  and a.status = 'ACTIVE'
  and a.paddr = b.addr
  and a.sid = c.sid
  and a.wait_class <> 'Idle'
  and a.sid not in (select sid from v\$mystat where rownum = 1)
order by LAST_CALL_ET desc;

prompt display all status of all sessions
prompt =======================
col program for a50
select inst_id, status,username,count(*) from gv\$session where type<>'BACKGROUND'
group by inst_id,status,username order by 1,2,4 desc;

prompt display the session status that not active in current node
prompt =======================
col SECONDS for a10
select /*+ ordered use_nl(a,b) */
    trim(to_char(a.sql_id))            as sql_id,
    a.sid                              as sid,
    b.spid                             as spid,
    substr(c.event, 1, 25)             as event,
    c.p1 || ',' || c.p2 || ',' || c.p3 as "P1 P2 P3",
    to_char(LAST_CALL_ET)              as seconds,
    a.logon_time
from v\$session a,
     v\$process b,
     v\$session_wait c
where a.type = 'USER'
  and a.status <> 'ACTIVE'
  and a.paddr = b.addr
  and a.sid = c.sid
  and a.wait_class <> 'Idle'
  and a.sid not in (select sid from v\$mystat where rownum = 1)
order by LAST_CALL_ET desc;

    $ECHO
    spool off
!
  exit 0
fi
##########################################################################

if [ "$1" = "binds" -o "$1" = "bind" -o "$1" = "bind_his" ]; then

  if [ "$2" = "" ]; then
    echo "ora binds <sql_id>"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 37
    set tab      off
    set linesize 220
    set echo off
    col sql_text format A75 WORD_WRAP
    repfooter off;
    col BIND_NAME format A15
    column VALUE_STRING format A40 wrap
    column CAPTURED format A10
    column LAST_CAPTURED format A20
    col sql_hash format A15
    col sql_id format A18
    col sql_text format A75 WORD_WRAP
    pro gv\$sql_bind_capture:
    select NAME BIND_NAME, POSITION POS, DATATYPE_STRING BIND_TYPE,
           WAS_CAPTURED CAPTURED,
           case
             when WAS_CAPTURED='YES' and LAST_CAPTURED is null
             then 'YES'
             else 'NO'
           end "Reverted",
           TO_CHAR(LAST_CAPTURED, 'HH:MI:SS (DD Mon)') LAST_CAPTURED,
           case datatype
           when 180 then to_char(anydata.accesstimestamp(value_anydata),'yyyy-mm-dd hh24:mi:ss')
             else value_string end as VALUE_STRING
           --VALUE_STRING
    from  gv\$sql_bind_capture
    where sql_id='$2';
    $ECHO

    set linesize 150 pagesize 37
    col name format a20
    col DATATYPE_STRING format a30
    col BIND_VALUE format a40
    col POSITION format 99
    pro dba_hist_sqlbind:

    SELECT snap_id,LAST_CAPTURED,NAME, P.POSITION, P.DATATYPE_STRING,
    case datatype
    when 180 then to_char(anydata.accesstimestamp(value_anydata),'yyyy-mm-dd hh24:mi:ss')
             else value_string end as bind_value
    from dba_hist_sqlbind p
    where SQL_ID = '$2' and snap_id >=(select max(snap_id)-10 from dba_hist_snapshot)
    and was_captured='YES'
    order by snap_id,LAST_CAPTURED,name;
    $ECHO

!
echo "get sql binds in gv\$sql_bind_capture and dba_hist_sqlbind(recent 10 snapshots)"
exit 0
fi

################################################################################
if [ "$1" = "seg" -o "$1" = "segment" ]; then

  if [ "$2" = "" ]; then
    echo "ora seg segment_name"
    exit 1
  fi

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"
    connect $DBUSER

    set pagesize 30
    set linesize 150
    col owner format a15 trunc
    col tablespace_name format a20 trunc
    col SEGMENT_NAME format a30
    col partition_name format a20
    Pro Segment info of $2 :
    select owner,segment_name,partition_name,segment_type,tablespace_name
          , round(bytes/(1024*1024)) Size_MB
    from dba_segments where segment_name=upper('$2')
    order by 1,2,3;
    $ECHO

!
 echo "ora seg <seg_name>"
exit 0
fi
#######################################################################################################

if [ "$1" = "stat" -o "$1" = "optstats" ]; then

    sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    Prompt "Top 50 DBA_OPTSTAT_OPERATIONS: top 30"
    set linesize 200 pagesize 100
    col OPERATION format a30
    col target format a30 trunc
    col start_time format a20
    col SAVTIME format a20
    set trimspool on
    spool ora_stats_$filedate.log

    select * from
    (
    select operation,target,to_char(start_time,'yyyy-mm-dd hh24:mi:ss') as start_time,
    extract( day from (end_time-start_time)) *24*60+
    extract( hour from (end_time-start_time)) *60+
    extract( minute from (end_time-start_time)) as duration_Min
    from DBA_OPTSTAT_OPERATIONS
    where (target not like 'SYS.%' or target is null)--and operation like '%auto%'
    order by start_time desc
    )
    where rownum<=30;
    $ECHO

    Prompt All Stale Tables not locked ,last_analyzed range (group by owner):
    col owner format a20 trunc
    col table_name format a20 trunc
    col LAST_ANALYZED format a20

    select owner,to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') as cur_time,
        sum(case when ceil(sysdate-LAST_ANALYZED)<=1 then 1 end) days_1,
        sum(case when ceil(sysdate-LAST_ANALYZED)>1  and ceil(sysdate-LAST_ANALYZED)<=10 then 1 end) days_1_10,
        sum(case when ceil(sysdate-LAST_ANALYZED)>10 and ceil(sysdate-LAST_ANALYZED)<=30 then 1 end) days_10_30,
        sum(case when ceil(sysdate-LAST_ANALYZED)>30 then 1 end) days_30
    from dba_tab_statistics
    where STALE_STATS='YES' AND stattype_locked not IN ('ALL', 'DATA')
    group by owner;
    $ECHO

    Prompt Table Stats locked (no sys created uses) top 50:
    select * from
    (
    select owner,table_name,object_type,stattype_locked,num_rows,STALE_STATS as stale
          ,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed
    from   dba_tab_statistics t
    WHERE t.stattype_locked IN ('ALL', 'DATA')
         and owner not in ('SQLTXPLAIN','SYS','SYSTEM','PUBLIC','XDB','WMSYS','SYSMAN','ORDSYS','CTXSYS','MDSYS','OLAPSYS','EXFSYS','RMAN','ORDDATA')
         --and STALE_STATS
    order by last_analyzed
    )
    where rownum<=50;
    $ECHO

    pro Num_rows=0 and Stale=Y / LAST_ANALYZED is null (maybe no segment /new create) (sample 50):
    col partition_name format a15 trunc
    select a.owner,a.table_name,object_type,a.partition_name,stattype_locked,stale_stats
          ,to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') last_analyzed,num_rows,blocks--,bytes
    from dba_tab_statistics a--,dba_segments b
    where a.object_type='TABLE' and
       (LAST_ANALYZED is null or (num_rows=0 and STALE_STATS='YES'))
     --and (a.table_name=b.segment_name(+)  and a.owner=b.owner(+) and b.segment_type(+)='TABLE')
     and table_name not in (select table_name from dba_tables where temporary='Y')
     and a.owner not in ('SQLTXPLAIN','SYS','SYSTEM','PUBLIC','XDB','WMSYS','SYSMAN','ORDSYS','CTXSYS','MDSYS','OLAPSYS','EXFSYS','RMAN','ORDDATA')
     and rownum<=50;
     $ECHO
    --order by 1,2;

    prompt Stale tables(no sys users)  top 50:
    col owner format a15 trunc
    col table_name format a20 trunc
    col partition_name format a8 trunc
    col subpartition_name format a8 trunc
    col RUN_TIME format a20
    select * from
    (
        select a.owner,a.table_name,a.partition_name,a.SUBPARTITION_NAME,num_rows,a.blocks ,b.blocks as real_blocks,
        to_char(last_analyzed,'yyyy-mm-dd hh24:mi:ss') as last_analyzed,
        to_char(sysdate,'yyyy-mm-dd hh24:mi:ss') as run_time,round((sysdate-LAST_ANALYZED),2) as stale_days
        ,stattype_locked
        from dba_tab_statistics a,dba_segments b
        where STALE_STATS='YES' --and (last_analyzed<sysdate-1)
        and a.owner not in ('SYS','SYSTEM','PUBLIC','XDB','WMSYS','SYSMAN','ORDSYS','CTXSYS','MDSYS','OLAPSYS','EXFSYS','RMAN','ORDDATA')
        and a.owner not like 'APEX%'
        and (a.owner=b.owner(+) and a.table_name=b.segment_name(+) and b.segment_type(+)='TABLE')
        and sysdate-LAST_ANALYZED>1
        order by stale_days desc
    ) where rownum<=50;
    $ECHO

    Pro DBA_TAB_STAT_PREFS sample 20:
    col PREFERENCE_NAME format a30
    col PREFERENCE_VALUE format a70 trunc
    select * from DBA_TAB_STAT_PREFS where rownum<=20;
    $ECHO

     Pro Dba_Autotask_task:
     col auto_collect_status format a80
     select nvl((select client_name||' '||status as auto_collect_status from Dba_Autotask_task
     where client_name='auto optimizer stats collection'),'Auto stats collection task not ENABLED!!!') as auto_collect_status
     from dual;
     $ECHO

     Pro dba_autotask_client:
     col CLIENT_NAME format a50
    select client_name,status
    from dba_autotask_client
    where client_name='auto optimizer stats collection';
    $ECHO

    Pro table with long Stats colleciton top 20:
    col object_name format a30
    col temporary format a10
    select * from
     (select * from
        (select a.owner,object_name,obj#,temporary
               ,to_char(lag(savtime) over ( order by savtime),'yyyy-mm-dd hh24:mi:ss') as start_time
               , to_char(savtime,'yyyy-mm-dd hh24:mi:ss') as savtime
               ,round((cast(savtime as date) - cast(lag(savtime) over ( order by savtime) as date))*24*60,2) as dur_min
               ,rowcnt,blkcnt
         from dba_objects a,sys.WRI\$_OPTSTAT_TAB_HISTORY b
        where a.object_id=b.obj#
        and savtime >=(select max(start_time) from DBA_OPTSTAT_OPERATIONS where operation='gather_database_stats(auto)')
        and savtime <=(select max( end_time ) from DBA_OPTSTAT_OPERATIONS where operation='gather_database_stats(auto)')
        ) --where dur_min>1
     order by dur_min desc
     )where rownum<=20  ;
     $ECHO
     spool off
!
exit 0
fi

####"ORA"####灵感来自渤海证券问题处理 ORA-00020: maximum number of processes (2000) exceeded###
if [ "$1" = "ORA" -o "$1" = "ora" ]; then
  if [ "$2" = "00020" -o "$2" = "20" ]; then
    echo "--------------------------------------------------------------------------------------------------"
    echo "|                      Run Follow Command to Kill The Oldest 10 Sessions !!!                     |"
    echo "--------------------------------------------------------------------------------------------------"
    echo "|  kill -9 \`ps -ef --sort=start_time|grep LOCAL=NO|grep -v grep| head -n 10 | awk '{print \$2}'\`  |"
    echo "--------------------------------------------------------------------------------------------------"
    echo "|    Usage: ./ora ORA <ErrorNumber>                                                              |"
    echo "--------------------------------------------------------------------------------------------------"

    exit 1
  fi
exit 1
fi

##################################################################################################

#
# Do pstack on all process
#
if [ "$1" = "pstack" ]; then
#be careful use "all" option
#ora pstack pid|all $DIR

  HOST_NAME=`uname -n`

  PID=$2
  shift 2

  if [ "$1" != "" ]; then
    DIR=$1
  else
    DIR=$T_TRC
  fi

  if [ ! -d $DIR ]; then
    echo "Directory $DIR does not exists"
  fi

  if [ "$ORACLE_SID" = "" ]; then
    echo "ORACLE_SID must be defined"
  fi

  if [ "$PID" = "all" ]; then
    ps -edf | egrep "ora_[a-z0-9]*_${ORACLE_SID}|oracle${ORACLE_SID}" | grep -v egrep | while read a; do
      set $a
      PID=$2
      TARGET_FILE="$DIR/pstack_${PID}_${HOST_NAME}.trc"
      echo >> $TARGET_FILE
      CURDATE=`date +"%T (%D)"`
      echo "######################## $CURDATE ########################" >> $TARGET_FILE
      pstack $PID >> $TARGET_FILE 2> /dev/null
      echo >> $TARGET_FILE
    done
    CURDATE=`date +"%T (%D)"`
    echo "pstack_all completed for all process at $CURDATE"
  else
    pstack $PID
    echo "pstack $PID complete"
  fi
  exit 0
fi

############################################################################################
#
# Get system state dump and place result in specified directory
#
if [ "$1" = "system_state" ]; then

  echo "may generate huge trc file , command commented!"

  sqlplus -s /NOLOG << ! | egrep -v "Session altered|Connected|rows selected"

    connect $DBUSER

    set pagesize 600
    set linesize 300
    set tab      off
    set linesize 140
    set echo off
    set long     4000

    --alter session set events 'immediate trace name systemstate level 266';

    select '##'||VALUE || '/${ORACLE_SID}_ora_'|| spid ||'.trc' file_name
    from v\$parameter, v\$process
    where name = 'user_dump_dest' and pid=userenv('pid');
!

  #echo "System state file $FILE successfully produced"
  exit 0
fi

##########################################################################################

if [ "$1" = "cursor_summary" -o "$1" = "pinned_cursors" ]; then
  #
  # This query summarizes information about pinned/locked/unpinned cursors
  # and their sizes
  #

  ##create_format_functions

  sqlplus -s /NOLOG << ! | egrep -v "Connected|ADDRESS|selected"

    connect $DBUSER

    set echo off
    set lines 200
    set pages 200

    column curtyp           heading curtyp      format a6 truncate
    column lmd              heading lmd         format a2
    column pmd              heading pmd         format a2
    column pc               heading pc          format a3
    column tot              heading total       format 999999999
    column cnt              heading count       format 999999999

    column sum_heap0        heading sum0        format 999999999
    column sum_heap4        heading sum4        format 999999999
    column sum_heap6        heading sum6        format 999999999

    column cnt_heap0        heading cnt0        format 999999999
    column cnt_heap4        heading cnt4        format 999999999
    column cnt_heap6        heading cnt6        format 999999999

    column avg_heap0        heading avg0        format 999999999
    column avg_heap4        heading avg4        format 999999999
    column avg_heap6        heading avg6        format 999999999

    column max_heap0        heading max0        format 999999999
    column max_heap4        heading max4        format 999999999
    column max_heap6        heading max6        format 999999999

    select /* ora pinned_cursors */
           case when pc = 'PAR' and lmd = '0' and pmd = '0' then 'Parent Freeable'
                when pc = 'PAR' and lmd = 'N' and pmd = '0' then 'Parent Inuse'
                when pc = 'CHI' and lmd = '0' and pmd = '0' then 'Child Freeable'
                when pc = 'CHI' and lmd = '0' and pmd = 'S' then 'Pseudo Cursor '
                when pc = 'CHI' and lmd = 'N' and pmd = '0' then 'Child Cached'
                when pc = 'CHI' and lmd = 'N' and pmd = 'S' then 'Child Executing'
             else 'Not Sure'
           end cursor_type,
           pc, lmd, pmd,
           (count(*))           cnt,
           (sum(tot))      tot,
           (count(decode(KGLOBHS0, 0, NULL, KGLOBHS0))) cnt_heap0,
           (count(decode(KGLOBHS6, 0, NULL, KGLOBHS6))) cnt_heap6,
           (sum(KGLOBHS0)) sum_heap0,
--           (sum(KGLOBHS4)) sum_heap4,
           (sum(KGLOBHS6)) sum_heap6,
           round((avg(KGLOBHS0))) avg_heap0,
--         (avg(KGLOBHS4)) avg_heap4,
           round(avg(KGLOBHS6)) avg_heap6,
           (max(KGLOBHS0)) max_heap0,
--           (max(KGLOBHS4)) max_heap4,
           (max(KGLOBHS6)) max_heap6
    from (
            select KGLOBHS0,
                   KGLOBHS4,
                   KGLOBHS6,
                   kglobhs0+kglobhs4+kglobhs6 tot,
                   decode(kglhdadr, kglhdpar, 'PAR', 'CHI') pc,
                   decode(kglhdlmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') lmd,
                   decode(kglhdpmd, 0, '0', 1, 'N', 2, 'S', 3, 'X', '?') pmd,
                   case
                      when KGLOBT09 = 65535 then
                            '0 PAR'
                      when KGLHDLMD = 1 and KGLHDPMD > 0 then
                            '1 PN CHI'
                      when KGLHDLMD = 1 then
                            '2 LK CHI'
                      else
                            '3 CHI'
                   end cursor_type
            from x\$kglcursor)
    group by pc, lmd, pmd
    order by pc desc, lmd, pmd;
    $ECHO

!
echo "Summarizes information about pinned/locked/unpinned cursors and their sizes"
  exit 0
fi

###################################################################################################
# Run a shell command. Useful when combined with repeat...
###################################################################################################
if [ "$1" = "sh" ]; then

  shift 1
  sh -fc "$*"
  echo "usage:ora repeat 5 10 sh 'ps -edf | grep DESC'"
  exit 0
fi

usage
echo "Command 'ora $1' not defined,please check the command again."